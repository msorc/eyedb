
/*
 * File 'DBM.h'
 *
 * Package Name 'DBM'
 *
 * Generated by eyedbodl at Sat Dec  3 12:43:51 2005
 *
 * -------------------------------------
 * ------- DO NOT EDIT THIS CODE -------
 * -------------------------------------
 *
 */

#include <eyedb/eyedb.h>

#ifndef _eyedb_DBM_
#define _eyedb_DBM_

using namespace eyedb;

namespace eyedb {

class UserEntry;
class DBUserAccess;
class SysUserAccess;
class DBEntry;
class DBPropertyValue;
class DBProperty;

class DBM {

 public:
  static void init();
  static void release();
  static Status updateSchema(Database *db);
  static Status updateSchema(Schema *m);
};

class DBMDatabase : public Database {

 public:
  DBMDatabase(const char *s, const char *_dbmdb_str = 0) : Database(s, _dbmdb_str) {}
  DBMDatabase(const char *s, int _dbid, const char *_dbmdb_str = 0) : Database(s, _dbid, _dbmdb_str) {}
  DBMDatabase(int _dbid, const char *_dbmdb_str = 0) : Database(_dbid, _dbmdb_str) {}
  Status open(Connection *, Database::OpenFlag, const char * = 0, const char * = 0);
  Status open(Connection *, Database::OpenFlag, const OpenHints *hints, const char * = 0, const char * = 0);
  static void setConsApp(Database *);
  static Status checkSchema(Schema *);
  static Bool getDynamicGetErrorPolicy();
  static Bool getDynamicSetErrorPolicy();
  static void setDynamicGetErrorPolicy(Bool policy);
  static void setDynamicSetErrorPolicy(Bool policy);
};

enum SysAccessMode {
  NoSysAccessMode = 0,
  DBCreateSysAccessMode = 256,
  AddUserSysAccessMode = 512,
  DeleteUserSysAccessMode = 1024,
  SetUserPasswdSysAccessMode = 2048,
  AdminSysAccessMode = 768,
  SuperUserSysAccessMode = 4095
};

enum DBAccessMode {
  NoDBAccessMode = 0,
  ReadDBAccessMode = 16,
  WriteDBAccessMode = 32,
  ExecDBAccessMode = 64,
  ReadWriteDBAccessMode = 48,
  ReadExecDBAccessMode = 80,
  ReadWriteExecDBAccessMode = 112,
  AdminDBAccessMode = 113
};

enum UserType {
  EyeDBUser = 1,
  UnixUser = 2,
  StrictUnixUser = 3
};

class UserEntry : public Struct {

 public:
  UserEntry(Database * = 0, const Dataspace * = 0);
  UserEntry(const UserEntry& x);

  virtual Object *clone() const {return new UserEntry(*this);};

  UserEntry& operator=(const UserEntry& x);

  virtual UserEntry *asUserEntry() {return this;}
  virtual const UserEntry *asUserEntry() const {return this;}

  Status name(const char *);
  Status name(unsigned int a0, char);
  const char *name(Bool *isnull = 0, Status * = 0) const;
  char name(unsigned int a0, Bool *isnull = 0, Status * = 0)  const;

  Status passwd(const char *);
  Status passwd(unsigned int a0, char);
  const char *passwd(Bool *isnull = 0, Status * = 0) const;
  char passwd(unsigned int a0, Bool *isnull = 0, Status * = 0)  const;

  Status uid(eyedblib::int32);
  eyedblib::int32 uid(Bool *isnull = 0, Status * = 0)  const;

  Status type(UserType, Bool _check_value = True);
  UserType type(Bool *isnull = 0, Status * = 0)  const;
  virtual ~UserEntry() {garbageRealize();}

 protected:
  UserEntry(Database *_db, const Dataspace *_dataspace, int) : Struct(_db, _dataspace) {}
  UserEntry(const Struct *x, Bool share, int) : Struct(x, share) {}
  UserEntry(const UserEntry *x, Bool share, int) : Struct(x, share) {}

 private:
  void initialize(Database *_db);

 public: /* restricted */
  UserEntry(const Struct *, Bool = False);
  UserEntry(const UserEntry *, Bool = False);
  UserEntry(const Class *, Data);
};

class DBUserAccess : public Struct {

 public:
  DBUserAccess(Database * = 0, const Dataspace * = 0);
  DBUserAccess(const DBUserAccess& x);

  virtual Object *clone() const {return new DBUserAccess(*this);};

  DBUserAccess& operator=(const DBUserAccess& x);

  virtual DBUserAccess *asDBUserAccess() {return this;}
  virtual const DBUserAccess *asDBUserAccess() const {return this;}

  Status dbentry(DBEntry*);
  DBEntry *dbentry(Bool *isnull = 0, Status * = 0) ;
  const DBEntry *dbentry(Bool *isnull = 0, Status * = 0) const;
  Oid dbentry_oid(Status * = 0);
  Status dbentry_oid(const Oid &);

  Status user(UserEntry*);
  UserEntry *user(Bool *isnull = 0, Status * = 0) ;
  const UserEntry *user(Bool *isnull = 0, Status * = 0) const;
  Oid user_oid(Status * = 0);
  Status user_oid(const Oid &);

  Status mode(DBAccessMode, Bool _check_value = True);
  DBAccessMode mode(Bool *isnull = 0, Status * = 0)  const;
  virtual ~DBUserAccess() {garbageRealize();}

 protected:
  DBUserAccess(Database *_db, const Dataspace *_dataspace, int) : Struct(_db, _dataspace) {}
  DBUserAccess(const Struct *x, Bool share, int) : Struct(x, share) {}
  DBUserAccess(const DBUserAccess *x, Bool share, int) : Struct(x, share) {}

 private:
  void initialize(Database *_db);

 public: /* restricted */
  DBUserAccess(const Struct *, Bool = False);
  DBUserAccess(const DBUserAccess *, Bool = False);
  DBUserAccess(const Class *, Data);
};

class SysUserAccess : public Struct {

 public:
  SysUserAccess(Database * = 0, const Dataspace * = 0);
  SysUserAccess(const SysUserAccess& x);

  virtual Object *clone() const {return new SysUserAccess(*this);};

  SysUserAccess& operator=(const SysUserAccess& x);

  virtual SysUserAccess *asSysUserAccess() {return this;}
  virtual const SysUserAccess *asSysUserAccess() const {return this;}

  Status user(UserEntry*);
  UserEntry *user(Bool *isnull = 0, Status * = 0) ;
  const UserEntry *user(Bool *isnull = 0, Status * = 0) const;
  Oid user_oid(Status * = 0);
  Status user_oid(const Oid &);

  Status mode(SysAccessMode, Bool _check_value = True);
  SysAccessMode mode(Bool *isnull = 0, Status * = 0)  const;
  virtual ~SysUserAccess() {garbageRealize();}

 protected:
  SysUserAccess(Database *_db, const Dataspace *_dataspace, int) : Struct(_db, _dataspace) {}
  SysUserAccess(const Struct *x, Bool share, int) : Struct(x, share) {}
  SysUserAccess(const SysUserAccess *x, Bool share, int) : Struct(x, share) {}

 private:
  void initialize(Database *_db);

 public: /* restricted */
  SysUserAccess(const Struct *, Bool = False);
  SysUserAccess(const SysUserAccess *, Bool = False);
  SysUserAccess(const Class *, Data);
};

class DBEntry : public Struct {

 public:
  DBEntry(Database * = 0, const Dataspace * = 0);
  DBEntry(const DBEntry& x);

  virtual Object *clone() const {return new DBEntry(*this);};

  DBEntry& operator=(const DBEntry& x);

  virtual DBEntry *asDBEntry() {return this;}
  virtual const DBEntry *asDBEntry() const {return this;}

  Status dbname(const char *);
  Status dbname(unsigned int a0, char);
  const char *dbname(Bool *isnull = 0, Status * = 0) const;
  char dbname(unsigned int a0, Bool *isnull = 0, Status * = 0)  const;

  Status dbid(eyedblib::int32);
  eyedblib::int32 dbid(Bool *isnull = 0, Status * = 0)  const;

  Status dbfile(const char *);
  Status dbfile(unsigned int a0, char);
  const char *dbfile(Bool *isnull = 0, Status * = 0) const;
  char dbfile(unsigned int a0, Bool *isnull = 0, Status * = 0)  const;

  Status default_access(DBAccessMode, Bool _check_value = True);
  DBAccessMode default_access(Bool *isnull = 0, Status * = 0)  const;

  Status schm(Object*);
  Object *schm(Bool *isnull = 0, Status * = 0) ;
  const Object *schm(Bool *isnull = 0, Status * = 0) const;
  Oid schm_oid(Status * = 0);
  Status schm_oid(const Oid &);

  Status comment(const char *);
  Status comment(unsigned int a0, char);
  const char *comment(Bool *isnull = 0, Status * = 0) const;
  char comment(unsigned int a0, Bool *isnull = 0, Status * = 0)  const;

  Status props(unsigned int a0, DBProperty*);
  DBProperty *props(unsigned int a0, Bool *isnull = 0, Status * = 0) ;
  const DBProperty *props(unsigned int a0, Bool *isnull = 0, Status * = 0) const;
  Oid props_oid(unsigned int a0, Status * = 0);
  Status props_oid(unsigned int a0, const Oid &);
  unsigned int props_cnt(Status * = 0) const;
  virtual ~DBEntry() {garbageRealize();}

 protected:
  DBEntry(Database *_db, const Dataspace *_dataspace, int) : Struct(_db, _dataspace) {}
  DBEntry(const Struct *x, Bool share, int) : Struct(x, share) {}
  DBEntry(const DBEntry *x, Bool share, int) : Struct(x, share) {}

 private:
  void initialize(Database *_db);

 public: /* restricted */
  DBEntry(const Struct *, Bool = False);
  DBEntry(const DBEntry *, Bool = False);
  DBEntry(const Class *, Data);
};

class DBPropertyValue : public Struct {

 public:
  DBPropertyValue(Database * = 0, const Dataspace * = 0);
  DBPropertyValue(const DBPropertyValue& x);

  virtual Object *clone() const {return new DBPropertyValue(*this);};

  DBPropertyValue& operator=(const DBPropertyValue& x);

  virtual DBPropertyValue *asDBPropertyValue() {return this;}
  virtual const DBPropertyValue *asDBPropertyValue() const {return this;}

  Status ival(eyedblib::int64);
  eyedblib::int64 ival(Bool *isnull = 0, Status * = 0)  const;

  Status sval(const char *);
  Status sval(unsigned int a0, char);
  const char *sval(Bool *isnull = 0, Status * = 0) const;
  char sval(unsigned int a0, Bool *isnull = 0, Status * = 0)  const;

  Status bval(const unsigned char *, unsigned int len);
  Status bval(unsigned int a0, unsigned char);
  Status bval_cnt(unsigned int a0);
  const unsigned char *bval(unsigned int *len, Bool *isnull = 0, Status * = 0) const;
  unsigned char bval(unsigned int a0, Bool *isnull = 0, Status * = 0)  const;
  unsigned int bval_cnt(Status * = 0) const;

  Status oval(Object*);
  Object *oval(Bool *isnull = 0, Status * = 0) ;
  const Object *oval(Bool *isnull = 0, Status * = 0) const;
  Oid oval_oid(Status * = 0);
  Status oval_oid(const Oid &);
  virtual ~DBPropertyValue() {garbageRealize();}

 protected:
  DBPropertyValue(Database *_db, const Dataspace *_dataspace, int) : Struct(_db, _dataspace) {}
  DBPropertyValue(const Struct *x, Bool share, int) : Struct(x, share) {}
  DBPropertyValue(const DBPropertyValue *x, Bool share, int) : Struct(x, share) {}

 private:
  void initialize(Database *_db);

 public: /* restricted */
  DBPropertyValue(const Struct *, Bool = False);
  DBPropertyValue(const DBPropertyValue *, Bool = False);
  DBPropertyValue(const Class *, Data);
};

class DBProperty : public Struct {

 public:
  DBProperty(Database * = 0, const Dataspace * = 0);
  DBProperty(const DBProperty& x);

  virtual Object *clone() const {return new DBProperty(*this);};

  DBProperty& operator=(const DBProperty& x);

  virtual DBProperty *asDBProperty() {return this;}
  virtual const DBProperty *asDBProperty() const {return this;}

  Status key(const char *);
  Status key(unsigned int a0, char);
  const char *key(Bool *isnull = 0, Status * = 0) const;
  char key(unsigned int a0, Bool *isnull = 0, Status * = 0)  const;

  Status value(DBPropertyValue*);
  DBPropertyValue *value(Bool *isnull = 0, Status * = 0) ;
  const DBPropertyValue *value(Bool *isnull = 0, Status * = 0) const;
  virtual ~DBProperty() {garbageRealize();}

 protected:
  DBProperty(Database *_db, const Dataspace *_dataspace, int) : Struct(_db, _dataspace) {}
  DBProperty(const Struct *x, Bool share, int) : Struct(x, share) {}
  DBProperty(const DBProperty *x, Bool share, int) : Struct(x, share) {}

 private:
  void initialize(Database *_db);

 public: /* restricted */
  DBProperty(const Struct *, Bool = False);
  DBProperty(const DBProperty *, Bool = False);
  DBProperty(const Class *, Data);
};


#define UserEntry_(X) ((UserEntry *)(X))

#define DBUserAccess_(X) ((DBUserAccess *)(X))

#define SysUserAccess_(X) ((SysUserAccess *)(X))

#define DBEntry_(X) ((DBEntry *)(X))

#define DBPropertyValue_(X) ((DBPropertyValue *)(X))

#define DBProperty_(X) ((DBProperty *)(X))

extern Object *DBMMakeObject(Object *, Bool=True);
extern Bool DBM_set_oid_check(Bool);
extern Bool DBM_get_oid_check();

}

#endif
