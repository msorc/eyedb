
/*
 * File 'syscls.h'
 *
 * Package Name 'syscls'
 *
 * Generated by eyedbodl at Sat Dec 10 15:43:55 2005
 *
 * -------------------------------------
 * ------- DO NOT EDIT THIS CODE -------
 * -------------------------------------
 *
 */

#include <eyedb/eyedb.h>

#ifndef _eyedb_syscls_
#define _eyedb_syscls_

using namespace eyedb;

namespace eyedb {

class AttributeComponent;
class AttributeComponentSet;
class ClassComponent;
class AgregatClassComponent;
class ClassVariable;
class Index;
class HashIndex;
class BTreeIndex;
class CollAttrImpl;
class ArgType;
class Signature;
class Executable;
class AgregatClassExecutable;
class Method;
class FEMethod;
class FEMethod_C;
class BEMethod;
class BEMethod_C;
class BEMethod_OQL;
class Trigger;
class UniqueConstraint;
class NotNullConstraint;
class CardinalityDescription;
class CardinalityConstraint;
class CardinalityConstraint_Test;
class ProtectionUser;
class Protection;
class UnreadableObject;
class ClassConversion;
class set_class_AttributeComponent_ref;

class syscls {

 public:
  static void init();
  static void release();
  static Status updateSchema(Database *db);
  static Status updateSchema(Schema *m);
};

class sysclsDatabase : public Database {

 public:
  sysclsDatabase(const char *s, const char *_dbmdb_str = 0) : Database(s, _dbmdb_str) {}
  sysclsDatabase(const char *s, int _dbid, const char *_dbmdb_str = 0) : Database(s, _dbid, _dbmdb_str) {}
  sysclsDatabase(int _dbid, const char *_dbmdb_str = 0) : Database(_dbid, _dbmdb_str) {}
  Status open(Connection *, Database::OpenFlag, const char * = 0, const char * = 0);
  Status open(Connection *, Database::OpenFlag, const OpenHints *hints, const char * = 0, const char * = 0);
  static void setConsApp(Database *);
  static Status checkSchema(Schema *);
  static Bool getDynamicGetErrorPolicy();
  static Bool getDynamicSetErrorPolicy();
  static void setDynamicGetErrorPolicy(Bool policy);
  static void setDynamicSetErrorPolicy(Bool policy);
};

enum IndexType {
  HashIndexType = 32,
  BTreeIndexType = 64
};

enum ExecutableLang {
  C_LANG = 1,
  OQL_LANG = 2,
  SYSTEM_EXEC = 256
};

enum ArgType_Type {
  ANY_TYPE = 0,
  VOID_TYPE = 1,
  INT16_TYPE = 2,
  INT32_TYPE = 3,
  INT64_TYPE = 4,
  STRING_TYPE = 5,
  CHAR_TYPE = 6,
  FLOAT_TYPE = 7,
  OID_TYPE = 8,
  OBJ_TYPE = 9,
  RAW_TYPE = 10,
  BYTE_TYPE = 11,
  ARRAY_TYPE = 256,
  IN_ARG_TYPE = 4096,
  OUT_ARG_TYPE = 8192,
  INOUT_ARG_TYPE = 12288
};

enum ExecutableLocalisation {
  BACKEND = 1,
  FRONTEND = 2,
  STATIC_EXEC = 256
};

enum ExecutableType {
  METHOD_C_TYPE = 2,
  METHOD_OQL_TYPE = 18,
  TRIGGER_C_TYPE = 8,
  TRIGGER_OQL_TYPE = 24
};

enum TriggerType {
  TriggerCREATE_BEFORE = 17,
  TriggerCREATE_AFTER = 18,
  TriggerUPDATE_BEFORE = 33,
  TriggerUPDATE_AFTER = 34,
  TriggerLOAD_BEFORE = 65,
  TriggerLOAD_AFTER = 66,
  TriggerREMOVE_BEFORE = 129,
  TriggerREMOVE_AFTER = 130
};

enum ProtectionMode {
  ProtRead = 256,
  ProtRW = 257
};

enum ClassUpdateType {
  ADD_ATTR = 0,
  RMV_ATTR = 1,
  CNV_ATTR = 2,
  MIG_ATTR = 3,
  RMV_CLASS = 4
};

enum AttributeConvertType {
  INT16_TO_INT16 = 0,
  INT16_TO_INT32 = 1,
  INT16_TO_INT64 = 2,
  INT16_TO_FLOAT = 3,
  INT16_TO_BYTE = 4,
  INT16_TO_CHAR = 5,
  INT16_TO_ENUM = 6,
  INT32_TO_INT32 = 7,
  INT32_TO_INT16 = 8,
  INT32_TO_INT64 = 9,
  INT32_TO_FLOAT = 10,
  INT32_TO_BYTE = 11,
  INT32_TO_CHAR = 12,
  INT32_TO_ENUM = 13,
  INT64_TO_INT64 = 14,
  INT64_TO_INT16 = 15,
  INT64_TO_INT32 = 16,
  INT64_TO_FLOAT = 17,
  INT64_TO_BYTE = 18,
  INT64_TO_CHAR = 19,
  INT64_TO_ENUM = 20,
  FLOAT_TO_FLOAT = 21,
  FLOAT_TO_INT16 = 22,
  FLOAT_TO_INT32 = 23,
  FLOAT_TO_INT64 = 24,
  FLOAT_TO_BYTE = 25,
  FLOAT_TO_CHAR = 26,
  FLOAT_TO_ENUM = 27,
  CHAR_TO_CHAR = 28,
  CHAR_TO_INT16 = 29,
  CHAR_TO_INT32 = 30,
  CHAR_TO_INT64 = 31,
  CHAR_TO_FLOAT = 32,
  CHAR_TO_BYTE = 33,
  CHAR_TO_ENUM = 34,
  BYTE_TO_BYTE = 35,
  BYTE_TO_INT16 = 36,
  BYTE_TO_INT32 = 37,
  BYTE_TO_INT64 = 38,
  BYTE_TO_FLOAT = 39,
  BYTE_TO_CHAR = 40,
  BYTE_TO_ENUM = 41,
  ENUM_TO_ENUM = 42,
  ENUM_TO_INT16 = 43,
  ENUM_TO_INT32 = 44,
  ENUM_TO_INT64 = 45,
  ENUM_TO_FLOAT = 46,
  ENUM_TO_CHAR = 47,
  ENUM_TO_BYTE = 48,
  CHAR_TO_STRING = 49,
  STRING_TO_CHAR = 50,
  INT16_TO_STRING = 51,
  STRING_TO_INT16 = 52,
  INT32_TO_STRING = 53,
  STRING_TO_INT32 = 54,
  INT64_TO_STRING = 55,
  STRING_TO_INT64 = 56,
  FLOAT_TO_STRING = 57,
  STRING_TO_FLOAT = 58,
  BYTE_TO_STRING = 59,
  STRING_TO_BYTE = 60,
  SET_TO_BAG = 61,
  SET_TO_ARRAY = 62,
  SET_TO_LIST = 63,
  BAG_TO_SET = 64,
  BAG_TO_ARRAY = 65,
  BAG_TO_LIST = 66,
  ARRAY_TO_BAG = 67,
  ARRAY_TO_SET = 68,
  ARRAY_TO_LIST = 69,
  LIST_TO_BAG = 70,
  LIST_TO_ARRAY = 71,
  LIST_TO_SET = 72,
  CLASS_TO_CLASS = 73,
  USER_CNV = 74,
  NIL_CNV = 75
};

class AttributeComponent : public Struct {

 public:
  AttributeComponent(Database * = 0, const Dataspace * = 0);
  AttributeComponent(const AttributeComponent& x);

  virtual Object *clone() const {return new AttributeComponent(*this);};

  AttributeComponent& operator=(const AttributeComponent& x);

  virtual AttributeComponent *asAttributeComponent() {return this;}
  virtual const AttributeComponent *asAttributeComponent() const {return this;}
  virtual Index *asIndex() {return (Index *)0;}
  virtual const Index *asIndex() const {return (const Index *)0;}
  virtual HashIndex *asHashIndex() {return (HashIndex *)0;}
  virtual const HashIndex *asHashIndex() const {return (const HashIndex *)0;}
  virtual BTreeIndex *asBTreeIndex() {return (BTreeIndex *)0;}
  virtual const BTreeIndex *asBTreeIndex() const {return (const BTreeIndex *)0;}
  virtual CollAttrImpl *asCollAttrImpl() {return (CollAttrImpl *)0;}
  virtual const CollAttrImpl *asCollAttrImpl() const {return (const CollAttrImpl *)0;}
  virtual UniqueConstraint *asUniqueConstraint() {return (UniqueConstraint *)0;}
  virtual const UniqueConstraint *asUniqueConstraint() const {return (const UniqueConstraint *)0;}
  virtual NotNullConstraint *asNotNullConstraint() {return (NotNullConstraint *)0;}
  virtual const NotNullConstraint *asNotNullConstraint() const {return (const NotNullConstraint *)0;}
  virtual CardinalityConstraint_Test *asCardinalityConstraint_Test() {return (CardinalityConstraint_Test *)0;}
  virtual const CardinalityConstraint_Test *asCardinalityConstraint_Test() const {return (const CardinalityConstraint_Test *)0;}

  Status setName(const char *);
  Status setName(unsigned int a0, char);
  const char *getName(Bool *isnull = 0, Status * = 0) const;
  char getName(unsigned int a0, Bool *isnull = 0, Status * = 0)  const;

  Status setAttrpath(const char *);
  Status setAttrpath(unsigned int a0, char);
  const char *getAttrpath(Bool *isnull = 0, Status * = 0) const;
  char getAttrpath(unsigned int a0, Bool *isnull = 0, Status * = 0)  const;

  Status setClassOwner(Class*);
  Class *getClassOwner(Bool *isnull = 0, Status * = 0) ;
  const Class *getClassOwner(Bool *isnull = 0, Status * = 0) const;
  Oid getClassOwnerOid(Status * = 0);
  Status setClassOwnerOid(const Oid &);

  Status setPropagate(Bool, Bool _check_value = True);
  Bool getPropagate(Bool *isnull = 0, Status * = 0)  const;
  virtual ~AttributeComponent() {garbageRealize();}
  // AttributeComponent User Part

    virtual Status m_trace(FILE *, int, unsigned int, const RecMode *) const;
    Status checkUnique(const char *, const char *);
    Status find(Database *db, const Class *cls,
  AttributeComponent *&);
    virtual AttributeComponent *xclone(Database *, const Class *);
    std::string makeAttrpath(const Class *cls);
    void userInitialize();
    void userCopy(const Object &);
    void userGarbage();
    virtual int getInd() const;
    

 protected:
  AttributeComponent(Database *_db, const Dataspace *_dataspace, int) : Struct(_db, _dataspace) {}
  AttributeComponent(const Struct *x, Bool share, int) : Struct(x, share) {}
  AttributeComponent(const AttributeComponent *x, Bool share, int) : Struct(x, share) {}

 private:
  void initialize(Database *_db);

 public: /* restricted */
  AttributeComponent(const Struct *, Bool = False);
  AttributeComponent(const AttributeComponent *, Bool = False);
  AttributeComponent(const Class *, Data);
};

class AttributeComponentSet : public Struct {

 public:
  AttributeComponentSet(Database * = 0, const Dataspace * = 0);
  AttributeComponentSet(const AttributeComponentSet& x);

  virtual Object *clone() const {return new AttributeComponentSet(*this);};

  AttributeComponentSet& operator=(const AttributeComponentSet& x);

  virtual AttributeComponentSet *asAttributeComponentSet() {return this;}
  virtual const AttributeComponentSet *asAttributeComponentSet() const {return this;}

  Status setAttrname(const char *);
  Status setAttrname(unsigned int a0, char);
  const char *getAttrname(Bool *isnull = 0, Status * = 0) const;
  char getAttrname(unsigned int a0, Bool *isnull = 0, Status * = 0)  const;

  Status setCompsColl(CollSet*);
  CollSet *getCompsColl(Bool *isnull = 0, Status * = 0) ;
  unsigned int getCompsCount(Bool *isnull = 0, Status *rs = 0) const {const Collection *_coll = getCompsColl(isnull, rs); return (_coll ? _coll->getCount() : 0);}
  const CollSet *getCompsColl(Bool *isnull = 0, Status * = 0) const;
  Status addToCompsColl(AttributeComponent*, Bool noDup = False, const IndexImpl * = 0);
  Status rmvFromCompsColl(AttributeComponent*, Bool checkFirst = False);
  Status addToCompsColl(const Oid &, const IndexImpl * = 0);
  Status rmvFromCompsColl(const Oid &);

  Status setClassOwner(Class*);
  Class *getClassOwner(Bool *isnull = 0, Status * = 0) ;
  const Class *getClassOwner(Bool *isnull = 0, Status * = 0) const;
  Oid getClassOwnerOid(Status * = 0);
  Status setClassOwnerOid(const Oid &);
  virtual ~AttributeComponentSet() {garbageRealize();}
  // AttributeComponentSet User Part

    void userInitialize();
    void userCopy(const Object &);
    void userGarbage();

    Status find(const char *, Index *&);
    Status find(const char *, NotNullConstraint *&);
    Status find(const char *, UniqueConstraint *&);
    Status find(const char *, CollAttrImpl *&);
    Status find(const char *, CardinalityConstraint_Test *&);
    Status getAttrComponents(const Class *, LinkedList &);

  private:
    struct Cache {
      unsigned int comp_count;
      unsigned int comp_alloc;
      struct Comp {
 char *attrpath;
 AttributeComponent *comp;
 Comp();
 ~Comp();
      } *comps;
      Cache();
      void add(AttributeComponent *);
      void getComponents(const char *, int, LinkedList &);
      AttributeComponent *find(const char *attrpath);
      ~Cache();
    };

    Status makeCache();
    void invalidateCache();

    Cache *index_cache, *notnull_cache, *unique_cache, *card_cache, *collimpl_cache;
    friend class Attribute;
    

 protected:
  AttributeComponentSet(Database *_db, const Dataspace *_dataspace, int) : Struct(_db, _dataspace) {}
  AttributeComponentSet(const Struct *x, Bool share, int) : Struct(x, share) {}
  AttributeComponentSet(const AttributeComponentSet *x, Bool share, int) : Struct(x, share) {}

 private:
  void initialize(Database *_db);

 public: /* restricted */
  AttributeComponentSet(const Struct *, Bool = False);
  AttributeComponentSet(const AttributeComponentSet *, Bool = False);
  AttributeComponentSet(const Class *, Data);
};

class ClassComponent : public Struct {

 public:
  ClassComponent(Database * = 0, const Dataspace * = 0);
  ClassComponent(const ClassComponent& x);

  virtual Object *clone() const {return new ClassComponent(*this);};

  ClassComponent& operator=(const ClassComponent& x);

  virtual ClassComponent *asClassComponent() {return this;}
  virtual const ClassComponent *asClassComponent() const {return this;}
  virtual AgregatClassComponent *asAgregatClassComponent() {return (AgregatClassComponent *)0;}
  virtual const AgregatClassComponent *asAgregatClassComponent() const {return (const AgregatClassComponent *)0;}
  virtual ClassVariable *asClassVariable() {return (ClassVariable *)0;}
  virtual const ClassVariable *asClassVariable() const {return (const ClassVariable *)0;}
  virtual AgregatClassExecutable *asAgregatClassExecutable() {return (AgregatClassExecutable *)0;}
  virtual const AgregatClassExecutable *asAgregatClassExecutable() const {return (const AgregatClassExecutable *)0;}
  virtual Method *asMethod() {return (Method *)0;}
  virtual const Method *asMethod() const {return (const Method *)0;}
  virtual FEMethod *asFEMethod() {return (FEMethod *)0;}
  virtual const FEMethod *asFEMethod() const {return (const FEMethod *)0;}
  virtual FEMethod_C *asFEMethod_C() {return (FEMethod_C *)0;}
  virtual const FEMethod_C *asFEMethod_C() const {return (const FEMethod_C *)0;}
  virtual BEMethod *asBEMethod() {return (BEMethod *)0;}
  virtual const BEMethod *asBEMethod() const {return (const BEMethod *)0;}
  virtual BEMethod_C *asBEMethod_C() {return (BEMethod_C *)0;}
  virtual const BEMethod_C *asBEMethod_C() const {return (const BEMethod_C *)0;}
  virtual BEMethod_OQL *asBEMethod_OQL() {return (BEMethod_OQL *)0;}
  virtual const BEMethod_OQL *asBEMethod_OQL() const {return (const BEMethod_OQL *)0;}
  virtual Trigger *asTrigger() {return (Trigger *)0;}
  virtual const Trigger *asTrigger() const {return (const Trigger *)0;}
  virtual CardinalityConstraint *asCardinalityConstraint() {return (CardinalityConstraint *)0;}
  virtual const CardinalityConstraint *asCardinalityConstraint() const {return (const CardinalityConstraint *)0;}

  Status setClassOwner(Class*);
  Class *getClassOwner(Bool *isnull = 0, Status * = 0) ;
  const Class *getClassOwner(Bool *isnull = 0, Status * = 0) const;
  Oid getClassOwnerOid(Status * = 0);
  Status setClassOwnerOid(const Oid &);

  Status setName(const char *);
  Status setName(unsigned int a0, char);
  const char *getName(Bool *isnull = 0, Status * = 0) const;
  char getName(unsigned int a0, Bool *isnull = 0, Status * = 0)  const;
  virtual ~ClassComponent() {garbageRealize();}
  // ClassComponent User Part

    virtual Status check(Class *) const;
    virtual Bool isInherit() const;
    virtual Status m_trace(FILE *, int, unsigned int, const RecMode *) const;
    virtual int getInd() const;
    virtual Status make(Class *);
    virtual Status realize(const RecMode* = NoRecurs);
    virtual Status remove(const RecMode* = NoRecurs);
    virtual Status realize_for_update();
    virtual Status remove_for_update();
    

 protected:
  ClassComponent(Database *_db, const Dataspace *_dataspace, int) : Struct(_db, _dataspace) {}
  ClassComponent(const Struct *x, Bool share, int) : Struct(x, share) {}
  ClassComponent(const ClassComponent *x, Bool share, int) : Struct(x, share) {}

 private:
  void initialize(Database *_db);

 public: /* restricted */
  ClassComponent(const Struct *, Bool = False);
  ClassComponent(const ClassComponent *, Bool = False);
  ClassComponent(const Class *, Data);
};

class AgregatClassComponent : public ClassComponent {

 public:
  AgregatClassComponent(Database * = 0, const Dataspace * = 0);
  AgregatClassComponent(const AgregatClassComponent& x);

  virtual Object *clone() const {return new AgregatClassComponent(*this);};

  AgregatClassComponent& operator=(const AgregatClassComponent& x);

  virtual AgregatClassComponent *asAgregatClassComponent() {return this;}
  virtual const AgregatClassComponent *asAgregatClassComponent() const {return this;}
  virtual AgregatClassExecutable *asAgregatClassExecutable() {return (AgregatClassExecutable *)0;}
  virtual const AgregatClassExecutable *asAgregatClassExecutable() const {return (const AgregatClassExecutable *)0;}
  virtual Method *asMethod() {return (Method *)0;}
  virtual const Method *asMethod() const {return (const Method *)0;}
  virtual FEMethod *asFEMethod() {return (FEMethod *)0;}
  virtual const FEMethod *asFEMethod() const {return (const FEMethod *)0;}
  virtual FEMethod_C *asFEMethod_C() {return (FEMethod_C *)0;}
  virtual const FEMethod_C *asFEMethod_C() const {return (const FEMethod_C *)0;}
  virtual BEMethod *asBEMethod() {return (BEMethod *)0;}
  virtual const BEMethod *asBEMethod() const {return (const BEMethod *)0;}
  virtual BEMethod_C *asBEMethod_C() {return (BEMethod_C *)0;}
  virtual const BEMethod_C *asBEMethod_C() const {return (const BEMethod_C *)0;}
  virtual BEMethod_OQL *asBEMethod_OQL() {return (BEMethod_OQL *)0;}
  virtual const BEMethod_OQL *asBEMethod_OQL() const {return (const BEMethod_OQL *)0;}
  virtual Trigger *asTrigger() {return (Trigger *)0;}
  virtual const Trigger *asTrigger() const {return (const Trigger *)0;}
  virtual CardinalityConstraint *asCardinalityConstraint() {return (CardinalityConstraint *)0;}
  virtual const CardinalityConstraint *asCardinalityConstraint() const {return (const CardinalityConstraint *)0;}
  virtual ~AgregatClassComponent() {garbageRealize();}

 protected:
  AgregatClassComponent(Database *_db, const Dataspace *_dataspace, int) : ClassComponent(_db, _dataspace, 1) {}
  AgregatClassComponent(const Struct *x, Bool share, int) : ClassComponent(x, share, 1) {}
  AgregatClassComponent(const AgregatClassComponent *x, Bool share, int) : ClassComponent(x, share, 1) {}

 private:
  void initialize(Database *_db);

 public: /* restricted */
  AgregatClassComponent(const Struct *, Bool = False);
  AgregatClassComponent(const AgregatClassComponent *, Bool = False);
  AgregatClassComponent(const Class *, Data);
};

class ClassVariable : public ClassComponent {

 public:
  ClassVariable(Database * = 0, const Dataspace * = 0);
  ClassVariable(const ClassVariable& x);

  virtual Object *clone() const {return new ClassVariable(*this);};

  ClassVariable& operator=(const ClassVariable& x);

  virtual ClassVariable *asClassVariable() {return this;}
  virtual const ClassVariable *asClassVariable() const {return this;}

  Status setVname(const char *);
  Status setVname(unsigned int a0, char);
  const char *getVname(Bool *isnull = 0, Status * = 0) const;
  char getVname(unsigned int a0, Bool *isnull = 0, Status * = 0)  const;

  Status setVal(Object*);
  Object *getVal(Bool *isnull = 0, Status * = 0) ;
  const Object *getVal(Bool *isnull = 0, Status * = 0) const;
  Oid getValOid(Status * = 0);
  Status setValOid(const Oid &);
  virtual ~ClassVariable() {garbageRealize();}
  // ClassVariable User Part

    Status check(Class *) const;
    Bool isInherit() const;
    Status m_trace(FILE *, int, unsigned int, const RecMode *) const;
    int getInd() const;
    Status m_trace(FILE *, int, unsigned int, const RecMode *);
    

 protected:
  ClassVariable(Database *_db, const Dataspace *_dataspace, int) : ClassComponent(_db, _dataspace, 1) {}
  ClassVariable(const Struct *x, Bool share, int) : ClassComponent(x, share, 1) {}
  ClassVariable(const ClassVariable *x, Bool share, int) : ClassComponent(x, share, 1) {}

 private:
  void initialize(Database *_db);

 public: /* restricted */
  ClassVariable(const Struct *, Bool = False);
  ClassVariable(const ClassVariable *, Bool = False);
  ClassVariable(const Class *, Data);
};

class Index : public AttributeComponent {

 public:
  Index(Database * = 0, const Dataspace * = 0);
  Index(const Index& x);

  virtual Object *clone() const {return new Index(*this);};

  Index& operator=(const Index& x);

  virtual Index *asIndex() {return this;}
  virtual const Index *asIndex() const {return this;}
  virtual HashIndex *asHashIndex() {return (HashIndex *)0;}
  virtual const HashIndex *asHashIndex() const {return (const HashIndex *)0;}
  virtual BTreeIndex *asBTreeIndex() {return (BTreeIndex *)0;}
  virtual const BTreeIndex *asBTreeIndex() const {return (const BTreeIndex *)0;}

  Status setIdxOid(Oid);
  Oid getIdxOid(Bool *isnull = 0, Status * = 0)  const;

  Status setDspid(eyedblib::int16);
  eyedblib::int16 getDspid(Bool *isnull = 0, Status * = 0)  const;

  Status setIsString(Bool, Bool _check_value = True);
  Bool getIsString(Bool *isnull = 0, Status * = 0)  const;

  Status setImplHints(unsigned int a0, eyedblib::int32);
  Status setImplHintsCount(unsigned int a0);
  eyedblib::int32 getImplHints(unsigned int a0, Bool *isnull = 0, Status * = 0)  const;
  unsigned int getImplHintsCount(Status * = 0) const;
  virtual ~Index() {garbageRealize();}
  // Index User Part

    Index(Database *, const char *, const char *);
    virtual Status realize(const RecMode* = NoRecurs);
    virtual Status remove(const RecMode* = NoRecurs);
    virtual Status s_trace(FILE *, Bool, unsigned int flags = 0) const;
    Idx *idx;
    Status makeDataspace(Database *db, const Dataspace *&) const;

    void userInitialize();
    void userCopy(const Object &);
    void userGarbage();
    Status move(const Dataspace *) const;
    short get_dspid() const;
    Bool compareHints(Index *idx);
    int getInd() const;


    Status getCount(unsigned int &count);
    Status getStats(std::string &, Bool dspImpl = True,
      Bool full = False, const char *indent = "");
    Status getStats(IndexStats *&stats);
    Status simulate(const IndexImpl &, std::string &,
      Bool dspImpl = True, Bool full = False,
      const char *indent = "");
    Status simulate(const IndexImpl &, IndexStats *&stats);

    Status reimplement(const IndexImpl &, Index *&);
    virtual Status setImplementation(const IndexImpl *) {return Success;}
    virtual Status getImplementation(IndexImpl *&, Bool remote = False) const {return 0;}
    Status getDefaultDataspace(const Dataspace *&) const;
    Status setDefaultDataspace(const Dataspace *);
    Status getObjectLocations(ObjectLocationArray &);
    virtual Status report(eyedbsm::DbHandle *sedbh, const Oid &idxoid);
    

 protected:
  Index(Database *_db, const Dataspace *_dataspace, int) : AttributeComponent(_db, _dataspace, 1) {}
  Index(const Struct *x, Bool share, int) : AttributeComponent(x, share, 1) {}
  Index(const Index *x, Bool share, int) : AttributeComponent(x, share, 1) {}

 private:
  void initialize(Database *_db);

 public: /* restricted */
  Index(const Struct *, Bool = False);
  Index(const Index *, Bool = False);
  Index(const Class *, Data);
};

class HashIndex : public Index {

 public:
  HashIndex(Database * = 0, const Dataspace * = 0);
  HashIndex(const HashIndex& x);

  virtual Object *clone() const {return new HashIndex(*this);};

  HashIndex& operator=(const HashIndex& x);

  virtual HashIndex *asHashIndex() {return this;}
  virtual const HashIndex *asHashIndex() const {return this;}

  Status setHashMethod(BEMethod_C*);
  BEMethod_C *getHashMethod(Bool *isnull = 0, Status * = 0) ;
  const BEMethod_C *getHashMethod(Bool *isnull = 0, Status * = 0) const;
  Oid getHashMethodOid(Status * = 0);
  Status setHashMethodOid(const Oid &);

  Status setKeyCount(eyedblib::int32);
  eyedblib::int32 getKeyCount(Bool *isnull = 0, Status * = 0)  const;
  virtual ~HashIndex() {garbageRealize();}
  // HashIndex User Part

    HashIndex(Database *, Class *, const char *attrpath,
       Bool propagate, Bool is_string,
       const Dataspace * = 0, int key_count = 0,
       BEMethod_C * = 0,
       const int *impl_hints = 0, int impl_hints_cnt = 0);
    HashIndex(Database *, Class *, const char *attrpath,
       Bool propagate, Bool is_string,
       const IndexImpl *idximpl);
    static Status make(Database *, Class *, const char *attrpath,
         Bool propagate, Bool is_string,
         const char *hints, HashIndex *&);
    Status setImplementation(const IndexImpl *);
    Status getImplementation(IndexImpl *&, Bool remote = False) const;
    virtual AttributeComponent *xclone(Database *, const Class *);
    Status check(Class *) const;
    Status make(Class *);
    Status realize(const RecMode* = NoRecurs);
    Status remove(const RecMode* = NoRecurs);
    Status s_trace(FILE *, Bool, unsigned int flags = 0) const;
    Status m_trace(FILE *, int, unsigned int, const RecMode *) const;
    Bool compareHashMethod(HashIndex *idx);
    const char *genName() const;
    virtual Status report(eyedbsm::DbHandle *sedbh, const Oid &idxoid);
    

 protected:
  HashIndex(Database *_db, const Dataspace *_dataspace, int) : Index(_db, _dataspace, 1) {}
  HashIndex(const Struct *x, Bool share, int) : Index(x, share, 1) {}
  HashIndex(const HashIndex *x, Bool share, int) : Index(x, share, 1) {}

 private:
  void initialize(Database *_db);

 public: /* restricted */
  HashIndex(const Struct *, Bool = False);
  HashIndex(const HashIndex *, Bool = False);
  HashIndex(const Class *, Data);
};

class BTreeIndex : public Index {

 public:
  BTreeIndex(Database * = 0, const Dataspace * = 0);
  BTreeIndex(const BTreeIndex& x);

  virtual Object *clone() const {return new BTreeIndex(*this);};

  BTreeIndex& operator=(const BTreeIndex& x);

  virtual BTreeIndex *asBTreeIndex() {return this;}
  virtual const BTreeIndex *asBTreeIndex() const {return this;}

  Status setDegree(eyedblib::int32);
  eyedblib::int32 getDegree(Bool *isnull = 0, Status * = 0)  const;
  virtual ~BTreeIndex() {garbageRealize();}
  // BTreeIndex User Part

    BTreeIndex(Database *, Class *,
        const char *attrpath, Bool propagate, Bool is_string,
        const Dataspace * = 0, int degree = 0,
        const int *impl_hints = 0, int impl_hints_cnt = 0);
    BTreeIndex(Database *, Class *, const char *pathattr,
        Bool propagate, Bool is_string,
        const IndexImpl *idximpl);
    static Status make(Database *, Class *, const char *attrpath,
         Bool propagate, Bool is_string,
         const char *hints, BTreeIndex *&);
    Status setImplementation(const IndexImpl *);
    Status getImplementation(IndexImpl *&, Bool remote = False) const;
    virtual AttributeComponent *xclone(Database *, const Class *);
    Status check(Class *) const;
    Status realize(const RecMode* = NoRecurs);
    Status remove(const RecMode* = NoRecurs);
    Status s_trace(FILE *, Bool, unsigned int flags = 0) const;
    Status m_trace(FILE *, int, unsigned int, const RecMode *) const;
    const char *genName() const;
    virtual Status report(eyedbsm::DbHandle *sedbh, const Oid &idxoid);
    

 protected:
  BTreeIndex(Database *_db, const Dataspace *_dataspace, int) : Index(_db, _dataspace, 1) {}
  BTreeIndex(const Struct *x, Bool share, int) : Index(x, share, 1) {}
  BTreeIndex(const BTreeIndex *x, Bool share, int) : Index(x, share, 1) {}

 private:
  void initialize(Database *_db);

 public: /* restricted */
  BTreeIndex(const Struct *, Bool = False);
  BTreeIndex(const BTreeIndex *, Bool = False);
  BTreeIndex(const Class *, Data);
};

class CollAttrImpl : public AttributeComponent {

 public:
  CollAttrImpl(Database * = 0, const Dataspace * = 0);
  CollAttrImpl(const CollAttrImpl& x);

  virtual Object *clone() const {return new CollAttrImpl(*this);};

  CollAttrImpl& operator=(const CollAttrImpl& x);

  virtual CollAttrImpl *asCollAttrImpl() {return this;}
  virtual const CollAttrImpl *asCollAttrImpl() const {return this;}

  Status setIdxtype(eyedblib::int32);
  eyedblib::int32 getIdxtype(Bool *isnull = 0, Status * = 0)  const;

  Status setDspid(eyedblib::int16);
  eyedblib::int16 getDspid(Bool *isnull = 0, Status * = 0)  const;

  Status setKeyCountOrDegree(eyedblib::int32);
  eyedblib::int32 getKeyCountOrDegree(Bool *isnull = 0, Status * = 0)  const;

  Status setHashMethod(BEMethod_C*);
  BEMethod_C *getHashMethod(Bool *isnull = 0, Status * = 0) ;
  const BEMethod_C *getHashMethod(Bool *isnull = 0, Status * = 0) const;
  Oid getHashMethodOid(Status * = 0);
  Status setHashMethodOid(const Oid &);

  Status setImplHints(unsigned int a0, eyedblib::int32);
  Status setImplHintsCount(unsigned int a0);
  eyedblib::int32 getImplHints(unsigned int a0, Bool *isnull = 0, Status * = 0)  const;
  unsigned int getImplHintsCount(Status * = 0) const;
  virtual ~CollAttrImpl() {garbageRealize();}
  // CollAttrImpl User Part

    CollAttrImpl(Database *, Class *, const char *attrpath,
   Bool propagate, const Dataspace * = 0,
   IndexImpl::Type = IndexImpl::Hash,
   int key_count_or_degree = 0,
   BEMethod_C * = 0,
   const int *impl_hints = 0, int impl_hints_cnt = 0);
    CollAttrImpl(Database *, Class *, const char *attrpath,
   Bool propagate, const IndexImpl *idximpl);

    Status makeDataspace(Database *db, const Dataspace *&) const;
    static Status make(Database *, Class *, const char *attrpath,
         Bool propagate,
         IndexImpl::Type, const char *hints,
         CollAttrImpl *&);
    Status getImplementation(Database *, const IndexImpl *&);
    virtual AttributeComponent *xclone(Database *, const Class *);
    Status realize(const RecMode* = NoRecurs);
    Status remove(const RecMode* = NoRecurs);
    Status s_trace(FILE *, Bool, unsigned int flags = 0) const;
    Status m_trace(FILE *, int, unsigned int, const RecMode *) const;
    const char *genName() const;
    int getInd() const;

    void userInitialize();
    void userCopy(const Object &);
    void userGarbage();

    const Dataspace *dsp;
    IndexImpl *idximpl;
    

 protected:
  CollAttrImpl(Database *_db, const Dataspace *_dataspace, int) : AttributeComponent(_db, _dataspace, 1) {}
  CollAttrImpl(const Struct *x, Bool share, int) : AttributeComponent(x, share, 1) {}
  CollAttrImpl(const CollAttrImpl *x, Bool share, int) : AttributeComponent(x, share, 1) {}

 private:
  void initialize(Database *_db);

 public: /* restricted */
  CollAttrImpl(const Struct *, Bool = False);
  CollAttrImpl(const CollAttrImpl *, Bool = False);
  CollAttrImpl(const Class *, Data);
};

class ArgType : public Struct {

 public:
  ArgType(Database * = 0, const Dataspace * = 0);
  ArgType(const ArgType& x);

  virtual Object *clone() const {return new ArgType(*this);};

  ArgType& operator=(const ArgType& x);

  virtual ArgType *asArgType() {return this;}
  virtual const ArgType *asArgType() const {return this;}

  Status setType(ArgType_Type, Bool _check_value = True);
  ArgType_Type getType(Bool *isnull = 0, Status * = 0)  const;

  Status setClname(const char *);
  Status setClname(unsigned int a0, char);
  const char *getClname(Bool *isnull = 0, Status * = 0) const;
  char getClname(unsigned int a0, Bool *isnull = 0, Status * = 0)  const;
  virtual ~ArgType() {garbageRealize();}
  // ArgType User Part

    Bool operator==(const ArgType &) const;

    Bool operator!=(const ArgType &) const;
    static ArgType *make(Schema *m, const char *s);
    static int getBasicType(const char *s);
    void declare(FILE *, Schema *, const char *name);
    void init(FILE *, Schema *, const char *prefix, const char *name,
       const char *indent);
    void ret(FILE *, Schema *, const char *prefix, const char *name);
    const char *getCType(Schema *) const;
    void getCPrefix(FILE *fd, Schema *, const char *prefix,
      const char *name, Bool fullcast) const;
    

 protected:
  ArgType(Database *_db, const Dataspace *_dataspace, int) : Struct(_db, _dataspace) {}
  ArgType(const Struct *x, Bool share, int) : Struct(x, share) {}
  ArgType(const ArgType *x, Bool share, int) : Struct(x, share) {}

 private:
  void initialize(Database *_db);

 public: /* restricted */
  ArgType(const Struct *, Bool = False);
  ArgType(const ArgType *, Bool = False);
  ArgType(const Class *, Data);
};

class Signature : public Struct {

 public:
  Signature(Database * = 0, const Dataspace * = 0);
  Signature(const Signature& x);

  virtual Object *clone() const {return new Signature(*this);};

  Signature& operator=(const Signature& x);

  virtual Signature *asSignature() {return this;}
  virtual const Signature *asSignature() const {return this;}

  Status setRettype(ArgType*);
  ArgType *getRettype(Bool *isnull = 0, Status * = 0) ;
  const ArgType *getRettype(Bool *isnull = 0, Status * = 0) const;

  Status setNargs(eyedblib::int32);
  eyedblib::int32 getNargs(Bool *isnull = 0, Status * = 0)  const;

  Status setTypes(unsigned int a0, ArgType*);
  Status setTypesCount(unsigned int a0);
  ArgType *getTypes(unsigned int a0, Bool *isnull = 0, Status * = 0) ;
  const ArgType *getTypes(unsigned int a0, Bool *isnull = 0, Status * = 0) const;
  unsigned int getTypesCount(Status * = 0) const;
  virtual ~Signature() {garbageRealize();}
  // Signature User Part

    Bool operator ==(const Signature &) const;
    Bool operator !=(const Signature &) const;
    const char *getArg(int i);
    static const char *getPrefix(const char *prefix, int i);
    static Bool isVoid(const ArgType *type);
    void listArgs(FILE *, Schema *);
    void declArgs(FILE *, Schema *);
    void initArgs(FILE *, Schema *, const char *prefix, const char *preret,
    const char *indent);
    void setArgs(FILE *, Schema *, int type, const char *prefix,
   const char *preret, const char *indent);
    void retArgs(FILE *, Schema *, const char *prefix, const char *preret,
   const char *indent);
    

 protected:
  Signature(Database *_db, const Dataspace *_dataspace, int) : Struct(_db, _dataspace) {}
  Signature(const Struct *x, Bool share, int) : Struct(x, share) {}
  Signature(const Signature *x, Bool share, int) : Struct(x, share) {}

 private:
  void initialize(Database *_db);

 public: /* restricted */
  Signature(const Struct *, Bool = False);
  Signature(const Signature *, Bool = False);
  Signature(const Class *, Data);
};

class Executable : public Struct {

 public:
  Executable(Database * = 0, const Dataspace * = 0);
  Executable(const Executable& x);

  virtual Object *clone() const {return new Executable(*this);};

  Executable& operator=(const Executable& x);

  virtual Executable *asExecutable() {return this;}
  virtual const Executable *asExecutable() const {return this;}

  Status setExname(const char *);
  Status setExname(unsigned int a0, char);
  const char *getExname(Bool *isnull = 0, Status * = 0) const;
  char getExname(unsigned int a0, Bool *isnull = 0, Status * = 0)  const;

  Status setLang(ExecutableLang, Bool _check_value = True);
  ExecutableLang getLang(Bool *isnull = 0, Status * = 0)  const;

  Status setLoc(ExecutableLocalisation, Bool _check_value = True);
  ExecutableLocalisation getLoc(Bool *isnull = 0, Status * = 0)  const;

  Status setSign(Signature*);
  Signature *getSign(Bool *isnull = 0, Status * = 0) ;
  const Signature *getSign(Bool *isnull = 0, Status * = 0) const;

  Status setIntname(const char *);
  Status setIntname(unsigned int a0, char);
  const char *getIntname(Bool *isnull = 0, Status * = 0) const;
  char getIntname(unsigned int a0, Bool *isnull = 0, Status * = 0)  const;

  Status setExtrefBody(const char *);
  Status setExtrefBody(unsigned int a0, char);
  const char *getExtrefBody(Bool *isnull = 0, Status * = 0) const;
  char getExtrefBody(unsigned int a0, Bool *isnull = 0, Status * = 0)  const;
  virtual ~Executable() {garbageRealize();}
  // Executable User Part

    void initExec(const char *exname,
    ExecutableLang lang,
    Bool isSystem,
    ExecutableLocalisation loc,
    Signature *sign, Class * = 0);
    static const char *makeInternalName(const char *exname,
     const Signature *sign,
     Bool isClassMethod,
     const char *clname = 0);
    const char *_getPrototype(const Class *, Bool scope) const;
    static const char *makeExtRef(const char *extref);
    static const char *getSOTag();
    static const char *getSOFile(const char *extref);
    static void *_dlopen(const char *extref);
    int isStaticExec() const;
    void *dl;
    void userInitialize();
    void userCopy(const Object &);
    virtual Status execCheck();
    Status checkRealize(const char *, const char *, void **);
    static Status checkRealize(const char *extref, const char *intname,
          void **pdl, void **pcsym);
    

 protected:
  Executable(Database *_db, const Dataspace *_dataspace, int) : Struct(_db, _dataspace) {}
  Executable(const Struct *x, Bool share, int) : Struct(x, share) {}
  Executable(const Executable *x, Bool share, int) : Struct(x, share) {}

 private:
  void initialize(Database *_db);

 public: /* restricted */
  Executable(const Struct *, Bool = False);
  Executable(const Executable *, Bool = False);
  Executable(const Class *, Data);
};

class AgregatClassExecutable : public AgregatClassComponent {

 public:
  AgregatClassExecutable(Database * = 0, const Dataspace * = 0);
  AgregatClassExecutable(const AgregatClassExecutable& x);

  virtual Object *clone() const {return new AgregatClassExecutable(*this);};

  AgregatClassExecutable& operator=(const AgregatClassExecutable& x);

  virtual AgregatClassExecutable *asAgregatClassExecutable() {return this;}
  virtual const AgregatClassExecutable *asAgregatClassExecutable() const {return this;}
  virtual Method *asMethod() {return (Method *)0;}
  virtual const Method *asMethod() const {return (const Method *)0;}
  virtual FEMethod *asFEMethod() {return (FEMethod *)0;}
  virtual const FEMethod *asFEMethod() const {return (const FEMethod *)0;}
  virtual FEMethod_C *asFEMethod_C() {return (FEMethod_C *)0;}
  virtual const FEMethod_C *asFEMethod_C() const {return (const FEMethod_C *)0;}
  virtual BEMethod *asBEMethod() {return (BEMethod *)0;}
  virtual const BEMethod *asBEMethod() const {return (const BEMethod *)0;}
  virtual BEMethod_C *asBEMethod_C() {return (BEMethod_C *)0;}
  virtual const BEMethod_C *asBEMethod_C() const {return (const BEMethod_C *)0;}
  virtual BEMethod_OQL *asBEMethod_OQL() {return (BEMethod_OQL *)0;}
  virtual const BEMethod_OQL *asBEMethod_OQL() const {return (const BEMethod_OQL *)0;}
  virtual Trigger *asTrigger() {return (Trigger *)0;}
  virtual const Trigger *asTrigger() const {return (const Trigger *)0;}

  Status setEx(Executable*);
  Executable *getEx(Bool *isnull = 0, Status * = 0) ;
  const Executable *getEx(Bool *isnull = 0, Status * = 0) const;
  virtual ~AgregatClassExecutable() {garbageRealize();}

 protected:
  AgregatClassExecutable(Database *_db, const Dataspace *_dataspace, int) : AgregatClassComponent(_db, _dataspace, 1) {}
  AgregatClassExecutable(const Struct *x, Bool share, int) : AgregatClassComponent(x, share, 1) {}
  AgregatClassExecutable(const AgregatClassExecutable *x, Bool share, int) : AgregatClassComponent(x, share, 1) {}

 private:
  void initialize(Database *_db);

 public: /* restricted */
  AgregatClassExecutable(const Struct *, Bool = False);
  AgregatClassExecutable(const AgregatClassExecutable *, Bool = False);
  AgregatClassExecutable(const Class *, Data);
};

class Method : public AgregatClassExecutable {

 public:
  Method(Database * = 0, const Dataspace * = 0);
  Method(const Method& x);

  virtual Object *clone() const {return new Method(*this);};

  Method& operator=(const Method& x);

  virtual Method *asMethod() {return this;}
  virtual const Method *asMethod() const {return this;}
  virtual FEMethod *asFEMethod() {return (FEMethod *)0;}
  virtual const FEMethod *asFEMethod() const {return (const FEMethod *)0;}
  virtual FEMethod_C *asFEMethod_C() {return (FEMethod_C *)0;}
  virtual const FEMethod_C *asFEMethod_C() const {return (const FEMethod_C *)0;}
  virtual BEMethod *asBEMethod() {return (BEMethod *)0;}
  virtual const BEMethod *asBEMethod() const {return (const BEMethod *)0;}
  virtual BEMethod_C *asBEMethod_C() {return (BEMethod_C *)0;}
  virtual const BEMethod_C *asBEMethod_C() const {return (const BEMethod_C *)0;}
  virtual BEMethod_OQL *asBEMethod_OQL() {return (BEMethod_OQL *)0;}
  virtual const BEMethod_OQL *asBEMethod_OQL() const {return (const BEMethod_OQL *)0;}
  virtual ~Method() {garbageRealize();}
  // Method User Part

    virtual Status applyTo(Database *, Object *, ArgArray &,
      Argument &retarg, Bool checkArgs);
    Status realize(const RecMode* = NoRecurs);
    Status remove(const RecMode* = NoRecurs);

    static Status get(Database *, Class *, const char *name,
        const Signature *, Bool isClassMethod,
        Method * &);

    static Status getSignature(Database *, Class *,
          const char *sign_str, Signature *&,
          char *&fname);

    static Status get(Database *, Class *,
        const char *sign_str, Bool isClassMethod,
        Method * &);

    const char *getPrototype(Bool scope = True) const;

    Status check(Class *) const;
    Bool isInherit() const;
    Status m_trace(FILE *, int, unsigned int, const RecMode *) const;
    int getInd() const;
    virtual Status execCheck();
    

 protected:
  Method(Database *_db, const Dataspace *_dataspace, int) : AgregatClassExecutable(_db, _dataspace, 1) {}
  Method(const Struct *x, Bool share, int) : AgregatClassExecutable(x, share, 1) {}
  Method(const Method *x, Bool share, int) : AgregatClassExecutable(x, share, 1) {}

 private:
  void initialize(Database *_db);

 public: /* restricted */
  Method(const Struct *, Bool = False);
  Method(const Method *, Bool = False);
  Method(const Class *, Data);
};

class FEMethod : public Method {

 public:
  FEMethod(Database * = 0, const Dataspace * = 0);
  FEMethod(const FEMethod& x);

  virtual Object *clone() const {return new FEMethod(*this);};

  FEMethod& operator=(const FEMethod& x);

  virtual FEMethod *asFEMethod() {return this;}
  virtual const FEMethod *asFEMethod() const {return this;}
  virtual FEMethod_C *asFEMethod_C() {return (FEMethod_C *)0;}
  virtual const FEMethod_C *asFEMethod_C() const {return (const FEMethod_C *)0;}
  virtual ~FEMethod() {garbageRealize();}

 protected:
  FEMethod(Database *_db, const Dataspace *_dataspace, int) : Method(_db, _dataspace, 1) {}
  FEMethod(const Struct *x, Bool share, int) : Method(x, share, 1) {}
  FEMethod(const FEMethod *x, Bool share, int) : Method(x, share, 1) {}

 private:
  void initialize(Database *_db);

 public: /* restricted */
  FEMethod(const Struct *, Bool = False);
  FEMethod(const FEMethod *, Bool = False);
  FEMethod(const Class *, Data);
};

class FEMethod_C : public FEMethod {

 public:
  FEMethod_C(Database * = 0, const Dataspace * = 0);
  FEMethod_C(const FEMethod_C& x);

  virtual Object *clone() const {return new FEMethod_C(*this);};

  FEMethod_C& operator=(const FEMethod_C& x);

  virtual FEMethod_C *asFEMethod_C() {return this;}
  virtual const FEMethod_C *asFEMethod_C() const {return this;}
  virtual ~FEMethod_C() {garbageRealize();}
  // FEMethod_C User Part

    Status (*csym)(Database *, FEMethod_C *, Object *,
     ArgArray &array, Argument &retarg);
    FEMethod_C(Database *, Class *, const char *name,
        Signature *, Bool isClassMethod,
        Bool isSystem, const char *extref);
    Status execCheck();
    Status applyTo(Database *, Object *, ArgArray &, Argument &retarg, Bool checkArgs);
    void userInitialize();
    void userCopy(const Object &);
    

 protected:
  FEMethod_C(Database *_db, const Dataspace *_dataspace, int) : FEMethod(_db, _dataspace, 1) {}
  FEMethod_C(const Struct *x, Bool share, int) : FEMethod(x, share, 1) {}
  FEMethod_C(const FEMethod_C *x, Bool share, int) : FEMethod(x, share, 1) {}

 private:
  void initialize(Database *_db);

 public: /* restricted */
  FEMethod_C(const Struct *, Bool = False);
  FEMethod_C(const FEMethod_C *, Bool = False);
  FEMethod_C(const Class *, Data);
};

class BEMethod : public Method {

 public:
  BEMethod(Database * = 0, const Dataspace * = 0);
  BEMethod(const BEMethod& x);

  virtual Object *clone() const {return new BEMethod(*this);};

  BEMethod& operator=(const BEMethod& x);

  virtual BEMethod *asBEMethod() {return this;}
  virtual const BEMethod *asBEMethod() const {return this;}
  virtual BEMethod_C *asBEMethod_C() {return (BEMethod_C *)0;}
  virtual const BEMethod_C *asBEMethod_C() const {return (const BEMethod_C *)0;}
  virtual BEMethod_OQL *asBEMethod_OQL() {return (BEMethod_OQL *)0;}
  virtual const BEMethod_OQL *asBEMethod_OQL() const {return (const BEMethod_OQL *)0;}
  virtual ~BEMethod() {garbageRealize();}

 protected:
  BEMethod(Database *_db, const Dataspace *_dataspace, int) : Method(_db, _dataspace, 1) {}
  BEMethod(const Struct *x, Bool share, int) : Method(x, share, 1) {}
  BEMethod(const BEMethod *x, Bool share, int) : Method(x, share, 1) {}

 private:
  void initialize(Database *_db);

 public: /* restricted */
  BEMethod(const Struct *, Bool = False);
  BEMethod(const BEMethod *, Bool = False);
  BEMethod(const Class *, Data);
};

class BEMethod_C : public BEMethod {

 public:
  BEMethod_C(Database * = 0, const Dataspace * = 0);
  BEMethod_C(const BEMethod_C& x);

  virtual Object *clone() const {return new BEMethod_C(*this);};

  BEMethod_C& operator=(const BEMethod_C& x);

  virtual BEMethod_C *asBEMethod_C() {return this;}
  virtual const BEMethod_C *asBEMethod_C() const {return this;}
  virtual ~BEMethod_C() {garbageRealize();}
  // BEMethod_C User Part

    Status (*csym)(Database *, BEMethod *, Object *,
     ArgArray &array, Argument &retarg);
    BEMethod_C(Database *, Class *, const char *name,
        Signature *, Bool isClassMethod,
        Bool isSystem, const char *extref);
    Status execCheck();
    Status applyTo(Database *, Object *, ArgArray &, Argument &retarg, Bool checkArgs);
    

 protected:
  BEMethod_C(Database *_db, const Dataspace *_dataspace, int) : BEMethod(_db, _dataspace, 1) {}
  BEMethod_C(const Struct *x, Bool share, int) : BEMethod(x, share, 1) {}
  BEMethod_C(const BEMethod_C *x, Bool share, int) : BEMethod(x, share, 1) {}

 private:
  void initialize(Database *_db);

 public: /* restricted */
  BEMethod_C(const Struct *, Bool = False);
  BEMethod_C(const BEMethod_C *, Bool = False);
  BEMethod_C(const Class *, Data);
};

class BEMethod_OQL : public BEMethod {

 public:
  BEMethod_OQL(Database * = 0, const Dataspace * = 0);
  BEMethod_OQL(const BEMethod_OQL& x);

  virtual Object *clone() const {return new BEMethod_OQL(*this);};

  BEMethod_OQL& operator=(const BEMethod_OQL& x);

  virtual BEMethod_OQL *asBEMethod_OQL() {return this;}
  virtual const BEMethod_OQL *asBEMethod_OQL() const {return this;}
  virtual ~BEMethod_OQL() {garbageRealize();}
  // BEMethod_OQL User Part

    BEMethod_OQL(Database *, Class *, const char *name,
   Signature *, Bool isClassMethod,
   Bool isSystem, const char *body);

    Status execCheck();
    Status setBody(const char *);
    Status applyTo(Database *, Object *, ArgArray &,
     Argument &retarg, Bool checkArgs);

    static std::string makeExtrefBody(const Class *cls, const char *oql,
          const char *fname,
          char *typnames[],
          char *varnames[],
          unsigned int param_cnt,
          std::string &oqlConstruct);
    Status runtimeInit();

    Bool isRTInitialized;
    char **varnames;
    int param_cnt;
    char *funcname;
    char *body;
    char *fullBody;
    char *tmpbuf;
    void *entry;

    void userInitialize();
    void userGarbage();
    void userCopy(const Object &);
    

 protected:
  BEMethod_OQL(Database *_db, const Dataspace *_dataspace, int) : BEMethod(_db, _dataspace, 1) {}
  BEMethod_OQL(const Struct *x, Bool share, int) : BEMethod(x, share, 1) {}
  BEMethod_OQL(const BEMethod_OQL *x, Bool share, int) : BEMethod(x, share, 1) {}

 private:
  void initialize(Database *_db);

 public: /* restricted */
  BEMethod_OQL(const Struct *, Bool = False);
  BEMethod_OQL(const BEMethod_OQL *, Bool = False);
  BEMethod_OQL(const Class *, Data);
};

class Trigger : public AgregatClassExecutable {

 public:
  Trigger(Database * = 0, const Dataspace * = 0);
  Trigger(const Trigger& x);

  virtual Object *clone() const {return new Trigger(*this);};

  Trigger& operator=(const Trigger& x);

  virtual Trigger *asTrigger() {return this;}
  virtual const Trigger *asTrigger() const {return this;}

  Status setType(TriggerType, Bool _check_value = True);
  TriggerType getType(Bool *isnull = 0, Status * = 0)  const;

  Status setLight(eyedblib::int32);
  eyedblib::int32 getLight(Bool *isnull = 0, Status * = 0)  const;

  Status setSuffix(const char *);
  Status setSuffix(unsigned int a0, char);
  const char *getSuffix(Bool *isnull = 0, Status * = 0) const;
  char getSuffix(unsigned int a0, Bool *isnull = 0, Status * = 0)  const;
  virtual ~Trigger() {garbageRealize();}
  // Trigger User Part

    Trigger(Database *, Class *, TriggerType,
     ExecutableLang, Bool isSystem, const char *suffix,
     Bool light, const char *extref);
    Status (*csym)(TriggerType, Database *, const Oid &,
     Object *);
    Status apply(const Oid &, Object *);
    Status realize(const RecMode* = NoRecurs);
    Status remove(const RecMode* = NoRecurs);
    const char *getPrototype(Bool scope = True) const;
    const char *getCSym() const;
    static const char *getStrTriggerType(TriggerType);
    Bool isInherit() const;
    Status m_trace(FILE *, int, unsigned int, const RecMode *) const;
    int getInd() const;

    static std::string makeExtrefBody(const Class *cls, const char *oql,
          const char *fname,
          std::string &oqlConstruct);
    Status runtimeInit();

    Bool isRTInitialized;
    char *funcname;
    char *body;
    char *fullBody;
    char *tmpbuf;
    void *entry;

    void userInitialize();
    void userGarbage();
    void userCopy(const Object &);
    

 protected:
  Trigger(Database *_db, const Dataspace *_dataspace, int) : AgregatClassExecutable(_db, _dataspace, 1) {}
  Trigger(const Struct *x, Bool share, int) : AgregatClassExecutable(x, share, 1) {}
  Trigger(const Trigger *x, Bool share, int) : AgregatClassExecutable(x, share, 1) {}

 private:
  void initialize(Database *_db);

 public: /* restricted */
  Trigger(const Struct *, Bool = False);
  Trigger(const Trigger *, Bool = False);
  Trigger(const Class *, Data);
};

class UniqueConstraint : public AttributeComponent {

 public:
  UniqueConstraint(Database * = 0, const Dataspace * = 0);
  UniqueConstraint(const UniqueConstraint& x);

  virtual Object *clone() const {return new UniqueConstraint(*this);};

  UniqueConstraint& operator=(const UniqueConstraint& x);

  virtual UniqueConstraint *asUniqueConstraint() {return this;}
  virtual const UniqueConstraint *asUniqueConstraint() const {return this;}
  virtual ~UniqueConstraint() {garbageRealize();}
  // UniqueConstraint User Part

    UniqueConstraint(Database *, Class *, const char *attrpath,
       Bool propagate);
    Status m_trace(FILE *, int, unsigned int, const RecMode *) const;
    Status realize(const RecMode* = NoRecurs);
    Status remove(const RecMode* = NoRecurs);
    virtual AttributeComponent *xclone(Database *, const Class *);
    const char *genName() const;
    int getInd() const;
    

 protected:
  UniqueConstraint(Database *_db, const Dataspace *_dataspace, int) : AttributeComponent(_db, _dataspace, 1) {}
  UniqueConstraint(const Struct *x, Bool share, int) : AttributeComponent(x, share, 1) {}
  UniqueConstraint(const UniqueConstraint *x, Bool share, int) : AttributeComponent(x, share, 1) {}

 private:
  void initialize(Database *_db);

 public: /* restricted */
  UniqueConstraint(const Struct *, Bool = False);
  UniqueConstraint(const UniqueConstraint *, Bool = False);
  UniqueConstraint(const Class *, Data);
};

class NotNullConstraint : public AttributeComponent {

 public:
  NotNullConstraint(Database * = 0, const Dataspace * = 0);
  NotNullConstraint(const NotNullConstraint& x);

  virtual Object *clone() const {return new NotNullConstraint(*this);};

  NotNullConstraint& operator=(const NotNullConstraint& x);

  virtual NotNullConstraint *asNotNullConstraint() {return this;}
  virtual const NotNullConstraint *asNotNullConstraint() const {return this;}
  virtual ~NotNullConstraint() {garbageRealize();}
  // NotNullConstraint User Part

    NotNullConstraint(Database *, Class *, const char *attrpath,
        Bool propagate);
    Status m_trace(FILE *, int, unsigned int, const RecMode *) const;
    Status realize(const RecMode* = NoRecurs);
    Status remove(const RecMode* = NoRecurs);
    virtual AttributeComponent *xclone(Database *, const Class *);
    const char *genName() const;
    int getInd() const;
    

 protected:
  NotNullConstraint(Database *_db, const Dataspace *_dataspace, int) : AttributeComponent(_db, _dataspace, 1) {}
  NotNullConstraint(const Struct *x, Bool share, int) : AttributeComponent(x, share, 1) {}
  NotNullConstraint(const NotNullConstraint *x, Bool share, int) : AttributeComponent(x, share, 1) {}

 private:
  void initialize(Database *_db);

 public: /* restricted */
  NotNullConstraint(const Struct *, Bool = False);
  NotNullConstraint(const NotNullConstraint *, Bool = False);
  NotNullConstraint(const Class *, Data);
};

class CardinalityDescription : public Struct {

 public:
  CardinalityDescription(Database * = 0, const Dataspace * = 0);
  CardinalityDescription(const CardinalityDescription& x);

  virtual Object *clone() const {return new CardinalityDescription(*this);};

  CardinalityDescription& operator=(const CardinalityDescription& x);

  virtual CardinalityDescription *asCardinalityDescription() {return this;}
  virtual const CardinalityDescription *asCardinalityDescription() const {return this;}

  Status setBottom(eyedblib::int32);
  eyedblib::int32 getBottom(Bool *isnull = 0, Status * = 0)  const;

  Status setBottomExcl(eyedblib::int32);
  eyedblib::int32 getBottomExcl(Bool *isnull = 0, Status * = 0)  const;

  Status setTop(eyedblib::int32);
  eyedblib::int32 getTop(Bool *isnull = 0, Status * = 0)  const;

  Status setTopExcl(eyedblib::int32);
  eyedblib::int32 getTopExcl(Bool *isnull = 0, Status * = 0)  const;
  virtual ~CardinalityDescription() {garbageRealize();}
  // CardinalityDescription User Part

    const char *getString(Bool = True) const;
    Bool compare(CardinalityDescription *);
    

 protected:
  CardinalityDescription(Database *_db, const Dataspace *_dataspace, int) : Struct(_db, _dataspace) {}
  CardinalityDescription(const Struct *x, Bool share, int) : Struct(x, share) {}
  CardinalityDescription(const CardinalityDescription *x, Bool share, int) : Struct(x, share) {}

 private:
  void initialize(Database *_db);

 public: /* restricted */
  CardinalityDescription(const Struct *, Bool = False);
  CardinalityDescription(const CardinalityDescription *, Bool = False);
  CardinalityDescription(const Class *, Data);
};

class CardinalityConstraint : public AgregatClassComponent {

 public:
  CardinalityConstraint(Database * = 0, const Dataspace * = 0);
  CardinalityConstraint(const CardinalityConstraint& x);

  virtual Object *clone() const {return new CardinalityConstraint(*this);};

  CardinalityConstraint& operator=(const CardinalityConstraint& x);

  virtual CardinalityConstraint *asCardinalityConstraint() {return this;}
  virtual const CardinalityConstraint *asCardinalityConstraint() const {return this;}

  Status setAttrname(const char *);
  Status setAttrname(unsigned int a0, char);
  const char *getAttrname(Bool *isnull = 0, Status * = 0) const;
  char getAttrname(unsigned int a0, Bool *isnull = 0, Status * = 0)  const;

  Status setCardDesc(CardinalityDescription*);
  CardinalityDescription *getCardDesc(Bool *isnull = 0, Status * = 0) ;
  const CardinalityDescription *getCardDesc(Bool *isnull = 0, Status * = 0) const;
  virtual ~CardinalityConstraint() {garbageRealize();}
  // CardinalityConstraint User Part

    CardinalityConstraint(Database *, Class *,
     const char *attrname, int, int, int, int);
    Status check(Class *) const;
    const char *genName() const;
    Bool isInherit() const;
    Status make(Class *);
    Status m_trace(FILE *, int, unsigned int, const RecMode *) const;
    int getInd() const;
    static int maxint;
    

 protected:
  CardinalityConstraint(Database *_db, const Dataspace *_dataspace, int) : AgregatClassComponent(_db, _dataspace, 1) {}
  CardinalityConstraint(const Struct *x, Bool share, int) : AgregatClassComponent(x, share, 1) {}
  CardinalityConstraint(const CardinalityConstraint *x, Bool share, int) : AgregatClassComponent(x, share, 1) {}

 private:
  void initialize(Database *_db);

 public: /* restricted */
  CardinalityConstraint(const Struct *, Bool = False);
  CardinalityConstraint(const CardinalityConstraint *, Bool = False);
  CardinalityConstraint(const Class *, Data);
};

class CardinalityConstraint_Test : public AttributeComponent {

 public:
  CardinalityConstraint_Test(Database * = 0, const Dataspace * = 0);
  CardinalityConstraint_Test(const CardinalityConstraint_Test& x);

  virtual Object *clone() const {return new CardinalityConstraint_Test(*this);};

  CardinalityConstraint_Test& operator=(const CardinalityConstraint_Test& x);

  virtual CardinalityConstraint_Test *asCardinalityConstraint_Test() {return this;}
  virtual const CardinalityConstraint_Test *asCardinalityConstraint_Test() const {return this;}

  Status setCardDesc(CardinalityDescription*);
  CardinalityDescription *getCardDesc(Bool *isnull = 0, Status * = 0) ;
  const CardinalityDescription *getCardDesc(Bool *isnull = 0, Status * = 0) const;
  virtual ~CardinalityConstraint_Test() {garbageRealize();}
  // CardinalityConstraint_Test User Part

    CardinalityConstraint_Test(Database *, Class *,
          const char *attrpath,
          int, int, int, int);
    Status realize(const RecMode* = NoRecurs);
    Status remove(const RecMode* = NoRecurs);
    const char *genName() const;
    Status m_trace(FILE *, int, unsigned int, const RecMode *) const;
    static int maxint;
    int getInd() const;
    

 protected:
  CardinalityConstraint_Test(Database *_db, const Dataspace *_dataspace, int) : AttributeComponent(_db, _dataspace, 1) {}
  CardinalityConstraint_Test(const Struct *x, Bool share, int) : AttributeComponent(x, share, 1) {}
  CardinalityConstraint_Test(const CardinalityConstraint_Test *x, Bool share, int) : AttributeComponent(x, share, 1) {}

 private:
  void initialize(Database *_db);

 public: /* restricted */
  CardinalityConstraint_Test(const Struct *, Bool = False);
  CardinalityConstraint_Test(const CardinalityConstraint_Test *, Bool = False);
  CardinalityConstraint_Test(const Class *, Data);
};

class ProtectionUser : public Struct {

 public:
  ProtectionUser(Database * = 0, const Dataspace * = 0);
  ProtectionUser(const ProtectionUser& x);

  virtual Object *clone() const {return new ProtectionUser(*this);};

  ProtectionUser& operator=(const ProtectionUser& x);

  virtual ProtectionUser *asProtectionUser() {return this;}
  virtual const ProtectionUser *asProtectionUser() const {return this;}

  Status setUser(Object*);
  Object *getUser(Bool *isnull = 0, Status * = 0) ;
  const Object *getUser(Bool *isnull = 0, Status * = 0) const;
  Oid getUserOid(Status * = 0);
  Status setUserOid(const Oid &);

  Status setMode(ProtectionMode, Bool _check_value = True);
  ProtectionMode getMode(Bool *isnull = 0, Status * = 0)  const;
  virtual ~ProtectionUser() {garbageRealize();}

 protected:
  ProtectionUser(Database *_db, const Dataspace *_dataspace, int) : Struct(_db, _dataspace) {}
  ProtectionUser(const Struct *x, Bool share, int) : Struct(x, share) {}
  ProtectionUser(const ProtectionUser *x, Bool share, int) : Struct(x, share) {}

 private:
  void initialize(Database *_db);

 public: /* restricted */
  ProtectionUser(const Struct *, Bool = False);
  ProtectionUser(const ProtectionUser *, Bool = False);
  ProtectionUser(const Class *, Data);
};

class Protection : public Struct {

 public:
  Protection(Database * = 0, const Dataspace * = 0);
  Protection(const Protection& x);

  virtual Object *clone() const {return new Protection(*this);};

  Protection& operator=(const Protection& x);

  virtual Protection *asProtection() {return this;}
  virtual const Protection *asProtection() const {return this;}

  Status setName(const char *);
  Status setName(unsigned int a0, char);
  const char *getName(Bool *isnull = 0, Status * = 0) const;
  char getName(unsigned int a0, Bool *isnull = 0, Status * = 0)  const;

  Status setPusers(unsigned int a0, ProtectionUser*);
  Status setPusersCount(unsigned int a0);
  ProtectionUser *getPusers(unsigned int a0, Bool *isnull = 0, Status * = 0) ;
  const ProtectionUser *getPusers(unsigned int a0, Bool *isnull = 0, Status * = 0) const;
  unsigned int getPusersCount(Status * = 0) const;

  Status setPoid(Oid);
  Oid getPoid(Bool *isnull = 0, Status * = 0)  const;
  virtual ~Protection() {garbageRealize();}
  // Protection User Part

    Status realize(const RecMode* = NoRecurs);
    Status remove(const RecMode* = NoRecurs);
    

 protected:
  Protection(Database *_db, const Dataspace *_dataspace, int) : Struct(_db, _dataspace) {}
  Protection(const Struct *x, Bool share, int) : Struct(x, share) {}
  Protection(const Protection *x, Bool share, int) : Struct(x, share) {}

 private:
  void initialize(Database *_db);

 public: /* restricted */
  Protection(const Struct *, Bool = False);
  Protection(const Protection *, Bool = False);
  Protection(const Class *, Data);
};

class UnreadableObject : public Struct {

 public:
  UnreadableObject(Database * = 0, const Dataspace * = 0);
  UnreadableObject(const UnreadableObject& x);

  virtual Object *clone() const {return new UnreadableObject(*this);};

  UnreadableObject& operator=(const UnreadableObject& x);

  virtual UnreadableObject *asUnreadableObject() {return this;}
  virtual const UnreadableObject *asUnreadableObject() const {return this;}
  virtual ~UnreadableObject() {garbageRealize();}
  // UnreadableObject User Part

    Status trace_realize(FILE*, int, unsigned int, const RecMode *) const;
    static Bool isUnreadableObject(const Object *);
    static Bool isUnreadableObject(const Class *);
    

 protected:
  UnreadableObject(Database *_db, const Dataspace *_dataspace, int) : Struct(_db, _dataspace) {}
  UnreadableObject(const Struct *x, Bool share, int) : Struct(x, share) {}
  UnreadableObject(const UnreadableObject *x, Bool share, int) : Struct(x, share) {}

 private:
  void initialize(Database *_db);

 public: /* restricted */
  UnreadableObject(const Struct *, Bool = False);
  UnreadableObject(const UnreadableObject *, Bool = False);
  UnreadableObject(const Class *, Data);
};

class ClassConversion : public Struct {

 public:
  ClassConversion(Database * = 0, const Dataspace * = 0);
  ClassConversion(const ClassConversion& x);

  virtual Object *clone() const {return new ClassConversion(*this);};

  ClassConversion& operator=(const ClassConversion& x);

  virtual ClassConversion *asClassConversion() {return this;}
  virtual const ClassConversion *asClassConversion() const {return this;}

  Status setUpdtype(ClassUpdateType, Bool _check_value = True);
  ClassUpdateType getUpdtype(Bool *isnull = 0, Status * = 0)  const;

  Status setCnvtype(AttributeConvertType, Bool _check_value = True);
  AttributeConvertType getCnvtype(Bool *isnull = 0, Status * = 0)  const;

  Status setClsname(const char *);
  Status setClsname(unsigned int a0, char);
  const char *getClsname(Bool *isnull = 0, Status * = 0) const;
  char getClsname(unsigned int a0, Bool *isnull = 0, Status * = 0)  const;

  Status setAttrname(const char *);
  Status setAttrname(unsigned int a0, char);
  const char *getAttrname(Bool *isnull = 0, Status * = 0) const;
  char getAttrname(unsigned int a0, Bool *isnull = 0, Status * = 0)  const;

  Status setAttrnum(eyedblib::int32);
  eyedblib::int32 getAttrnum(Bool *isnull = 0, Status * = 0)  const;

  Status setOidO(Oid);
  Oid getOidO(Bool *isnull = 0, Status * = 0)  const;

  Status setOidN(Oid);
  Oid getOidN(Bool *isnull = 0, Status * = 0)  const;

  Status setRoidO(Oid);
  Oid getRoidO(Bool *isnull = 0, Status * = 0)  const;

  Status setSync(eyedblib::int32);
  eyedblib::int32 getSync(Bool *isnull = 0, Status * = 0)  const;

  Status setWithCheck(eyedblib::int32);
  eyedblib::int32 getWithCheck(Bool *isnull = 0, Status * = 0)  const;

  Status setSrcDim(eyedblib::int32);
  eyedblib::int32 getSrcDim(Bool *isnull = 0, Status * = 0)  const;

  Status setDestDim(eyedblib::int32);
  eyedblib::int32 getDestDim(Bool *isnull = 0, Status * = 0)  const;

  Status setOffsetO(eyedblib::int32);
  eyedblib::int32 getOffsetO(Bool *isnull = 0, Status * = 0)  const;

  Status setOffsetN(eyedblib::int32);
  eyedblib::int32 getOffsetN(Bool *isnull = 0, Status * = 0)  const;

  Status setSizeO(eyedblib::int32);
  eyedblib::int32 getSizeO(Bool *isnull = 0, Status * = 0)  const;

  Status setSizeN(eyedblib::int32);
  eyedblib::int32 getSizeN(Bool *isnull = 0, Status * = 0)  const;

  Status setCnvMth(BEMethod_C*);
  BEMethod_C *getCnvMth(Bool *isnull = 0, Status * = 0) ;
  const BEMethod_C *getCnvMth(Bool *isnull = 0, Status * = 0) const;
  Oid getCnvMthOid(Status * = 0);
  Status setCnvMthOid(const Oid &);
  virtual ~ClassConversion() {garbageRealize();}
  // ClassConversion User Part

    struct Context {
      const Class *cls;
      ObjectArray obj_arr;
      Context *next;
      Context();
      ~Context();
    };

    const Class *cls_;
    const Attribute *attr_;
    static Status getClass_(Database *, const Oid &ocloid,
       const Class *&,
       ClassConversion::Context *&,
       Bool class_to_class = False);
    static Status convert(Database *, const ClassConversion::Context *,
     Data in_idr, Size in_size);
    Status convert(Database *db, Data in_idr, Size &in_size);
    static Size computeSize(ClassConversion::Context *conv_ctx,
       Size start_size);
    void computeSize(Size &cur_size);

    static void init();
    static void _release();

    void userInitialize();
    void userCopy(const Object &);
    void userGarbage();
    

 protected:
  ClassConversion(Database *_db, const Dataspace *_dataspace, int) : Struct(_db, _dataspace) {}
  ClassConversion(const Struct *x, Bool share, int) : Struct(x, share) {}
  ClassConversion(const ClassConversion *x, Bool share, int) : Struct(x, share) {}

 private:
  void initialize(Database *_db);

 public: /* restricted */
  ClassConversion(const Struct *, Bool = False);
  ClassConversion(const ClassConversion *, Bool = False);
  ClassConversion(const Class *, Data);
};


#define AttributeComponent_(X) ((AttributeComponent *)(X))

#define AttributeComponentSet_(X) ((AttributeComponentSet *)(X))

#define ClassComponent_(X) ((ClassComponent *)(X))

#define AgregatClassComponent_(X) ((AgregatClassComponent *)(X))

#define ClassVariable_(X) ((ClassVariable *)(X))

#define Index_(X) ((Index *)(X))

#define HashIndex_(X) ((HashIndex *)(X))

#define BTreeIndex_(X) ((BTreeIndex *)(X))

#define CollAttrImpl_(X) ((CollAttrImpl *)(X))

#define ArgType_(X) ((ArgType *)(X))

#define Signature_(X) ((Signature *)(X))

#define Executable_(X) ((Executable *)(X))

#define AgregatClassExecutable_(X) ((AgregatClassExecutable *)(X))

#define Method_(X) ((Method *)(X))

#define FEMethod_(X) ((FEMethod *)(X))

#define FEMethodC_(X) ((FEMethod_C *)(X))

#define BEMethod_(X) ((BEMethod *)(X))

#define BEMethodC_(X) ((BEMethod_C *)(X))

#define BEMethodOQL_(X) ((BEMethod_OQL *)(X))

#define Trigger_(X) ((Trigger *)(X))

#define UniqueConstraint_(X) ((UniqueConstraint *)(X))

#define NotNullConstraint_(X) ((NotNullConstraint *)(X))

#define CardinalityDescription_(X) ((CardinalityDescription *)(X))

#define CardinalityConstraint_(X) ((CardinalityConstraint *)(X))

#define CardinalityConstraintTest_(X) ((CardinalityConstraint_Test *)(X))

#define ProtectionUser_(X) ((ProtectionUser *)(X))

#define Protection_(X) ((Protection *)(X))

#define UnreadableObject_(X) ((UnreadableObject *)(X))

#define ClassConversion_(X) ((ClassConversion *)(X))

extern Object *sysclsMakeObject(Object *, Bool=True);
extern Bool syscls_set_oid_check(Bool);
extern Bool syscls_get_oid_check();

extern EnumClass *IndexType_Class;
extern EnumClass *ExecutableLang_Class;
extern EnumClass *ArgType_Type_Class;
extern EnumClass *ExecutableLocalisation_Class;
extern EnumClass *ExecutableType_Class;
extern EnumClass *TriggerType_Class;
extern EnumClass *ProtectionMode_Class;
extern EnumClass *ClassUpdateType_Class;
extern EnumClass *AttributeConvertType_Class;
extern StructClass *AttributeComponent_Class;
extern StructClass *AttributeComponentSet_Class;
extern StructClass *ClassComponent_Class;
extern StructClass *AgregatClassComponent_Class;
extern StructClass *ClassVariable_Class;
extern StructClass *Index_Class;
extern StructClass *HashIndex_Class;
extern StructClass *BTreeIndex_Class;
extern StructClass *CollAttrImpl_Class;
extern StructClass *ArgType_Class;
extern StructClass *Signature_Class;
extern StructClass *Executable_Class;
extern StructClass *AgregatClassExecutable_Class;
extern StructClass *Method_Class;
extern StructClass *FEMethod_Class;
extern StructClass *FEMethod_C_Class;
extern StructClass *BEMethod_Class;
extern StructClass *BEMethod_C_Class;
extern StructClass *BEMethod_OQL_Class;
extern StructClass *Trigger_Class;
extern StructClass *UniqueConstraint_Class;
extern StructClass *NotNullConstraint_Class;
extern StructClass *CardinalityDescription_Class;
extern StructClass *CardinalityConstraint_Class;
extern StructClass *CardinalityConstraint_Test_Class;
extern StructClass *ProtectionUser_Class;
extern StructClass *Protection_Class;
extern StructClass *UnreadableObject_Class;
extern StructClass *ClassConversion_Class;

}

#endif
