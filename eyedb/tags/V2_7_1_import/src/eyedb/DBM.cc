
/*
 * File 'DBM.cc'
 *
 * Package Name 'DBM'
 *
 * Generated by eyedbodl at Sat Dec  3 12:43:51 2005
 *
 * -------------------------------------
 * ------- DO NOT EDIT THIS CODE -------
 * -------------------------------------
 *
 */

#include <eyedb/eyedb.h>

#include <eyedb/internals/ObjectPeer.h>
#include <eyedb/internals/ClassPeer.h>
#include <eyedb/internals/kern_const.h>

#include <eyedb/DBM.h>

#define min(x,y)((x)<(y)?(x):(y))

namespace eyedb {

static Bool dynget_error_policy = False;
static Bool dynset_error_policy = True;
static Oid nulloid;
static unsigned char nulldata[1];
static Bool oid_check = True;
static int class_ind;
static Database::consapp_t *constructors_x = new Database::consapp_t[113];
static Object *(*constructors[113])(const Object *, Bool);
static GenHashTable *hash;
#define make_object DBMMakeObject
extern void DBMInit(void);
extern void DBMRelease(void);
extern Status DBMSchemaUpdate(Database *);
extern Status DBMSchemaUpdate(Schema *);

static Class *index_Class = new Class("index");

void DBM::init()
{
  DBMInit();
}

void DBM::release()
{
  DBMRelease();
}

Status DBM::updateSchema(Database *db)
{
  return DBMSchemaUpdate(db);
}

Status DBM::updateSchema(Schema *m)
{
  return DBMSchemaUpdate(m);
}

static EnumClass *SysAccessMode_Class;
static EnumClass *DBAccessMode_Class;
static EnumClass *UserType_Class;
static StructClass *UserEntry_Class;
static StructClass *DBUserAccess_Class;
static StructClass *SysUserAccess_Class;
static StructClass *DBEntry_Class;
static StructClass *DBPropertyValue_Class;
static StructClass *DBProperty_Class;

static Size SysAccessMode_idr_objsz, SysAccessMode_idr_psize;

static EnumClass *SysAccessMode_make(EnumClass *SysAccessMode_class = 0, Schema *m = 0)
{
  if (!SysAccessMode_class)
    return new EnumClass("system_access_mode");
  EnumItem *en[7];
  en[0] = new EnumItem("NO_SYSACCESS_MODE", "NoSysAccessMode", (unsigned int)0);
  en[1] = new EnumItem("DB_CREATE_SYSACCESS_MODE", "DBCreateSysAccessMode", (unsigned int)256);
  en[2] = new EnumItem("ADD_USER_SYSACCESS_MODE", "AddUserSysAccessMode", (unsigned int)512);
  en[3] = new EnumItem("DELETE_USER_SYSACCESS_MODE", "DeleteUserSysAccessMode", (unsigned int)1024);
  en[4] = new EnumItem("SET_USER_PASSWD_SYSACCESS_MODE", "SetUserPasswdSysAccessMode", (unsigned int)2048);
  en[5] = new EnumItem("ADMIN_SYSACCESS_MODE", "AdminSysAccessMode", (unsigned int)768);
  en[6] = new EnumItem("SUPERUSER_SYSACCESS_MODE", "SuperUserSysAccessMode", (unsigned int)4095);

  SysAccessMode_class->setEnumItems(en, 7);

  delete en[0];
  delete en[1];
  delete en[2];
  delete en[3];
  delete en[4];
  delete en[5];
  delete en[6];


  return SysAccessMode_class;
}

static void SysAccessMode_init_p()
{
  SysAccessMode_Class = SysAccessMode_make();
}

static void SysAccessMode_init()
{
  SysAccessMode_make(SysAccessMode_Class);

  SysAccessMode_idr_objsz = SysAccessMode_Class->getIDRObjectSize(&SysAccessMode_idr_psize, 0);

  ObjectPeer::setUnrealizable(SysAccessMode_Class, True);
}

static Size DBAccessMode_idr_objsz, DBAccessMode_idr_psize;

static EnumClass *DBAccessMode_make(EnumClass *DBAccessMode_class = 0, Schema *m = 0)
{
  if (!DBAccessMode_class)
    return new EnumClass("database_access_mode");
  EnumItem *en[8];
  en[0] = new EnumItem("NO_DBACCESS_MODE", "NoDBAccessMode", (unsigned int)0);
  en[1] = new EnumItem("READ_DBACCESS_MODE", "ReadDBAccessMode", (unsigned int)16);
  en[2] = new EnumItem("WRITE_DBACCESS_MODE", "WriteDBAccessMode", (unsigned int)32);
  en[3] = new EnumItem("EXEC_DBACCESS_MODE", "ExecDBAccessMode", (unsigned int)64);
  en[4] = new EnumItem("READ_WRITE_DBACCESS_MODE", "ReadWriteDBAccessMode", (unsigned int)48);
  en[5] = new EnumItem("READ_EXEC_DBACCESS_MODE", "ReadExecDBAccessMode", (unsigned int)80);
  en[6] = new EnumItem("READ_WRITE_EXEC_DBACCESS_MODE", "ReadWriteExecDBAccessMode", (unsigned int)112);
  en[7] = new EnumItem("ADMIN_DBACCESS_MODE", "AdminDBAccessMode", (unsigned int)113);

  DBAccessMode_class->setEnumItems(en, 8);

  delete en[0];
  delete en[1];
  delete en[2];
  delete en[3];
  delete en[4];
  delete en[5];
  delete en[6];
  delete en[7];


  return DBAccessMode_class;
}

static void DBAccessMode_init_p()
{
  DBAccessMode_Class = DBAccessMode_make();
}

static void DBAccessMode_init()
{
  DBAccessMode_make(DBAccessMode_Class);

  DBAccessMode_idr_objsz = DBAccessMode_Class->getIDRObjectSize(&DBAccessMode_idr_psize, 0);

  ObjectPeer::setUnrealizable(DBAccessMode_Class, True);
}

static Size UserType_idr_objsz, UserType_idr_psize;

static EnumClass *UserType_make(EnumClass *UserType_class = 0, Schema *m = 0)
{
  if (!UserType_class)
    return new EnumClass("user_type");
  EnumItem *en[3];
  en[0] = new EnumItem("EYEDB_USER", "EyeDBUser", (unsigned int)1);
  en[1] = new EnumItem("UNIX_USER", "UnixUser", (unsigned int)2);
  en[2] = new EnumItem("STRICT_UNIX_USER", "StrictUnixUser", (unsigned int)3);

  UserType_class->setEnumItems(en, 3);

  delete en[0];
  delete en[1];
  delete en[2];


  return UserType_class;
}

static void UserType_init_p()
{
  UserType_Class = UserType_make();
}

static void UserType_init()
{
  UserType_make(UserType_Class);

  UserType_idr_objsz = UserType_Class->getIDRObjectSize(&UserType_idr_psize, 0);

  ObjectPeer::setUnrealizable(UserType_Class, True);
}

static const Attribute **UserEntry_agritems;
static Size UserEntry_idr_objsz, UserEntry_idr_psize;

static StructClass *UserEntry_make(StructClass *UserEntry_class = 0, Schema *m = 0)
{
  if (!UserEntry_class)
    return new StructClass("user_entry", (m ? m->getClass("struct") : Struct_Class));
  Attribute *attr[6];
  int *dims;

  dims = new int[1];
  dims[0] = -1;
  attr[2] = new Attribute((m ? m->getClass("char") : Char_Class), "name", False, 1, dims);
  delete[] dims;

  dims = new int[1];
  dims[0] = -1;
  attr[3] = new Attribute((m ? m->getClass("char") : Char_Class), "passwd", False, 1, dims);
  delete[] dims;

  dims = 0;
  attr[4] = new Attribute((m ? m->getClass("int") : Int32_Class), "uid", False, 0, dims);

  dims = 0;
  attr[5] = new Attribute((m ? m->getClass("user_type") : UserType_Class), "type", False, 0, dims);

  UserEntry_class->setAttributes(&attr[2], 4);

  delete attr[2];
  delete attr[3];
  delete attr[4];
  delete attr[5];


  return UserEntry_class;
}

Object *UserEntry_construct_x(const Class *cls, Data idr)
{
  return new UserEntry(cls, idr);
}

Object *UserEntry_construct(const Object *o, Bool share)
{
  return new UserEntry((const Struct *)o, share);
}

static void UserEntry_init_p()
{
  UserEntry_Class = UserEntry_make();
  constructors_x[class_ind] = UserEntry_construct_x;
  constructors[class_ind] = UserEntry_construct;
  hash->insert("user_entry", class_ind++);
}

static void UserEntry_init()
{
  UserEntry_make(UserEntry_Class);

  UserEntry_agritems = UserEntry_Class->getAttributes();
  UserEntry_idr_objsz = UserEntry_Class->getIDRObjectSize(&UserEntry_idr_psize, 0);

  ObjectPeer::setUnrealizable(UserEntry_Class, True);
}

static Status UserEntry_attrcomp_realize(Database *db, Class *cls)
{
  AttributeComponent *comp;
  const Dataspace *dataspace;
  ClassComponent *clcomp;
  Status status;
  int *impl_hints;
  comp = new UniqueConstraint(db, cls, "user_entry.name", True);
  cls->add(comp->getInd(), comp);

  impl_hints = new int[8];
  impl_hints[0] = 0;
  impl_hints[1] = 0;
  impl_hints[2] = 0;
  impl_hints[3] = 0;
  impl_hints[4] = 0;
  impl_hints[5] = 0;
  impl_hints[6] = 0;
  impl_hints[7] = 0;
  dataspace = 0;;
  comp = new HashIndex(db, cls, "user_entry.name", True, True, dataspace, 0, 0, impl_hints, 8);
  delete [] impl_hints;
  cls->add(comp->getInd(), comp);

  impl_hints = new int[8];
  impl_hints[0] = 0;
  impl_hints[1] = 0;
  impl_hints[2] = 0;
  impl_hints[3] = 0;
  impl_hints[4] = 0;
  impl_hints[5] = 0;
  impl_hints[6] = 0;
  impl_hints[7] = 0;
  dataspace = 0;;
  comp = new BTreeIndex(db, cls, "user_entry.uid", True, False, dataspace, 0, impl_hints, 8);
  delete [] impl_hints;
  cls->add(comp->getInd(), comp);

  return Success;
}

UserEntry::UserEntry(Database *_db, const Dataspace *_dataspace) : Struct(_db, _dataspace)
{
  initialize(_db);
}

UserEntry::UserEntry(const Class *_cls, Data _idr)
{
  setClass((Class *)_cls);

  Size idr_psize;
  Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  ClassPeer::newObjRealize(getClass(), this);
  ObjectPeer::setGRTObject(this, True);
  userInitialize();
}

void UserEntry::initialize(Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("user_entry") : UserEntry_Class));

  Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  ClassPeer::newObjRealize(getClass(), this);
  ObjectPeer::setGRTObject(this, True);
  userInitialize();
}

UserEntry::UserEntry(const UserEntry& x) : Struct(x)
{
  userCopy(x);
}

UserEntry& UserEntry::operator=(const UserEntry& x)
{
  *(Struct *)this = Struct::operator=((const Struct &)x);
  userCopy(x);
  return *this;
}

UserEntry::UserEntry(const Struct *x, Bool share) : Struct(x, share)
{
  setClass((db ? db->getSchema()->getClass("user_entry") : UserEntry_Class));

  Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      ClassPeer::newObjRealize(getClass(), this);
    }

  ObjectPeer::setGRTObject(this, True);
  userCopy(*x);
}

UserEntry::UserEntry(const UserEntry *x, Bool share) : Struct(x, share)
{
  setClass((db ? db->getSchema()->getClass("user_entry") : UserEntry_Class));

  Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      ClassPeer::newObjRealize(getClass(), this);
    }

  ObjectPeer::setGRTObject(this, True);
  userCopy(*x);
}

Status UserEntry::name(const char *_name)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;
  Size size;
  Size len = ::strlen(_name) + 1;

  status = getClass()->getAttributes()[2]->getSize(this, size);
  if (status)
    return status;

  if (size != len)
    status = getClass()->getAttributes()[2]->setSize(this, len);
  if (status)
    return status;

  status = getClass()->getAttributes()[2]->setValue(this, (Data)_name, len, 0);
  return status;

}

Status UserEntry::name(unsigned int a0, char _name)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;
  Size from = a0;

  Size size;
  status = getClass()->getAttributes()[2]->getSize(this, size);
  if (status)
    return status;

  if (size <= from)
    status = getClass()->getAttributes()[2]->setSize(this, from+1);
  if (status)
    return status;

  status = getClass()->getAttributes()[2]->setValue(this, (Data)&_name, 1, from);
  return status;
}

const char *UserEntry::name(Bool *isnull, Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  Data data;
  Status s;

  s = getClass()->getAttributes()[2]->getValue(this, (Data *)&data, Attribute::directAccess, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  if (!data) data = nulldata;
  return (const char *)data;
}

char UserEntry::name(unsigned int a0, Bool *isnull, Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  char __tmp = 0;
  Status s;
  Size from = a0;

  s = getClass()->getAttributes()[2]->getValue(this, (Data *)&__tmp, 1, from, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

Status UserEntry::passwd(const char *_passwd)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;
  Size size;
  Size len = ::strlen(_passwd) + 1;

  status = getClass()->getAttributes()[3]->getSize(this, size);
  if (status)
    return status;

  if (size != len)
    status = getClass()->getAttributes()[3]->setSize(this, len);
  if (status)
    return status;

  status = getClass()->getAttributes()[3]->setValue(this, (Data)_passwd, len, 0);
  return status;

}

Status UserEntry::passwd(unsigned int a0, char _passwd)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;
  Size from = a0;

  Size size;
  status = getClass()->getAttributes()[3]->getSize(this, size);
  if (status)
    return status;

  if (size <= from)
    status = getClass()->getAttributes()[3]->setSize(this, from+1);
  if (status)
    return status;

  status = getClass()->getAttributes()[3]->setValue(this, (Data)&_passwd, 1, from);
  return status;
}

const char *UserEntry::passwd(Bool *isnull, Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  Data data;
  Status s;

  s = getClass()->getAttributes()[3]->getValue(this, (Data *)&data, Attribute::directAccess, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  if (!data) data = nulldata;
  return (const char *)data;
}

char UserEntry::passwd(unsigned int a0, Bool *isnull, Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  char __tmp = 0;
  Status s;
  Size from = a0;

  s = getClass()->getAttributes()[3]->getValue(this, (Data *)&__tmp, 1, from, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

Status UserEntry::uid(eyedblib::int32 _uid)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;

  status = getClass()->getAttributes()[4]->setValue(this, (Data)&_uid, 1, 0);
  return status;
}

eyedblib::int32 UserEntry::uid(Bool *isnull, Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int32 __tmp = 0;
  Status s;

  s = getClass()->getAttributes()[4]->getValue(this, (Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

Status UserEntry::type(UserType _type, Bool _check_value)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;
  eyedblib::int32 __tmp = _type;

  status = getClass()->getAttributes()[5]->setValue(this, (Data)&__tmp, 1, 0, _check_value);
  return status;
}

UserType UserEntry::type(Bool *isnull, Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int32 __tmp = 0;
  Status s;

  s = getClass()->getAttributes()[5]->getValue(this, (Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return (UserType)0;}
  return (UserType)__tmp;
}

static const Attribute **DBUserAccess_agritems;
static Size DBUserAccess_idr_objsz, DBUserAccess_idr_psize;

static StructClass *DBUserAccess_make(StructClass *DBUserAccess_class = 0, Schema *m = 0)
{
  if (!DBUserAccess_class)
    return new StructClass("database_user_access", (m ? m->getClass("struct") : Struct_Class));
  Attribute *attr[5];
  int *dims;

  dims = 0;
  attr[2] = new Attribute((m ? m->getClass("database_entry") : DBEntry_Class), "dbentry", True, 0, dims);

  dims = 0;
  attr[3] = new Attribute((m ? m->getClass("user_entry") : UserEntry_Class), "user", True, 0, dims);

  dims = 0;
  attr[4] = new Attribute((m ? m->getClass("database_access_mode") : DBAccessMode_Class), "mode", False, 0, dims);

  DBUserAccess_class->setAttributes(&attr[2], 3);

  delete attr[2];
  delete attr[3];
  delete attr[4];


  return DBUserAccess_class;
}

Object *DBUserAccess_construct_x(const Class *cls, Data idr)
{
  return new DBUserAccess(cls, idr);
}

Object *DBUserAccess_construct(const Object *o, Bool share)
{
  return new DBUserAccess((const Struct *)o, share);
}

static void DBUserAccess_init_p()
{
  DBUserAccess_Class = DBUserAccess_make();
  constructors_x[class_ind] = DBUserAccess_construct_x;
  constructors[class_ind] = DBUserAccess_construct;
  hash->insert("database_user_access", class_ind++);
}

static void DBUserAccess_init()
{
  DBUserAccess_make(DBUserAccess_Class);

  DBUserAccess_agritems = DBUserAccess_Class->getAttributes();
  DBUserAccess_idr_objsz = DBUserAccess_Class->getIDRObjectSize(&DBUserAccess_idr_psize, 0);

  ObjectPeer::setUnrealizable(DBUserAccess_Class, True);
}

static Status DBUserAccess_attrcomp_realize(Database *db, Class *cls)
{
  AttributeComponent *comp;
  const Dataspace *dataspace;
  ClassComponent *clcomp;
  Status status;
  int *impl_hints;
  impl_hints = new int[8];
  impl_hints[0] = 0;
  impl_hints[1] = 0;
  impl_hints[2] = 0;
  impl_hints[3] = 0;
  impl_hints[4] = 0;
  impl_hints[5] = 0;
  impl_hints[6] = 0;
  impl_hints[7] = 0;
  dataspace = 0;;
  comp = new HashIndex(db, cls, "database_user_access.dbentry", True, False, dataspace, 0, 0, impl_hints, 8);
  delete [] impl_hints;
  cls->add(comp->getInd(), comp);

  impl_hints = new int[8];
  impl_hints[0] = 0;
  impl_hints[1] = 0;
  impl_hints[2] = 0;
  impl_hints[3] = 0;
  impl_hints[4] = 0;
  impl_hints[5] = 0;
  impl_hints[6] = 0;
  impl_hints[7] = 0;
  dataspace = 0;;
  comp = new HashIndex(db, cls, "database_user_access.user", True, False, dataspace, 0, 0, impl_hints, 8);
  delete [] impl_hints;
  cls->add(comp->getInd(), comp);

  return Success;
}

DBUserAccess::DBUserAccess(Database *_db, const Dataspace *_dataspace) : Struct(_db, _dataspace)
{
  initialize(_db);
}

DBUserAccess::DBUserAccess(const Class *_cls, Data _idr)
{
  setClass((Class *)_cls);

  Size idr_psize;
  Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  ClassPeer::newObjRealize(getClass(), this);
  ObjectPeer::setGRTObject(this, True);
  userInitialize();
}

void DBUserAccess::initialize(Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("database_user_access") : DBUserAccess_Class));

  Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  ClassPeer::newObjRealize(getClass(), this);
  ObjectPeer::setGRTObject(this, True);
  userInitialize();
}

DBUserAccess::DBUserAccess(const DBUserAccess& x) : Struct(x)
{
  userCopy(x);
}

DBUserAccess& DBUserAccess::operator=(const DBUserAccess& x)
{
  *(Struct *)this = Struct::operator=((const Struct &)x);
  userCopy(x);
  return *this;
}

DBUserAccess::DBUserAccess(const Struct *x, Bool share) : Struct(x, share)
{
  setClass((db ? db->getSchema()->getClass("database_user_access") : DBUserAccess_Class));

  Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      ClassPeer::newObjRealize(getClass(), this);
    }

  ObjectPeer::setGRTObject(this, True);
  userCopy(*x);
}

DBUserAccess::DBUserAccess(const DBUserAccess *x, Bool share) : Struct(x, share)
{
  setClass((db ? db->getSchema()->getClass("database_user_access") : DBUserAccess_Class));

  Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      ClassPeer::newObjRealize(getClass(), this);
    }

  ObjectPeer::setGRTObject(this, True);
  userCopy(*x);
}

Status DBUserAccess::dbentry(DBEntry *_dbentry)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;

  status = getClass()->getAttributes()[2]->setValue(this, (Data)&_dbentry, 1, 0);
  return status;
}

const DBEntry *DBUserAccess::dbentry(Bool *isnull, Status *rs) const 
{
  gbxAutoGarbSuspender _gbxsusp_;
  Object *__o = 0, *__go;
  Status s;

  s = getClass()->getAttributes()[2]->getValue(this, (Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (ObjectPeer::isGRTObject(__o)) {
       return (DBEntry *)__o;
     }
     __go = (DBEntry *)make_object(__o, False);
     if (__go)
      {
       __o = __go;
       s = getClass()->getAttributes()[2]->setValue((Agregat *)this, (Data)&__o, 1, 0);
       ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
     return (DBEntry *)__o;
    }

  Bool wasnull = (!__o ? True : False);
  if (!__o && db)
    {
      Oid toid;
      s = getClass()->getAttributes()[2]->getOid(this, &toid, 1, 0);
      if (s) {if (rs) *rs = s; return 0;}
      if (toid.isValid())
        {
          s = db->loadObject(&toid, &__o);
          if (s) {if (rs) *rs = s; return 0;}
          if (!ObjectPeer::isGRTObject(__o))
           {
             __go = (DBEntry *)make_object(__o, False);
             if (__go) __o = __go;
           }
        }
    }

  if (__o && wasnull)
    {
     s = getClass()->getAttributes()[2]->setValue((Agregat *)this, (Data)&__o, 1, 0);
     if (s) {if (rs) *rs = s; return 0;}
     __o->release();
    }
  return (DBEntry *)__o;
}

DBEntry *DBUserAccess::dbentry(Bool *isnull, Status *rs) 
{
  gbxAutoGarbSuspender _gbxsusp_;
  Object *__o = 0, *__go;
  Status s;

  s = getClass()->getAttributes()[2]->getValue(this, (Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (ObjectPeer::isGRTObject(__o)) {
       return (DBEntry *)__o;
     }
     __go = (DBEntry *)make_object(__o, False);
     if (__go)
      {
       __o = __go;
       s = getClass()->getAttributes()[2]->setValue((Agregat *)this, (Data)&__o, 1, 0);
       ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
     return (DBEntry *)__o;
    }

  Bool wasnull = (!__o ? True : False);
  if (!__o && db)
    {
      Oid toid;
      s = getClass()->getAttributes()[2]->getOid(this, &toid, 1, 0);
      if (s) {if (rs) *rs = s; return 0;}
      if (toid.isValid())
        {
          s = db->loadObject(&toid, &__o);
          if (s) {if (rs) *rs = s; return 0;}
          if (!ObjectPeer::isGRTObject(__o))
           {
             __go = (DBEntry *)make_object(__o, False);
             if (__go) __o = __go;
           }
        }
    }

  if (__o && wasnull)
    {
     s = getClass()->getAttributes()[2]->setValue((Agregat *)this, (Data)&__o, 1, 0);
     if (s) {if (rs) *rs = s; return 0;}
     __o->release();
    }
  return (DBEntry *)__o;
}

Status DBUserAccess::dbentry_oid(const Oid &_oid)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;

  status = getClass()->getAttributes()[2]->setOid(this, &_oid, 1, 0, oid_check);
  return status;
}

Oid DBUserAccess::dbentry_oid(Status *rs) 
{
  gbxAutoGarbSuspender _gbxsusp_;
  Oid __tmp;
  Status s;

  s = getClass()->getAttributes()[2]->getOid(this, &__tmp, 1, 0);
  if (s) {if (rs) *rs = s; return nulloid;}

  return __tmp;
}

Status DBUserAccess::user(UserEntry *_user)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;

  status = getClass()->getAttributes()[3]->setValue(this, (Data)&_user, 1, 0);
  return status;
}

const UserEntry *DBUserAccess::user(Bool *isnull, Status *rs) const 
{
  gbxAutoGarbSuspender _gbxsusp_;
  Object *__o = 0, *__go;
  Status s;

  s = getClass()->getAttributes()[3]->getValue(this, (Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (ObjectPeer::isGRTObject(__o)) {
       return (UserEntry *)__o;
     }
     __go = (UserEntry *)make_object(__o, False);
     if (__go)
      {
       __o = __go;
       s = getClass()->getAttributes()[3]->setValue((Agregat *)this, (Data)&__o, 1, 0);
       ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
     return (UserEntry *)__o;
    }

  Bool wasnull = (!__o ? True : False);
  if (!__o && db)
    {
      Oid toid;
      s = getClass()->getAttributes()[3]->getOid(this, &toid, 1, 0);
      if (s) {if (rs) *rs = s; return 0;}
      if (toid.isValid())
        {
          s = db->loadObject(&toid, &__o);
          if (s) {if (rs) *rs = s; return 0;}
          if (!ObjectPeer::isGRTObject(__o))
           {
             __go = (UserEntry *)make_object(__o, False);
             if (__go) __o = __go;
           }
        }
    }

  if (__o && wasnull)
    {
     s = getClass()->getAttributes()[3]->setValue((Agregat *)this, (Data)&__o, 1, 0);
     if (s) {if (rs) *rs = s; return 0;}
     __o->release();
    }
  return (UserEntry *)__o;
}

UserEntry *DBUserAccess::user(Bool *isnull, Status *rs) 
{
  gbxAutoGarbSuspender _gbxsusp_;
  Object *__o = 0, *__go;
  Status s;

  s = getClass()->getAttributes()[3]->getValue(this, (Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (ObjectPeer::isGRTObject(__o)) {
       return (UserEntry *)__o;
     }
     __go = (UserEntry *)make_object(__o, False);
     if (__go)
      {
       __o = __go;
       s = getClass()->getAttributes()[3]->setValue((Agregat *)this, (Data)&__o, 1, 0);
       ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
     return (UserEntry *)__o;
    }

  Bool wasnull = (!__o ? True : False);
  if (!__o && db)
    {
      Oid toid;
      s = getClass()->getAttributes()[3]->getOid(this, &toid, 1, 0);
      if (s) {if (rs) *rs = s; return 0;}
      if (toid.isValid())
        {
          s = db->loadObject(&toid, &__o);
          if (s) {if (rs) *rs = s; return 0;}
          if (!ObjectPeer::isGRTObject(__o))
           {
             __go = (UserEntry *)make_object(__o, False);
             if (__go) __o = __go;
           }
        }
    }

  if (__o && wasnull)
    {
     s = getClass()->getAttributes()[3]->setValue((Agregat *)this, (Data)&__o, 1, 0);
     if (s) {if (rs) *rs = s; return 0;}
     __o->release();
    }
  return (UserEntry *)__o;
}

Status DBUserAccess::user_oid(const Oid &_oid)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;

  status = getClass()->getAttributes()[3]->setOid(this, &_oid, 1, 0, oid_check);
  return status;
}

Oid DBUserAccess::user_oid(Status *rs) 
{
  gbxAutoGarbSuspender _gbxsusp_;
  Oid __tmp;
  Status s;

  s = getClass()->getAttributes()[3]->getOid(this, &__tmp, 1, 0);
  if (s) {if (rs) *rs = s; return nulloid;}

  return __tmp;
}

Status DBUserAccess::mode(DBAccessMode _mode, Bool _check_value)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;
  eyedblib::int32 __tmp = _mode;

  status = getClass()->getAttributes()[4]->setValue(this, (Data)&__tmp, 1, 0, _check_value);
  return status;
}

DBAccessMode DBUserAccess::mode(Bool *isnull, Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int32 __tmp = 0;
  Status s;

  s = getClass()->getAttributes()[4]->getValue(this, (Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return (DBAccessMode)0;}
  return (DBAccessMode)__tmp;
}

static const Attribute **SysUserAccess_agritems;
static Size SysUserAccess_idr_objsz, SysUserAccess_idr_psize;

static StructClass *SysUserAccess_make(StructClass *SysUserAccess_class = 0, Schema *m = 0)
{
  if (!SysUserAccess_class)
    return new StructClass("system_user_access", (m ? m->getClass("struct") : Struct_Class));
  Attribute *attr[4];
  int *dims;

  dims = 0;
  attr[2] = new Attribute((m ? m->getClass("user_entry") : UserEntry_Class), "user", True, 0, dims);

  dims = 0;
  attr[3] = new Attribute((m ? m->getClass("system_access_mode") : SysAccessMode_Class), "mode", False, 0, dims);

  SysUserAccess_class->setAttributes(&attr[2], 2);

  delete attr[2];
  delete attr[3];


  return SysUserAccess_class;
}

Object *SysUserAccess_construct_x(const Class *cls, Data idr)
{
  return new SysUserAccess(cls, idr);
}

Object *SysUserAccess_construct(const Object *o, Bool share)
{
  return new SysUserAccess((const Struct *)o, share);
}

static void SysUserAccess_init_p()
{
  SysUserAccess_Class = SysUserAccess_make();
  constructors_x[class_ind] = SysUserAccess_construct_x;
  constructors[class_ind] = SysUserAccess_construct;
  hash->insert("system_user_access", class_ind++);
}

static void SysUserAccess_init()
{
  SysUserAccess_make(SysUserAccess_Class);

  SysUserAccess_agritems = SysUserAccess_Class->getAttributes();
  SysUserAccess_idr_objsz = SysUserAccess_Class->getIDRObjectSize(&SysUserAccess_idr_psize, 0);

  ObjectPeer::setUnrealizable(SysUserAccess_Class, True);
}

static Status SysUserAccess_attrcomp_realize(Database *db, Class *cls)
{
  AttributeComponent *comp;
  const Dataspace *dataspace;
  ClassComponent *clcomp;
  Status status;
  int *impl_hints;
  impl_hints = new int[8];
  impl_hints[0] = 0;
  impl_hints[1] = 0;
  impl_hints[2] = 0;
  impl_hints[3] = 0;
  impl_hints[4] = 0;
  impl_hints[5] = 0;
  impl_hints[6] = 0;
  impl_hints[7] = 0;
  dataspace = 0;;
  comp = new HashIndex(db, cls, "system_user_access.user", True, False, dataspace, 0, 0, impl_hints, 8);
  delete [] impl_hints;
  cls->add(comp->getInd(), comp);

  return Success;
}

SysUserAccess::SysUserAccess(Database *_db, const Dataspace *_dataspace) : Struct(_db, _dataspace)
{
  initialize(_db);
}

SysUserAccess::SysUserAccess(const Class *_cls, Data _idr)
{
  setClass((Class *)_cls);

  Size idr_psize;
  Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  ClassPeer::newObjRealize(getClass(), this);
  ObjectPeer::setGRTObject(this, True);
  userInitialize();
}

void SysUserAccess::initialize(Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("system_user_access") : SysUserAccess_Class));

  Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  ClassPeer::newObjRealize(getClass(), this);
  ObjectPeer::setGRTObject(this, True);
  userInitialize();
}

SysUserAccess::SysUserAccess(const SysUserAccess& x) : Struct(x)
{
  userCopy(x);
}

SysUserAccess& SysUserAccess::operator=(const SysUserAccess& x)
{
  *(Struct *)this = Struct::operator=((const Struct &)x);
  userCopy(x);
  return *this;
}

SysUserAccess::SysUserAccess(const Struct *x, Bool share) : Struct(x, share)
{
  setClass((db ? db->getSchema()->getClass("system_user_access") : SysUserAccess_Class));

  Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      ClassPeer::newObjRealize(getClass(), this);
    }

  ObjectPeer::setGRTObject(this, True);
  userCopy(*x);
}

SysUserAccess::SysUserAccess(const SysUserAccess *x, Bool share) : Struct(x, share)
{
  setClass((db ? db->getSchema()->getClass("system_user_access") : SysUserAccess_Class));

  Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      ClassPeer::newObjRealize(getClass(), this);
    }

  ObjectPeer::setGRTObject(this, True);
  userCopy(*x);
}

Status SysUserAccess::user(UserEntry *_user)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;

  status = getClass()->getAttributes()[2]->setValue(this, (Data)&_user, 1, 0);
  return status;
}

const UserEntry *SysUserAccess::user(Bool *isnull, Status *rs) const 
{
  gbxAutoGarbSuspender _gbxsusp_;
  Object *__o = 0, *__go;
  Status s;

  s = getClass()->getAttributes()[2]->getValue(this, (Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (ObjectPeer::isGRTObject(__o)) {
       return (UserEntry *)__o;
     }
     __go = (UserEntry *)make_object(__o, False);
     if (__go)
      {
       __o = __go;
       s = getClass()->getAttributes()[2]->setValue((Agregat *)this, (Data)&__o, 1, 0);
       ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
     return (UserEntry *)__o;
    }

  Bool wasnull = (!__o ? True : False);
  if (!__o && db)
    {
      Oid toid;
      s = getClass()->getAttributes()[2]->getOid(this, &toid, 1, 0);
      if (s) {if (rs) *rs = s; return 0;}
      if (toid.isValid())
        {
          s = db->loadObject(&toid, &__o);
          if (s) {if (rs) *rs = s; return 0;}
          if (!ObjectPeer::isGRTObject(__o))
           {
             __go = (UserEntry *)make_object(__o, False);
             if (__go) __o = __go;
           }
        }
    }

  if (__o && wasnull)
    {
     s = getClass()->getAttributes()[2]->setValue((Agregat *)this, (Data)&__o, 1, 0);
     if (s) {if (rs) *rs = s; return 0;}
     __o->release();
    }
  return (UserEntry *)__o;
}

UserEntry *SysUserAccess::user(Bool *isnull, Status *rs) 
{
  gbxAutoGarbSuspender _gbxsusp_;
  Object *__o = 0, *__go;
  Status s;

  s = getClass()->getAttributes()[2]->getValue(this, (Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (ObjectPeer::isGRTObject(__o)) {
       return (UserEntry *)__o;
     }
     __go = (UserEntry *)make_object(__o, False);
     if (__go)
      {
       __o = __go;
       s = getClass()->getAttributes()[2]->setValue((Agregat *)this, (Data)&__o, 1, 0);
       ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
     return (UserEntry *)__o;
    }

  Bool wasnull = (!__o ? True : False);
  if (!__o && db)
    {
      Oid toid;
      s = getClass()->getAttributes()[2]->getOid(this, &toid, 1, 0);
      if (s) {if (rs) *rs = s; return 0;}
      if (toid.isValid())
        {
          s = db->loadObject(&toid, &__o);
          if (s) {if (rs) *rs = s; return 0;}
          if (!ObjectPeer::isGRTObject(__o))
           {
             __go = (UserEntry *)make_object(__o, False);
             if (__go) __o = __go;
           }
        }
    }

  if (__o && wasnull)
    {
     s = getClass()->getAttributes()[2]->setValue((Agregat *)this, (Data)&__o, 1, 0);
     if (s) {if (rs) *rs = s; return 0;}
     __o->release();
    }
  return (UserEntry *)__o;
}

Status SysUserAccess::user_oid(const Oid &_oid)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;

  status = getClass()->getAttributes()[2]->setOid(this, &_oid, 1, 0, oid_check);
  return status;
}

Oid SysUserAccess::user_oid(Status *rs) 
{
  gbxAutoGarbSuspender _gbxsusp_;
  Oid __tmp;
  Status s;

  s = getClass()->getAttributes()[2]->getOid(this, &__tmp, 1, 0);
  if (s) {if (rs) *rs = s; return nulloid;}

  return __tmp;
}

Status SysUserAccess::mode(SysAccessMode _mode, Bool _check_value)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;
  eyedblib::int32 __tmp = _mode;

  status = getClass()->getAttributes()[3]->setValue(this, (Data)&__tmp, 1, 0, _check_value);
  return status;
}

SysAccessMode SysUserAccess::mode(Bool *isnull, Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int32 __tmp = 0;
  Status s;

  s = getClass()->getAttributes()[3]->getValue(this, (Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return (SysAccessMode)0;}
  return (SysAccessMode)__tmp;
}

static const Attribute **DBEntry_agritems;
static Size DBEntry_idr_objsz, DBEntry_idr_psize;

static StructClass *DBEntry_make(StructClass *DBEntry_class = 0, Schema *m = 0)
{
  if (!DBEntry_class)
    return new StructClass("database_entry", (m ? m->getClass("struct") : Struct_Class));
  Attribute *attr[9];
  int *dims;

  dims = new int[1];
  dims[0] = -1;
  attr[2] = new Attribute((m ? m->getClass("char") : Char_Class), "dbname", False, 1, dims);
  delete[] dims;

  dims = 0;
  attr[3] = new Attribute((m ? m->getClass("int") : Int32_Class), "dbid", False, 0, dims);

  dims = new int[1];
  dims[0] = -1;
  attr[4] = new Attribute((m ? m->getClass("char") : Char_Class), "dbfile", False, 1, dims);
  delete[] dims;

  dims = 0;
  attr[5] = new Attribute((m ? m->getClass("database_access_mode") : DBAccessMode_Class), "default_access", False, 0, dims);

  dims = 0;
  attr[6] = new Attribute((m ? m->getClass("object") : Object_Class), "schm", True, 0, dims);

  dims = new int[1];
  dims[0] = -1;
  attr[7] = new Attribute((m ? m->getClass("char") : Char_Class), "comment", False, 1, dims);
  delete[] dims;

  dims = new int[1];
  dims[0] = -1;
  attr[8] = new Attribute((m ? m->getClass("database_property") : DBProperty_Class), "props", True, 1, dims);
  delete[] dims;

  DBEntry_class->setAttributes(&attr[2], 7);

  delete attr[2];
  delete attr[3];
  delete attr[4];
  delete attr[5];
  delete attr[6];
  delete attr[7];
  delete attr[8];


  return DBEntry_class;
}

Object *DBEntry_construct_x(const Class *cls, Data idr)
{
  return new DBEntry(cls, idr);
}

Object *DBEntry_construct(const Object *o, Bool share)
{
  return new DBEntry((const Struct *)o, share);
}

static void DBEntry_init_p()
{
  DBEntry_Class = DBEntry_make();
  constructors_x[class_ind] = DBEntry_construct_x;
  constructors[class_ind] = DBEntry_construct;
  hash->insert("database_entry", class_ind++);
}

static void DBEntry_init()
{
  DBEntry_make(DBEntry_Class);

  DBEntry_agritems = DBEntry_Class->getAttributes();
  DBEntry_idr_objsz = DBEntry_Class->getIDRObjectSize(&DBEntry_idr_psize, 0);

  ObjectPeer::setUnrealizable(DBEntry_Class, True);
}

static Status DBEntry_attrcomp_realize(Database *db, Class *cls)
{
  AttributeComponent *comp;
  const Dataspace *dataspace;
  ClassComponent *clcomp;
  Status status;
  int *impl_hints;
  comp = new UniqueConstraint(db, cls, "database_entry.dbname", True);
  cls->add(comp->getInd(), comp);

  impl_hints = new int[8];
  impl_hints[0] = 0;
  impl_hints[1] = 0;
  impl_hints[2] = 0;
  impl_hints[3] = 0;
  impl_hints[4] = 0;
  impl_hints[5] = 0;
  impl_hints[6] = 0;
  impl_hints[7] = 0;
  dataspace = 0;;
  comp = new HashIndex(db, cls, "database_entry.dbname", True, True, dataspace, 0, 0, impl_hints, 8);
  delete [] impl_hints;
  cls->add(comp->getInd(), comp);

  impl_hints = new int[8];
  impl_hints[0] = 0;
  impl_hints[1] = 0;
  impl_hints[2] = 0;
  impl_hints[3] = 0;
  impl_hints[4] = 0;
  impl_hints[5] = 0;
  impl_hints[6] = 0;
  impl_hints[7] = 0;
  dataspace = 0;;
  comp = new BTreeIndex(db, cls, "database_entry.dbid", True, False, dataspace, 0, impl_hints, 8);
  delete [] impl_hints;
  cls->add(comp->getInd(), comp);

  return Success;
}

DBEntry::DBEntry(Database *_db, const Dataspace *_dataspace) : Struct(_db, _dataspace)
{
  initialize(_db);
}

DBEntry::DBEntry(const Class *_cls, Data _idr)
{
  setClass((Class *)_cls);

  Size idr_psize;
  Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  ClassPeer::newObjRealize(getClass(), this);
  ObjectPeer::setGRTObject(this, True);
  userInitialize();
}

void DBEntry::initialize(Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("database_entry") : DBEntry_Class));

  Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  ClassPeer::newObjRealize(getClass(), this);
  ObjectPeer::setGRTObject(this, True);
  userInitialize();
}

DBEntry::DBEntry(const DBEntry& x) : Struct(x)
{
  userCopy(x);
}

DBEntry& DBEntry::operator=(const DBEntry& x)
{
  *(Struct *)this = Struct::operator=((const Struct &)x);
  userCopy(x);
  return *this;
}

DBEntry::DBEntry(const Struct *x, Bool share) : Struct(x, share)
{
  setClass((db ? db->getSchema()->getClass("database_entry") : DBEntry_Class));

  Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      ClassPeer::newObjRealize(getClass(), this);
    }

  ObjectPeer::setGRTObject(this, True);
  userCopy(*x);
}

DBEntry::DBEntry(const DBEntry *x, Bool share) : Struct(x, share)
{
  setClass((db ? db->getSchema()->getClass("database_entry") : DBEntry_Class));

  Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      ClassPeer::newObjRealize(getClass(), this);
    }

  ObjectPeer::setGRTObject(this, True);
  userCopy(*x);
}

Status DBEntry::dbname(const char *_dbname)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;
  Size size;
  Size len = ::strlen(_dbname) + 1;

  status = getClass()->getAttributes()[2]->getSize(this, size);
  if (status)
    return status;

  if (size != len)
    status = getClass()->getAttributes()[2]->setSize(this, len);
  if (status)
    return status;

  status = getClass()->getAttributes()[2]->setValue(this, (Data)_dbname, len, 0);
  return status;

}

Status DBEntry::dbname(unsigned int a0, char _dbname)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;
  Size from = a0;

  Size size;
  status = getClass()->getAttributes()[2]->getSize(this, size);
  if (status)
    return status;

  if (size <= from)
    status = getClass()->getAttributes()[2]->setSize(this, from+1);
  if (status)
    return status;

  status = getClass()->getAttributes()[2]->setValue(this, (Data)&_dbname, 1, from);
  return status;
}

const char *DBEntry::dbname(Bool *isnull, Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  Data data;
  Status s;

  s = getClass()->getAttributes()[2]->getValue(this, (Data *)&data, Attribute::directAccess, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  if (!data) data = nulldata;
  return (const char *)data;
}

char DBEntry::dbname(unsigned int a0, Bool *isnull, Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  char __tmp = 0;
  Status s;
  Size from = a0;

  s = getClass()->getAttributes()[2]->getValue(this, (Data *)&__tmp, 1, from, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

Status DBEntry::dbid(eyedblib::int32 _dbid)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;

  status = getClass()->getAttributes()[3]->setValue(this, (Data)&_dbid, 1, 0);
  return status;
}

eyedblib::int32 DBEntry::dbid(Bool *isnull, Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int32 __tmp = 0;
  Status s;

  s = getClass()->getAttributes()[3]->getValue(this, (Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

Status DBEntry::dbfile(const char *_dbfile)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;
  Size size;
  Size len = ::strlen(_dbfile) + 1;

  status = getClass()->getAttributes()[4]->getSize(this, size);
  if (status)
    return status;

  if (size != len)
    status = getClass()->getAttributes()[4]->setSize(this, len);
  if (status)
    return status;

  status = getClass()->getAttributes()[4]->setValue(this, (Data)_dbfile, len, 0);
  return status;

}

Status DBEntry::dbfile(unsigned int a0, char _dbfile)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;
  Size from = a0;

  Size size;
  status = getClass()->getAttributes()[4]->getSize(this, size);
  if (status)
    return status;

  if (size <= from)
    status = getClass()->getAttributes()[4]->setSize(this, from+1);
  if (status)
    return status;

  status = getClass()->getAttributes()[4]->setValue(this, (Data)&_dbfile, 1, from);
  return status;
}

const char *DBEntry::dbfile(Bool *isnull, Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  Data data;
  Status s;

  s = getClass()->getAttributes()[4]->getValue(this, (Data *)&data, Attribute::directAccess, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  if (!data) data = nulldata;
  return (const char *)data;
}

char DBEntry::dbfile(unsigned int a0, Bool *isnull, Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  char __tmp = 0;
  Status s;
  Size from = a0;

  s = getClass()->getAttributes()[4]->getValue(this, (Data *)&__tmp, 1, from, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

Status DBEntry::default_access(DBAccessMode _default_access, Bool _check_value)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;
  eyedblib::int32 __tmp = _default_access;

  status = getClass()->getAttributes()[5]->setValue(this, (Data)&__tmp, 1, 0, _check_value);
  return status;
}

DBAccessMode DBEntry::default_access(Bool *isnull, Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int32 __tmp = 0;
  Status s;

  s = getClass()->getAttributes()[5]->getValue(this, (Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return (DBAccessMode)0;}
  return (DBAccessMode)__tmp;
}

Status DBEntry::schm(Object *_schm)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;

  status = getClass()->getAttributes()[6]->setValue(this, (Data)&_schm, 1, 0);
  return status;
}

const Object *DBEntry::schm(Bool *isnull, Status *rs) const 
{
  gbxAutoGarbSuspender _gbxsusp_;
  Object *__o = 0, *__go;
  Status s;

  s = getClass()->getAttributes()[6]->getValue(this, (Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (ObjectPeer::isGRTObject(__o)) {
       return (Object *)__o;
     }
     __go = (Object *)make_object(__o, False);
     if (__go)
      {
       __o = __go;
       s = getClass()->getAttributes()[6]->setValue((Agregat *)this, (Data)&__o, 1, 0);
       ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
     return (Object *)__o;
    }

  Bool wasnull = (!__o ? True : False);
  if (!__o && db)
    {
      Oid toid;
      s = getClass()->getAttributes()[6]->getOid(this, &toid, 1, 0);
      if (s) {if (rs) *rs = s; return 0;}
      if (toid.isValid())
        {
          s = db->loadObject(&toid, &__o);
          if (s) {if (rs) *rs = s; return 0;}
          if (!ObjectPeer::isGRTObject(__o))
           {
             __go = (Object *)make_object(__o, False);
             if (__go) __o = __go;
           }
        }
    }

  if (__o && wasnull)
    {
     s = getClass()->getAttributes()[6]->setValue((Agregat *)this, (Data)&__o, 1, 0);
     if (s) {if (rs) *rs = s; return 0;}
     __o->release();
    }
  return (Object *)__o;
}

Object *DBEntry::schm(Bool *isnull, Status *rs) 
{
  gbxAutoGarbSuspender _gbxsusp_;
  Object *__o = 0, *__go;
  Status s;

  s = getClass()->getAttributes()[6]->getValue(this, (Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (ObjectPeer::isGRTObject(__o)) {
       return (Object *)__o;
     }
     __go = (Object *)make_object(__o, False);
     if (__go)
      {
       __o = __go;
       s = getClass()->getAttributes()[6]->setValue((Agregat *)this, (Data)&__o, 1, 0);
       ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
     return (Object *)__o;
    }

  Bool wasnull = (!__o ? True : False);
  if (!__o && db)
    {
      Oid toid;
      s = getClass()->getAttributes()[6]->getOid(this, &toid, 1, 0);
      if (s) {if (rs) *rs = s; return 0;}
      if (toid.isValid())
        {
          s = db->loadObject(&toid, &__o);
          if (s) {if (rs) *rs = s; return 0;}
          if (!ObjectPeer::isGRTObject(__o))
           {
             __go = (Object *)make_object(__o, False);
             if (__go) __o = __go;
           }
        }
    }

  if (__o && wasnull)
    {
     s = getClass()->getAttributes()[6]->setValue((Agregat *)this, (Data)&__o, 1, 0);
     if (s) {if (rs) *rs = s; return 0;}
     __o->release();
    }
  return (Object *)__o;
}

Status DBEntry::schm_oid(const Oid &_oid)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;

  status = getClass()->getAttributes()[6]->setOid(this, &_oid, 1, 0, oid_check);
  return status;
}

Oid DBEntry::schm_oid(Status *rs) 
{
  gbxAutoGarbSuspender _gbxsusp_;
  Oid __tmp;
  Status s;

  s = getClass()->getAttributes()[6]->getOid(this, &__tmp, 1, 0);
  if (s) {if (rs) *rs = s; return nulloid;}

  return __tmp;
}

Status DBEntry::comment(const char *_comment)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;
  Size size;
  Size len = ::strlen(_comment) + 1;

  status = getClass()->getAttributes()[7]->getSize(this, size);
  if (status)
    return status;

  if (size != len)
    status = getClass()->getAttributes()[7]->setSize(this, len);
  if (status)
    return status;

  status = getClass()->getAttributes()[7]->setValue(this, (Data)_comment, len, 0);
  return status;

}

Status DBEntry::comment(unsigned int a0, char _comment)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;
  Size from = a0;

  Size size;
  status = getClass()->getAttributes()[7]->getSize(this, size);
  if (status)
    return status;

  if (size <= from)
    status = getClass()->getAttributes()[7]->setSize(this, from+1);
  if (status)
    return status;

  status = getClass()->getAttributes()[7]->setValue(this, (Data)&_comment, 1, from);
  return status;
}

const char *DBEntry::comment(Bool *isnull, Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  Data data;
  Status s;

  s = getClass()->getAttributes()[7]->getValue(this, (Data *)&data, Attribute::directAccess, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  if (!data) data = nulldata;
  return (const char *)data;
}

char DBEntry::comment(unsigned int a0, Bool *isnull, Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  char __tmp = 0;
  Status s;
  Size from = a0;

  s = getClass()->getAttributes()[7]->getValue(this, (Data *)&__tmp, 1, from, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

Status DBEntry::props(unsigned int a0, DBProperty *_props)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;
  Size from = a0;

  Size size;
  status = getClass()->getAttributes()[8]->getSize(this, size);
  if (status)
    return status;

  if (size <= from)
    status = getClass()->getAttributes()[8]->setSize(this, from+1);
  if (status)
    return status;

  status = getClass()->getAttributes()[8]->setValue(this, (Data)&_props, 1, from);
  return status;
}

const DBProperty *DBEntry::props(unsigned int a0, Bool *isnull, Status *rs) const 
{
  gbxAutoGarbSuspender _gbxsusp_;
  Object *__o = 0, *__go;
  Status s;
  Size from = a0;

  s = getClass()->getAttributes()[8]->getValue(this, (Data *)&__o, 1, from, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (ObjectPeer::isGRTObject(__o)) {
       return (DBProperty *)__o;
     }
     __go = (DBProperty *)make_object(__o, False);
     if (__go)
      {
       __o = __go;
       s = getClass()->getAttributes()[8]->setValue((Agregat *)this, (Data)&__o, 1, from);
       ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
     return (DBProperty *)__o;
    }

  Bool wasnull = (!__o ? True : False);
  if (!__o && db)
    {
      Oid toid;
      s = getClass()->getAttributes()[8]->getOid(this, &toid, 1, from);
      if (s) {if (rs) *rs = s; return 0;}
      if (toid.isValid())
        {
          s = db->loadObject(&toid, &__o);
          if (s) {if (rs) *rs = s; return 0;}
          if (!ObjectPeer::isGRTObject(__o))
           {
             __go = (DBProperty *)make_object(__o, False);
             if (__go) __o = __go;
           }
        }
    }

  if (__o && wasnull)
    {
     s = getClass()->getAttributes()[8]->setValue((Agregat *)this, (Data)&__o, 1, from);
     if (s) {if (rs) *rs = s; return 0;}
     __o->release();
    }
  return (DBProperty *)__o;
}

DBProperty *DBEntry::props(unsigned int a0, Bool *isnull, Status *rs) 
{
  gbxAutoGarbSuspender _gbxsusp_;
  Object *__o = 0, *__go;
  Status s;
  Size from = a0;

  s = getClass()->getAttributes()[8]->getValue(this, (Data *)&__o, 1, from, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (ObjectPeer::isGRTObject(__o)) {
       return (DBProperty *)__o;
     }
     __go = (DBProperty *)make_object(__o, False);
     if (__go)
      {
       __o = __go;
       s = getClass()->getAttributes()[8]->setValue((Agregat *)this, (Data)&__o, 1, from);
       ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
     return (DBProperty *)__o;
    }

  Bool wasnull = (!__o ? True : False);
  if (!__o && db)
    {
      Oid toid;
      s = getClass()->getAttributes()[8]->getOid(this, &toid, 1, from);
      if (s) {if (rs) *rs = s; return 0;}
      if (toid.isValid())
        {
          s = db->loadObject(&toid, &__o);
          if (s) {if (rs) *rs = s; return 0;}
          if (!ObjectPeer::isGRTObject(__o))
           {
             __go = (DBProperty *)make_object(__o, False);
             if (__go) __o = __go;
           }
        }
    }

  if (__o && wasnull)
    {
     s = getClass()->getAttributes()[8]->setValue((Agregat *)this, (Data)&__o, 1, from);
     if (s) {if (rs) *rs = s; return 0;}
     __o->release();
    }
  return (DBProperty *)__o;
}

unsigned int DBEntry::props_cnt(Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  Size size;
  Status s;
  s = getClass()->getAttributes()[8]->getSize(this, size);
  if (s) {if (rs) *rs = s; return 0;}
  return (int)size;
}

Status DBEntry::props_oid(unsigned int a0, const Oid &_oid)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;
  Size from = a0;

  Size size;
  status = getClass()->getAttributes()[8]->getSize(this, size);
  if (status)
    return status;

  if (size <= from)
    status = getClass()->getAttributes()[8]->setSize(this, from+1);
  if (status)
    return status;

  status = getClass()->getAttributes()[8]->setOid(this, &_oid, 1, from, oid_check);
  return status;
}

Oid DBEntry::props_oid(unsigned int a0, Status *rs) 
{
  gbxAutoGarbSuspender _gbxsusp_;
  Oid __tmp;
  Status s;
  Size from = a0;

  s = getClass()->getAttributes()[8]->getOid(this, &__tmp, 1, from);
  if (s) {if (rs) *rs = s; return nulloid;}

  return __tmp;
}

static const Attribute **DBPropertyValue_agritems;
static Size DBPropertyValue_idr_objsz, DBPropertyValue_idr_psize;

static StructClass *DBPropertyValue_make(StructClass *DBPropertyValue_class = 0, Schema *m = 0)
{
  if (!DBPropertyValue_class)
    return new StructClass("database_property_value", (m ? m->getClass("struct") : Struct_Class));
  Attribute *attr[6];
  int *dims;

  dims = 0;
  attr[2] = new Attribute((m ? m->getClass("long") : Int64_Class), "ival", False, 0, dims);

  dims = new int[1];
  dims[0] = -1;
  attr[3] = new Attribute((m ? m->getClass("char") : Char_Class), "sval", False, 1, dims);
  delete[] dims;

  dims = new int[1];
  dims[0] = -1;
  attr[4] = new Attribute((m ? m->getClass("byte") : Byte_Class), "bval", False, 1, dims);
  delete[] dims;

  dims = 0;
  attr[5] = new Attribute((m ? m->getClass("object") : Object_Class), "oval", True, 0, dims);

  DBPropertyValue_class->setAttributes(&attr[2], 4);

  delete attr[2];
  delete attr[3];
  delete attr[4];
  delete attr[5];


  return DBPropertyValue_class;
}

Object *DBPropertyValue_construct_x(const Class *cls, Data idr)
{
  return new DBPropertyValue(cls, idr);
}

Object *DBPropertyValue_construct(const Object *o, Bool share)
{
  return new DBPropertyValue((const Struct *)o, share);
}

static void DBPropertyValue_init_p()
{
  DBPropertyValue_Class = DBPropertyValue_make();
  constructors_x[class_ind] = DBPropertyValue_construct_x;
  constructors[class_ind] = DBPropertyValue_construct;
  hash->insert("database_property_value", class_ind++);
}

static void DBPropertyValue_init()
{
  DBPropertyValue_make(DBPropertyValue_Class);

  DBPropertyValue_agritems = DBPropertyValue_Class->getAttributes();
  DBPropertyValue_idr_objsz = DBPropertyValue_Class->getIDRObjectSize(&DBPropertyValue_idr_psize, 0);

  ObjectPeer::setUnrealizable(DBPropertyValue_Class, True);
}

static Status DBPropertyValue_attrcomp_realize(Database *db, Class *cls)
{
  return Success;
}

DBPropertyValue::DBPropertyValue(Database *_db, const Dataspace *_dataspace) : Struct(_db, _dataspace)
{
  initialize(_db);
}

DBPropertyValue::DBPropertyValue(const Class *_cls, Data _idr)
{
  setClass((Class *)_cls);

  Size idr_psize;
  Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  ClassPeer::newObjRealize(getClass(), this);
  ObjectPeer::setGRTObject(this, True);
  userInitialize();
}

void DBPropertyValue::initialize(Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("database_property_value") : DBPropertyValue_Class));

  Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  ClassPeer::newObjRealize(getClass(), this);
  ObjectPeer::setGRTObject(this, True);
  userInitialize();
}

DBPropertyValue::DBPropertyValue(const DBPropertyValue& x) : Struct(x)
{
  userCopy(x);
}

DBPropertyValue& DBPropertyValue::operator=(const DBPropertyValue& x)
{
  *(Struct *)this = Struct::operator=((const Struct &)x);
  userCopy(x);
  return *this;
}

DBPropertyValue::DBPropertyValue(const Struct *x, Bool share) : Struct(x, share)
{
  setClass((db ? db->getSchema()->getClass("database_property_value") : DBPropertyValue_Class));

  Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      ClassPeer::newObjRealize(getClass(), this);
    }

  ObjectPeer::setGRTObject(this, True);
  userCopy(*x);
}

DBPropertyValue::DBPropertyValue(const DBPropertyValue *x, Bool share) : Struct(x, share)
{
  setClass((db ? db->getSchema()->getClass("database_property_value") : DBPropertyValue_Class));

  Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      ClassPeer::newObjRealize(getClass(), this);
    }

  ObjectPeer::setGRTObject(this, True);
  userCopy(*x);
}

Status DBPropertyValue::ival(eyedblib::int64 _ival)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;

  status = getClass()->getAttributes()[2]->setValue(this, (Data)&_ival, 1, 0);
  return status;
}

eyedblib::int64 DBPropertyValue::ival(Bool *isnull, Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int64 __tmp = 0;
  Status s;

  s = getClass()->getAttributes()[2]->getValue(this, (Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

Status DBPropertyValue::sval(const char *_sval)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;
  Size size;
  Size len = ::strlen(_sval) + 1;

  status = getClass()->getAttributes()[3]->getSize(this, size);
  if (status)
    return status;

  if (size != len)
    status = getClass()->getAttributes()[3]->setSize(this, len);
  if (status)
    return status;

  status = getClass()->getAttributes()[3]->setValue(this, (Data)_sval, len, 0);
  return status;

}

Status DBPropertyValue::sval(unsigned int a0, char _sval)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;
  Size from = a0;

  Size size;
  status = getClass()->getAttributes()[3]->getSize(this, size);
  if (status)
    return status;

  if (size <= from)
    status = getClass()->getAttributes()[3]->setSize(this, from+1);
  if (status)
    return status;

  status = getClass()->getAttributes()[3]->setValue(this, (Data)&_sval, 1, from);
  return status;
}

const char *DBPropertyValue::sval(Bool *isnull, Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  Data data;
  Status s;

  s = getClass()->getAttributes()[3]->getValue(this, (Data *)&data, Attribute::directAccess, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  if (!data) data = nulldata;
  return (const char *)data;
}

char DBPropertyValue::sval(unsigned int a0, Bool *isnull, Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  char __tmp = 0;
  Status s;
  Size from = a0;

  s = getClass()->getAttributes()[3]->getValue(this, (Data *)&__tmp, 1, from, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

Status DBPropertyValue::bval(const unsigned char *_bval, unsigned int len)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;
  Size size;
  status = getClass()->getAttributes()[4]->getSize(this, size);
  if (status)
    return status;

  if (size != len)
    status = getClass()->getAttributes()[4]->setSize(this, len);
  if (status)
    return status;

  status = getClass()->getAttributes()[4]->setValue(this, (Data)_bval, len, 0);
  return status;

}

Status DBPropertyValue::bval(unsigned int a0, unsigned char _bval)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;
  Size from = a0;

  Size size;
  status = getClass()->getAttributes()[4]->getSize(this, size);
  if (status)
    return status;

  if (size <= from)
    status = getClass()->getAttributes()[4]->setSize(this, from+1);
  if (status)
    return status;

  status = getClass()->getAttributes()[4]->setValue(this, (Data)&_bval, 1, from);
  return status;
}

Status DBPropertyValue::bval_cnt(unsigned int a0)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;
  Size from = a0;
  status = getClass()->getAttributes()[4]->setSize(this, from);
  return status;
}

const unsigned char *DBPropertyValue::bval(unsigned int *len, Bool *isnull, Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  Data data;
  Status s;

  s = getClass()->getAttributes()[4]->getValue(this, (Data *)&data, Attribute::directAccess, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  if (!data) data = nulldata;
  if (len) *len = bval_cnt();
  return (const unsigned char *)data;
}

unsigned char DBPropertyValue::bval(unsigned int a0, Bool *isnull, Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  unsigned char __tmp = 0;
  Status s;
  Size from = a0;

  s = getClass()->getAttributes()[4]->getValue(this, (Data *)&__tmp, 1, from, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

unsigned int DBPropertyValue::bval_cnt(Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  Size size;
  Status s;
  s = getClass()->getAttributes()[4]->getSize(this, size);
  if (s) {if (rs) *rs = s; return 0;}
  return (int)size;
}

Status DBPropertyValue::oval(Object *_oval)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;

  status = getClass()->getAttributes()[5]->setValue(this, (Data)&_oval, 1, 0);
  return status;
}

const Object *DBPropertyValue::oval(Bool *isnull, Status *rs) const 
{
  gbxAutoGarbSuspender _gbxsusp_;
  Object *__o = 0, *__go;
  Status s;

  s = getClass()->getAttributes()[5]->getValue(this, (Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (ObjectPeer::isGRTObject(__o)) {
       return (Object *)__o;
     }
     __go = (Object *)make_object(__o, False);
     if (__go)
      {
       __o = __go;
       s = getClass()->getAttributes()[5]->setValue((Agregat *)this, (Data)&__o, 1, 0);
       ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
     return (Object *)__o;
    }

  Bool wasnull = (!__o ? True : False);
  if (!__o && db)
    {
      Oid toid;
      s = getClass()->getAttributes()[5]->getOid(this, &toid, 1, 0);
      if (s) {if (rs) *rs = s; return 0;}
      if (toid.isValid())
        {
          s = db->loadObject(&toid, &__o);
          if (s) {if (rs) *rs = s; return 0;}
          if (!ObjectPeer::isGRTObject(__o))
           {
             __go = (Object *)make_object(__o, False);
             if (__go) __o = __go;
           }
        }
    }

  if (__o && wasnull)
    {
     s = getClass()->getAttributes()[5]->setValue((Agregat *)this, (Data)&__o, 1, 0);
     if (s) {if (rs) *rs = s; return 0;}
     __o->release();
    }
  return (Object *)__o;
}

Object *DBPropertyValue::oval(Bool *isnull, Status *rs) 
{
  gbxAutoGarbSuspender _gbxsusp_;
  Object *__o = 0, *__go;
  Status s;

  s = getClass()->getAttributes()[5]->getValue(this, (Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (ObjectPeer::isGRTObject(__o)) {
       return (Object *)__o;
     }
     __go = (Object *)make_object(__o, False);
     if (__go)
      {
       __o = __go;
       s = getClass()->getAttributes()[5]->setValue((Agregat *)this, (Data)&__o, 1, 0);
       ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
     return (Object *)__o;
    }

  Bool wasnull = (!__o ? True : False);
  if (!__o && db)
    {
      Oid toid;
      s = getClass()->getAttributes()[5]->getOid(this, &toid, 1, 0);
      if (s) {if (rs) *rs = s; return 0;}
      if (toid.isValid())
        {
          s = db->loadObject(&toid, &__o);
          if (s) {if (rs) *rs = s; return 0;}
          if (!ObjectPeer::isGRTObject(__o))
           {
             __go = (Object *)make_object(__o, False);
             if (__go) __o = __go;
           }
        }
    }

  if (__o && wasnull)
    {
     s = getClass()->getAttributes()[5]->setValue((Agregat *)this, (Data)&__o, 1, 0);
     if (s) {if (rs) *rs = s; return 0;}
     __o->release();
    }
  return (Object *)__o;
}

Status DBPropertyValue::oval_oid(const Oid &_oid)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;

  status = getClass()->getAttributes()[5]->setOid(this, &_oid, 1, 0, oid_check);
  return status;
}

Oid DBPropertyValue::oval_oid(Status *rs) 
{
  gbxAutoGarbSuspender _gbxsusp_;
  Oid __tmp;
  Status s;

  s = getClass()->getAttributes()[5]->getOid(this, &__tmp, 1, 0);
  if (s) {if (rs) *rs = s; return nulloid;}

  return __tmp;
}

static const Attribute **DBProperty_agritems;
static Size DBProperty_idr_objsz, DBProperty_idr_psize;

static StructClass *DBProperty_make(StructClass *DBProperty_class = 0, Schema *m = 0)
{
  if (!DBProperty_class)
    return new StructClass("database_property", (m ? m->getClass("struct") : Struct_Class));
  Attribute *attr[4];
  int *dims;

  dims = new int[1];
  dims[0] = -1;
  attr[2] = new Attribute((m ? m->getClass("char") : Char_Class), "key", False, 1, dims);
  delete[] dims;

  dims = 0;
  attr[3] = new Attribute((m ? m->getClass("database_property_value") : DBPropertyValue_Class), "value", False, 0, dims);

  DBProperty_class->setAttributes(&attr[2], 2);

  delete attr[2];
  delete attr[3];


  return DBProperty_class;
}

Object *DBProperty_construct_x(const Class *cls, Data idr)
{
  return new DBProperty(cls, idr);
}

Object *DBProperty_construct(const Object *o, Bool share)
{
  return new DBProperty((const Struct *)o, share);
}

static void DBProperty_init_p()
{
  DBProperty_Class = DBProperty_make();
  constructors_x[class_ind] = DBProperty_construct_x;
  constructors[class_ind] = DBProperty_construct;
  hash->insert("database_property", class_ind++);
}

static void DBProperty_init()
{
  DBProperty_make(DBProperty_Class);

  DBProperty_agritems = DBProperty_Class->getAttributes();
  DBProperty_idr_objsz = DBProperty_Class->getIDRObjectSize(&DBProperty_idr_psize, 0);

  ObjectPeer::setUnrealizable(DBProperty_Class, True);
}

static Status DBProperty_attrcomp_realize(Database *db, Class *cls)
{
  AttributeComponent *comp;
  const Dataspace *dataspace;
  ClassComponent *clcomp;
  Status status;
  int *impl_hints;
  impl_hints = new int[8];
  impl_hints[0] = 0;
  impl_hints[1] = 0;
  impl_hints[2] = 0;
  impl_hints[3] = 0;
  impl_hints[4] = 0;
  impl_hints[5] = 0;
  impl_hints[6] = 0;
  impl_hints[7] = 0;
  dataspace = 0;;
  comp = new HashIndex(db, cls, "database_property.key", True, True, dataspace, 0, 0, impl_hints, 8);
  delete [] impl_hints;
  cls->add(comp->getInd(), comp);

  return Success;
}

DBProperty::DBProperty(Database *_db, const Dataspace *_dataspace) : Struct(_db, _dataspace)
{
  initialize(_db);
}

DBProperty::DBProperty(const Class *_cls, Data _idr)
{
  setClass((Class *)_cls);

  Size idr_psize;
  Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  ClassPeer::newObjRealize(getClass(), this);
  ObjectPeer::setGRTObject(this, True);
  userInitialize();
}

void DBProperty::initialize(Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("database_property") : DBProperty_Class));

  Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  ClassPeer::newObjRealize(getClass(), this);
  ObjectPeer::setGRTObject(this, True);
  userInitialize();
}

DBProperty::DBProperty(const DBProperty& x) : Struct(x)
{
  userCopy(x);
}

DBProperty& DBProperty::operator=(const DBProperty& x)
{
  *(Struct *)this = Struct::operator=((const Struct &)x);
  userCopy(x);
  return *this;
}

DBProperty::DBProperty(const Struct *x, Bool share) : Struct(x, share)
{
  setClass((db ? db->getSchema()->getClass("database_property") : DBProperty_Class));

  Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      ClassPeer::newObjRealize(getClass(), this);
    }

  ObjectPeer::setGRTObject(this, True);
  userCopy(*x);
}

DBProperty::DBProperty(const DBProperty *x, Bool share) : Struct(x, share)
{
  setClass((db ? db->getSchema()->getClass("database_property") : DBProperty_Class));

  Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      ClassPeer::newObjRealize(getClass(), this);
    }

  ObjectPeer::setGRTObject(this, True);
  userCopy(*x);
}

Status DBProperty::key(const char *_key)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;
  Size size;
  Size len = ::strlen(_key) + 1;

  status = getClass()->getAttributes()[2]->getSize(this, size);
  if (status)
    return status;

  if (size != len)
    status = getClass()->getAttributes()[2]->setSize(this, len);
  if (status)
    return status;

  status = getClass()->getAttributes()[2]->setValue(this, (Data)_key, len, 0);
  return status;

}

Status DBProperty::key(unsigned int a0, char _key)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;
  Size from = a0;

  Size size;
  status = getClass()->getAttributes()[2]->getSize(this, size);
  if (status)
    return status;

  if (size <= from)
    status = getClass()->getAttributes()[2]->setSize(this, from+1);
  if (status)
    return status;

  status = getClass()->getAttributes()[2]->setValue(this, (Data)&_key, 1, from);
  return status;
}

const char *DBProperty::key(Bool *isnull, Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  Data data;
  Status s;

  s = getClass()->getAttributes()[2]->getValue(this, (Data *)&data, Attribute::directAccess, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  if (!data) data = nulldata;
  return (const char *)data;
}

char DBProperty::key(unsigned int a0, Bool *isnull, Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  char __tmp = 0;
  Status s;
  Size from = a0;

  s = getClass()->getAttributes()[2]->getValue(this, (Data *)&__tmp, 1, from, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

Status DBProperty::value(DBPropertyValue *_value)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;

  status = getClass()->getAttributes()[3]->setValue(this, (Data)&_value, 1, 0);
  return status;
}

const DBPropertyValue *DBProperty::value(Bool *isnull, Status *rs) const 
{
  gbxAutoGarbSuspender _gbxsusp_;
  Object *__o = 0, *__go;
  Status s;

  s = getClass()->getAttributes()[3]->getValue(this, (Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (ObjectPeer::isGRTObject(__o)) {
       return (DBPropertyValue *)__o;
     }
     __go = (DBPropertyValue *)make_object(__o, False);
     if (__go)
      {
       __o = __go;;
       s = getClass()->getAttributes()[3]->setValue((Agregat *)this, (Data)&__o, 1, 0);
       ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
    }
  return (DBPropertyValue *)__o;
}

DBPropertyValue *DBProperty::value(Bool *isnull, Status *rs) 
{
  gbxAutoGarbSuspender _gbxsusp_;
  Object *__o = 0, *__go;
  Status s;

  s = getClass()->getAttributes()[3]->getValue(this, (Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (ObjectPeer::isGRTObject(__o)) {
       return (DBPropertyValue *)__o;
     }
     __go = (DBPropertyValue *)make_object(__o, False);
     if (__go)
      {
       __o = __go;;
       s = getClass()->getAttributes()[3]->setValue((Agregat *)this, (Data)&__o, 1, 0);
       ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
    }
  return (DBPropertyValue *)__o;
}

static const char not_exit_msg[] = "class does not exist";
static const char differ_msg[] = "class differs in database and in runtime environment";

void DBMInit(void)
{
  if (hash) return;

  hash = new GenHashTable(0, 113);

  SysAccessMode_init_p();
  DBAccessMode_init_p();
  UserType_init_p();
  UserEntry_init_p();
  DBUserAccess_init_p();
  SysUserAccess_init_p();
  DBEntry_init_p();
  DBPropertyValue_init_p();
  DBProperty_init_p();
  SysAccessMode_init();
  DBAccessMode_init();
  UserType_init();
  UserEntry_init();
  DBUserAccess_init();
  SysUserAccess_init();
  DBEntry_init();
  DBPropertyValue_init();
  DBProperty_init();
}

void DBMRelease(void)
{
  delete hash;

  SysAccessMode_Class->release();
  DBAccessMode_Class->release();
  UserType_Class->release();
  UserEntry_Class->release();
  DBUserAccess_Class->release();
  SysUserAccess_Class->release();
  DBEntry_Class->release();
  DBPropertyValue_Class->release();
  DBProperty_Class->release();
}

static Status
DBMSchemaUpdate(Schema *m, Database *db)
{
  m->setName("eyedbdbm");
  Status status;
  EnumClass *SysAccessMode_class = SysAccessMode_make(0, m);
  if (!m->getClass("system_access_mode"))
    {
      status = m->addClass(SysAccessMode_class);
      if (status)
        return status;
    }
  EnumClass *DBAccessMode_class = DBAccessMode_make(0, m);
  if (!m->getClass("database_access_mode"))
    {
      status = m->addClass(DBAccessMode_class);
      if (status)
        return status;
    }
  EnumClass *UserType_class = UserType_make(0, m);
  if (!m->getClass("user_type"))
    {
      status = m->addClass(UserType_class);
      if (status)
        return status;
    }
  StructClass *UserEntry_class = UserEntry_make(0, m);
  if (!m->getClass("user_entry"))
    {
      status = m->addClass(UserEntry_class);
      if (status)
        return status;
    }
  StructClass *DBUserAccess_class = DBUserAccess_make(0, m);
  if (!m->getClass("database_user_access"))
    {
      status = m->addClass(DBUserAccess_class);
      if (status)
        return status;
    }
  StructClass *SysUserAccess_class = SysUserAccess_make(0, m);
  if (!m->getClass("system_user_access"))
    {
      status = m->addClass(SysUserAccess_class);
      if (status)
        return status;
    }
  StructClass *DBEntry_class = DBEntry_make(0, m);
  if (!m->getClass("database_entry"))
    {
      status = m->addClass(DBEntry_class);
      if (status)
        return status;
    }
  StructClass *DBPropertyValue_class = DBPropertyValue_make(0, m);
  if (!m->getClass("database_property_value"))
    {
      status = m->addClass(DBPropertyValue_class);
      if (status)
        return status;
    }
  StructClass *DBProperty_class = DBProperty_make(0, m);
  if (!m->getClass("database_property"))
    {
      status = m->addClass(DBProperty_class);
      if (status)
        return status;
    }

  SysAccessMode_make(SysAccessMode_class, m);
  DBAccessMode_make(DBAccessMode_class, m);
  UserType_make(UserType_class, m);
  UserEntry_make(UserEntry_class, m);
  DBUserAccess_make(DBUserAccess_class, m);
  SysUserAccess_make(SysUserAccess_class, m);
  DBEntry_make(DBEntry_class, m);
  DBPropertyValue_make(DBPropertyValue_class, m);
  DBProperty_make(DBProperty_class, m);

  if (!db) return Success;

  if (!SysAccessMode_class->compare(m->getClass("system_access_mode")))
    return Exception::make(IDB_ERROR, "'SysAccessMode' %s", differ_msg);
  if (!DBAccessMode_class->compare(m->getClass("database_access_mode")))
    return Exception::make(IDB_ERROR, "'DBAccessMode' %s", differ_msg);
  if (!UserType_class->compare(m->getClass("user_type")))
    return Exception::make(IDB_ERROR, "'UserType' %s", differ_msg);
  if (!UserEntry_class->compare(m->getClass("user_entry")))
    return Exception::make(IDB_ERROR, "'UserEntry' %s", differ_msg);
  if (!DBUserAccess_class->compare(m->getClass("database_user_access")))
    return Exception::make(IDB_ERROR, "'DBUserAccess' %s", differ_msg);
  if (!SysUserAccess_class->compare(m->getClass("system_user_access")))
    return Exception::make(IDB_ERROR, "'SysUserAccess' %s", differ_msg);
  if (!DBEntry_class->compare(m->getClass("database_entry")))
    return Exception::make(IDB_ERROR, "'DBEntry' %s", differ_msg);
  if (!DBPropertyValue_class->compare(m->getClass("database_property_value")))
    return Exception::make(IDB_ERROR, "'DBPropertyValue' %s", differ_msg);
  if (!DBProperty_class->compare(m->getClass("database_property")))
    return Exception::make(IDB_ERROR, "'DBProperty' %s", differ_msg);

  db->transactionBegin();

  if ((status = UserEntry_attrcomp_realize(db, m->getClass("user_entry")))) return status;

  if ((status = DBUserAccess_attrcomp_realize(db, m->getClass("database_user_access")))) return status;

  if ((status = SysUserAccess_attrcomp_realize(db, m->getClass("system_user_access")))) return status;

  if ((status = DBEntry_attrcomp_realize(db, m->getClass("database_entry")))) return status;

  if ((status = DBPropertyValue_attrcomp_realize(db, m->getClass("database_property_value")))) return status;

  if ((status = DBProperty_attrcomp_realize(db, m->getClass("database_property")))) return status;
  status = m->realize();
  if (status) return status;
  db->transactionCommit();
  return Success;
}

Status DBMSchemaUpdate(Database *db)
{
  return DBMSchemaUpdate(db->getSchema(), db);
}

Status DBMSchemaUpdate(Schema *m)
{
  return DBMSchemaUpdate(m, NULL);
}

Object *DBMMakeObject(Object *o, Bool remove)
{
  if (!o->getClass()) return (Object *)0;
  if (ObjectPeer::isGRTObject(o))
    return o;
  int ind = hash->get(o->getClass()->getName());
  if (ind < 0 && (!o->getClass()->getStrictAliasName() || (ind = hash->get(o->getClass()->getStrictAliasName())) < 0)) return 0;
  Object *co = constructors[ind](o, (remove ? True : False));
  ObjectPeer::setClass(co, o->getClass());
  if (remove) o->release();
  if (co->getDatabase())
    co->getDatabase()->cacheObject(co);
  return co;
}

Status DBMDatabase::open(Connection *ch, Database::OpenFlag flag, const char *userauth, const char *passwdauth)
{
    return open(ch, flag, 0, userauth, passwdauth);
}

Status DBMDatabase::open(Connection *ch, Database::OpenFlag flag, const OpenHints *hints, const char *userauth, const char *passwdauth)
{
  Status status = Database::open(ch, flag, hints, userauth, passwdauth);
  if (status) return status;
  transactionBegin();
  status = DBMDatabase::checkSchema(getSchema());
  transactionCommit();

  if (!status) add(hash, constructors_x);

  return status;
}

void DBMDatabase::setConsApp(Database *_db)
{
  _db->add(hash, constructors_x);
}

static void append(char *&s, const char *m1, const char *m2)
{
  if (!s) {s = (char *)malloc(strlen(m1)+strlen(m2)+2); *s = 0;}
  else s = (char *)realloc(s, strlen(s)+strlen(m1)+strlen(m2)+2);
  strcat(s, m1);
  strcat(s, m2);
  strcat(s, "\n");
}

Bool DBMDatabase::getDynamicGetErrorPolicy() {
   throw *Exception::make(IDB_ERROR, "getDynamicGetErrorPolicy() can be called only when the dynamic attribute fonctionnality is on (-dynamic-attr option of eyedbodl)");
}

Bool DBMDatabase::getDynamicSetErrorPolicy() {
   throw *Exception::make(IDB_ERROR, "getDynamicSetErrorPolicy() can be called only when the dynamic attribute fonctionnality is on (-dynamic-attr option of eyedbodl)");
}

void DBMDatabase::setDynamicGetErrorPolicy(Bool policy) {
   throw *Exception::make(IDB_ERROR, "setDynamicGetErrorPolicy() can be called only when the dynamic attribute fonctionnality is on (-dynamic-attr option of eyedbodl)");
}

void DBMDatabase::setDynamicSetErrorPolicy(Bool policy) {
   throw *Exception::make(IDB_ERROR, "setDynamicSetErrorPolicy() can be called only when the dynamic attribute fonctionnality is on (-dynamic-attr option of eyedbodl)");
}

Status DBMDatabase::checkSchema(Schema *m)
{
  Class *cl;
  char *s = 0;

  if (!(cl = m->getClass("system_access_mode")))
    append(s, "'system_access_mode' ", not_exit_msg);
  else if (!SysAccessMode_Class->compare(cl))
    append(s, "'SysAccessMode' ", differ_msg);
  if (!(cl = m->getClass("database_access_mode")))
    append(s, "'database_access_mode' ", not_exit_msg);
  else if (!DBAccessMode_Class->compare(cl))
    append(s, "'DBAccessMode' ", differ_msg);
  if (!(cl = m->getClass("user_type")))
    append(s, "'user_type' ", not_exit_msg);
  else if (!UserType_Class->compare(cl))
    append(s, "'UserType' ", differ_msg);
  if (!(cl = m->getClass("user_entry")))
    append(s, "'user_entry' ", not_exit_msg);
  else if (!UserEntry_Class->compare(cl))
    append(s, "'UserEntry' ", differ_msg);
  if (!(cl = m->getClass("database_user_access")))
    append(s, "'database_user_access' ", not_exit_msg);
  else if (!DBUserAccess_Class->compare(cl))
    append(s, "'DBUserAccess' ", differ_msg);
  if (!(cl = m->getClass("system_user_access")))
    append(s, "'system_user_access' ", not_exit_msg);
  else if (!SysUserAccess_Class->compare(cl))
    append(s, "'SysUserAccess' ", differ_msg);
  if (!(cl = m->getClass("database_entry")))
    append(s, "'database_entry' ", not_exit_msg);
  else if (!DBEntry_Class->compare(cl))
    append(s, "'DBEntry' ", differ_msg);
  if (!(cl = m->getClass("database_property_value")))
    append(s, "'database_property_value' ", not_exit_msg);
  else if (!DBPropertyValue_Class->compare(cl))
    append(s, "'DBPropertyValue' ", differ_msg);
  if (!(cl = m->getClass("database_property")))
    append(s, "'database_property' ", not_exit_msg);
  else if (!DBProperty_Class->compare(cl))
    append(s, "'DBProperty' ", differ_msg);
  if (s) {Status status = Exception::make(s); free(s); return status;}
  return Success;
}

Bool DBM_set_oid_check(Bool _oid_check)
{
  Bool old = oid_check;
  oid_check = _oid_check;
  return old;
}

Bool DBM_get_oid_check()
{
  return oid_check;
}

}
