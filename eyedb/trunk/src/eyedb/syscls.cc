
/*
 * File 'syscls.cc'
 *
 * Package Name 'syscls'
 *
 * Generated by eyedbodl at Thu Dec  8 15:48:01 2005
 *
 * -------------------------------------
 * ------- DO NOT EDIT THIS CODE -------
 * -------------------------------------
 *
 */

#include <eyedb/eyedb.h>

#include <eyedb/internals/ObjectPeer.h>
#include <eyedb/internals/ClassPeer.h>
#include <eyedb/internals/kern_const.h>

#include <eyedb/syscls.h>

#define min(x,y)((x)<(y)?(x):(y))

namespace eyedb {

static Bool dynget_error_policy = False;
static Bool dynset_error_policy = True;
static Oid nulloid;
static unsigned char nulldata[1];
static Bool oid_check = True;
static int class_ind;
static Database::consapp_t *constructors_x = new Database::consapp_t[105];
static Object *(*constructors[105])(const Object *, Bool);
static GenHashTable *hash;
#define make_object sysclsMakeObject
extern void sysclsInit(void);
extern void sysclsRelease(void);
extern Status sysclsSchemaUpdate(Database *);
extern Status sysclsSchemaUpdate(Schema *);

static Class *index_Class = new Class("index");

void syscls::init()
{
  sysclsInit();
}

void syscls::release()
{
  sysclsRelease();
}

Status syscls::updateSchema(Database *db)
{
  return sysclsSchemaUpdate(db);
}

Status syscls::updateSchema(Schema *m)
{
  return sysclsSchemaUpdate(m);
}

EnumClass *IndexType_Class;
EnumClass *ExecutableLang_Class;
EnumClass *ArgType_Type_Class;
EnumClass *ExecutableLocalisation_Class;
EnumClass *ExecutableType_Class;
EnumClass *TriggerType_Class;
EnumClass *ProtectionMode_Class;
EnumClass *ClassUpdateType_Class;
EnumClass *AttributeConvertType_Class;
StructClass *AttributeComponent_Class;
StructClass *AttributeComponentSet_Class;
StructClass *ClassComponent_Class;
StructClass *AgregatClassComponent_Class;
StructClass *ClassVariable_Class;
StructClass *Index_Class;
StructClass *HashIndex_Class;
StructClass *BTreeIndex_Class;
StructClass *CollAttrImpl_Class;
StructClass *ArgType_Class;
StructClass *Signature_Class;
StructClass *Executable_Class;
StructClass *AgregatClassExecutable_Class;
StructClass *Method_Class;
StructClass *FEMethod_Class;
StructClass *FEMethod_C_Class;
StructClass *BEMethod_Class;
StructClass *BEMethod_C_Class;
StructClass *BEMethod_OQL_Class;
StructClass *Trigger_Class;
StructClass *UniqueConstraint_Class;
StructClass *NotNullConstraint_Class;
StructClass *CardinalityDescription_Class;
StructClass *CardinalityConstraint_Class;
StructClass *CardinalityConstraint_Test_Class;
StructClass *ProtectionUser_Class;
StructClass *Protection_Class;
StructClass *UnreadableObject_Class;
StructClass *ClassConversion_Class;
static CollSetClass *set_class_AttributeComponent_ref_Class;

static Size IndexType_idr_objsz, IndexType_idr_psize;

static EnumClass *IndexType_make(EnumClass *IndexType_class = 0, Schema *m = 0)
{
  if (!IndexType_class)
    return new EnumClass("index_type");
  EnumItem *en[2];
  en[0] = new EnumItem("HASH_INDEX_TYPE", "HashIndexType", (unsigned int)32);
  en[1] = new EnumItem("BTREE_INDEX_TYPE", "BTreeIndexType", (unsigned int)64);

  IndexType_class->setEnumItems(en, 2);

  delete en[0];
  delete en[1];

  ClassPeer::setMType(IndexType_class, Class::System);

  return IndexType_class;
}

static void IndexType_init_p()
{
  IndexType_Class = IndexType_make();
}

static void IndexType_init()
{
  IndexType_make(IndexType_Class);

  IndexType_idr_objsz = IndexType_Class->getIDRObjectSize(&IndexType_idr_psize, 0);

  ObjectPeer::setUnrealizable(IndexType_Class, True);
}

static Size ExecutableLang_idr_objsz, ExecutableLang_idr_psize;

static EnumClass *ExecutableLang_make(EnumClass *ExecutableLang_class = 0, Schema *m = 0)
{
  if (!ExecutableLang_class)
    return new EnumClass("executable_lang");
  EnumItem *en[3];
  en[0] = new EnumItem("C_LANG", "C_LANG", (unsigned int)1);
  en[1] = new EnumItem("OQL_LANG", "OQL_LANG", (unsigned int)2);
  en[2] = new EnumItem("SYSTEM_EXEC", "SYSTEM_EXEC", (unsigned int)256);

  ExecutableLang_class->setEnumItems(en, 3);

  delete en[0];
  delete en[1];
  delete en[2];

  ClassPeer::setMType(ExecutableLang_class, Class::System);

  return ExecutableLang_class;
}

static void ExecutableLang_init_p()
{
  ExecutableLang_Class = ExecutableLang_make();
}

static void ExecutableLang_init()
{
  ExecutableLang_make(ExecutableLang_Class);

  ExecutableLang_idr_objsz = ExecutableLang_Class->getIDRObjectSize(&ExecutableLang_idr_psize, 0);

  ObjectPeer::setUnrealizable(ExecutableLang_Class, True);
}

static Size ArgType_Type_idr_objsz, ArgType_Type_idr_psize;

static EnumClass *ArgType_Type_make(EnumClass *ArgType_Type_class = 0, Schema *m = 0)
{
  if (!ArgType_Type_class)
    return new EnumClass("argtype_type");
  EnumItem *en[16];
  en[0] = new EnumItem("ANY_TYPE", "ANY_TYPE", (unsigned int)0);
  en[1] = new EnumItem("VOID_TYPE", "VOID_TYPE", (unsigned int)1);
  en[2] = new EnumItem("INT16_TYPE", "INT16_TYPE", (unsigned int)2);
  en[3] = new EnumItem("INT32_TYPE", "INT32_TYPE", (unsigned int)3);
  en[4] = new EnumItem("INT64_TYPE", "INT64_TYPE", (unsigned int)4);
  en[5] = new EnumItem("STRING_TYPE", "STRING_TYPE", (unsigned int)5);
  en[6] = new EnumItem("CHAR_TYPE", "CHAR_TYPE", (unsigned int)6);
  en[7] = new EnumItem("FLOAT_TYPE", "FLOAT_TYPE", (unsigned int)7);
  en[8] = new EnumItem("OID_TYPE", "OID_TYPE", (unsigned int)8);
  en[9] = new EnumItem("OBJ_TYPE", "OBJ_TYPE", (unsigned int)9);
  en[10] = new EnumItem("RAW_TYPE", "RAW_TYPE", (unsigned int)10);
  en[11] = new EnumItem("BYTE_TYPE", "BYTE_TYPE", (unsigned int)11);
  en[12] = new EnumItem("ARRAY_TYPE", "ARRAY_TYPE", (unsigned int)256);
  en[13] = new EnumItem("IN_ARG_TYPE", "IN_ARG_TYPE", (unsigned int)4096);
  en[14] = new EnumItem("OUT_ARG_TYPE", "OUT_ARG_TYPE", (unsigned int)8192);
  en[15] = new EnumItem("INOUT_ARG_TYPE", "INOUT_ARG_TYPE", (unsigned int)12288);

  ArgType_Type_class->setEnumItems(en, 16);

  delete en[0];
  delete en[1];
  delete en[2];
  delete en[3];
  delete en[4];
  delete en[5];
  delete en[6];
  delete en[7];
  delete en[8];
  delete en[9];
  delete en[10];
  delete en[11];
  delete en[12];
  delete en[13];
  delete en[14];
  delete en[15];

  ClassPeer::setMType(ArgType_Type_class, Class::System);

  return ArgType_Type_class;
}

static void ArgType_Type_init_p()
{
  ArgType_Type_Class = ArgType_Type_make();
}

static void ArgType_Type_init()
{
  ArgType_Type_make(ArgType_Type_Class);

  ArgType_Type_idr_objsz = ArgType_Type_Class->getIDRObjectSize(&ArgType_Type_idr_psize, 0);

  ObjectPeer::setUnrealizable(ArgType_Type_Class, True);
}

static Size ExecutableLocalisation_idr_objsz, ExecutableLocalisation_idr_psize;

static EnumClass *ExecutableLocalisation_make(EnumClass *ExecutableLocalisation_class = 0, Schema *m = 0)
{
  if (!ExecutableLocalisation_class)
    return new EnumClass("executable_localisation");
  EnumItem *en[3];
  en[0] = new EnumItem("BACKEND", "BACKEND", (unsigned int)1);
  en[1] = new EnumItem("FRONTEND", "FRONTEND", (unsigned int)2);
  en[2] = new EnumItem("STATIC_EXEC", "STATIC_EXEC", (unsigned int)256);

  ExecutableLocalisation_class->setEnumItems(en, 3);

  delete en[0];
  delete en[1];
  delete en[2];

  ClassPeer::setMType(ExecutableLocalisation_class, Class::System);

  return ExecutableLocalisation_class;
}

static void ExecutableLocalisation_init_p()
{
  ExecutableLocalisation_Class = ExecutableLocalisation_make();
}

static void ExecutableLocalisation_init()
{
  ExecutableLocalisation_make(ExecutableLocalisation_Class);

  ExecutableLocalisation_idr_objsz = ExecutableLocalisation_Class->getIDRObjectSize(&ExecutableLocalisation_idr_psize, 0);

  ObjectPeer::setUnrealizable(ExecutableLocalisation_Class, True);
}

static Size ExecutableType_idr_objsz, ExecutableType_idr_psize;

static EnumClass *ExecutableType_make(EnumClass *ExecutableType_class = 0, Schema *m = 0)
{
  if (!ExecutableType_class)
    return new EnumClass("executable_type");
  EnumItem *en[4];
  en[0] = new EnumItem("METHOD_C_TYPE", "METHOD_C_TYPE", (unsigned int)2);
  en[1] = new EnumItem("METHOD_OQL_TYPE", "METHOD_OQL_TYPE", (unsigned int)18);
  en[2] = new EnumItem("TRIGGER_C_TYPE", "TRIGGER_C_TYPE", (unsigned int)8);
  en[3] = new EnumItem("TRIGGER_OQL_TYPE", "TRIGGER_OQL_TYPE", (unsigned int)24);

  ExecutableType_class->setEnumItems(en, 4);

  delete en[0];
  delete en[1];
  delete en[2];
  delete en[3];

  ClassPeer::setMType(ExecutableType_class, Class::System);

  return ExecutableType_class;
}

static void ExecutableType_init_p()
{
  ExecutableType_Class = ExecutableType_make();
}

static void ExecutableType_init()
{
  ExecutableType_make(ExecutableType_Class);

  ExecutableType_idr_objsz = ExecutableType_Class->getIDRObjectSize(&ExecutableType_idr_psize, 0);

  ObjectPeer::setUnrealizable(ExecutableType_Class, True);
}

static Size TriggerType_idr_objsz, TriggerType_idr_psize;

static EnumClass *TriggerType_make(EnumClass *TriggerType_class = 0, Schema *m = 0)
{
  if (!TriggerType_class)
    return new EnumClass("trigger_type");
  EnumItem *en[8];
  en[0] = new EnumItem("TRIGGER_CREATE_BEFORE", "TriggerCREATE_BEFORE", (unsigned int)17);
  en[1] = new EnumItem("TRIGGER_CREATE_AFTER", "TriggerCREATE_AFTER", (unsigned int)18);
  en[2] = new EnumItem("TRIGGER_UPDATE_BEFORE", "TriggerUPDATE_BEFORE", (unsigned int)33);
  en[3] = new EnumItem("TRIGGER_UPDATE_AFTER", "TriggerUPDATE_AFTER", (unsigned int)34);
  en[4] = new EnumItem("TRIGGER_LOAD_BEFORE", "TriggerLOAD_BEFORE", (unsigned int)65);
  en[5] = new EnumItem("TRIGGER_LOAD_AFTER", "TriggerLOAD_AFTER", (unsigned int)66);
  en[6] = new EnumItem("TRIGGER_REMOVE_BEFORE", "TriggerREMOVE_BEFORE", (unsigned int)129);
  en[7] = new EnumItem("TRIGGER_REMOVE_AFTER", "TriggerREMOVE_AFTER", (unsigned int)130);

  TriggerType_class->setEnumItems(en, 8);

  delete en[0];
  delete en[1];
  delete en[2];
  delete en[3];
  delete en[4];
  delete en[5];
  delete en[6];
  delete en[7];

  ClassPeer::setMType(TriggerType_class, Class::System);

  return TriggerType_class;
}

static void TriggerType_init_p()
{
  TriggerType_Class = TriggerType_make();
}

static void TriggerType_init()
{
  TriggerType_make(TriggerType_Class);

  TriggerType_idr_objsz = TriggerType_Class->getIDRObjectSize(&TriggerType_idr_psize, 0);

  ObjectPeer::setUnrealizable(TriggerType_Class, True);
}

static Size ProtectionMode_idr_objsz, ProtectionMode_idr_psize;

static EnumClass *ProtectionMode_make(EnumClass *ProtectionMode_class = 0, Schema *m = 0)
{
  if (!ProtectionMode_class)
    return new EnumClass("protection_mode");
  EnumItem *en[2];
  en[0] = new EnumItem("PROT_READ", "ProtRead", (unsigned int)256);
  en[1] = new EnumItem("PROT_RW", "ProtRW", (unsigned int)257);

  ProtectionMode_class->setEnumItems(en, 2);

  delete en[0];
  delete en[1];

  ClassPeer::setMType(ProtectionMode_class, Class::System);

  return ProtectionMode_class;
}

static void ProtectionMode_init_p()
{
  ProtectionMode_Class = ProtectionMode_make();
}

static void ProtectionMode_init()
{
  ProtectionMode_make(ProtectionMode_Class);

  ProtectionMode_idr_objsz = ProtectionMode_Class->getIDRObjectSize(&ProtectionMode_idr_psize, 0);

  ObjectPeer::setUnrealizable(ProtectionMode_Class, True);
}

static Size ClassUpdateType_idr_objsz, ClassUpdateType_idr_psize;

static EnumClass *ClassUpdateType_make(EnumClass *ClassUpdateType_class = 0, Schema *m = 0)
{
  if (!ClassUpdateType_class)
    return new EnumClass("class_update_type");
  EnumItem *en[5];
  en[0] = new EnumItem("ADD_ATTR", "ADD_ATTR", (unsigned int)0);
  en[1] = new EnumItem("RMV_ATTR", "RMV_ATTR", (unsigned int)1);
  en[2] = new EnumItem("CNV_ATTR", "CNV_ATTR", (unsigned int)2);
  en[3] = new EnumItem("MIG_ATTR", "MIG_ATTR", (unsigned int)3);
  en[4] = new EnumItem("RMV_CLASS", "RMV_CLASS", (unsigned int)4);

  ClassUpdateType_class->setEnumItems(en, 5);

  delete en[0];
  delete en[1];
  delete en[2];
  delete en[3];
  delete en[4];

  ClassPeer::setMType(ClassUpdateType_class, Class::System);

  return ClassUpdateType_class;
}

static void ClassUpdateType_init_p()
{
  ClassUpdateType_Class = ClassUpdateType_make();
}

static void ClassUpdateType_init()
{
  ClassUpdateType_make(ClassUpdateType_Class);

  ClassUpdateType_idr_objsz = ClassUpdateType_Class->getIDRObjectSize(&ClassUpdateType_idr_psize, 0);

  ObjectPeer::setUnrealizable(ClassUpdateType_Class, True);
}

static Size AttributeConvertType_idr_objsz, AttributeConvertType_idr_psize;

static EnumClass *AttributeConvertType_make(EnumClass *AttributeConvertType_class = 0, Schema *m = 0)
{
  if (!AttributeConvertType_class)
    return new EnumClass("attribute_convert_type");
  EnumItem *en[76];
  en[0] = new EnumItem("INT16_TO_INT16", "INT16_TO_INT16", (unsigned int)0);
  en[1] = new EnumItem("INT16_TO_INT32", "INT16_TO_INT32", (unsigned int)1);
  en[2] = new EnumItem("INT16_TO_INT64", "INT16_TO_INT64", (unsigned int)2);
  en[3] = new EnumItem("INT16_TO_FLOAT", "INT16_TO_FLOAT", (unsigned int)3);
  en[4] = new EnumItem("INT16_TO_BYTE", "INT16_TO_BYTE", (unsigned int)4);
  en[5] = new EnumItem("INT16_TO_CHAR", "INT16_TO_CHAR", (unsigned int)5);
  en[6] = new EnumItem("INT16_TO_ENUM", "INT16_TO_ENUM", (unsigned int)6);
  en[7] = new EnumItem("INT32_TO_INT32", "INT32_TO_INT32", (unsigned int)7);
  en[8] = new EnumItem("INT32_TO_INT16", "INT32_TO_INT16", (unsigned int)8);
  en[9] = new EnumItem("INT32_TO_INT64", "INT32_TO_INT64", (unsigned int)9);
  en[10] = new EnumItem("INT32_TO_FLOAT", "INT32_TO_FLOAT", (unsigned int)10);
  en[11] = new EnumItem("INT32_TO_BYTE", "INT32_TO_BYTE", (unsigned int)11);
  en[12] = new EnumItem("INT32_TO_CHAR", "INT32_TO_CHAR", (unsigned int)12);
  en[13] = new EnumItem("INT32_TO_ENUM", "INT32_TO_ENUM", (unsigned int)13);
  en[14] = new EnumItem("INT64_TO_INT64", "INT64_TO_INT64", (unsigned int)14);
  en[15] = new EnumItem("INT64_TO_INT16", "INT64_TO_INT16", (unsigned int)15);
  en[16] = new EnumItem("INT64_TO_INT32", "INT64_TO_INT32", (unsigned int)16);
  en[17] = new EnumItem("INT64_TO_FLOAT", "INT64_TO_FLOAT", (unsigned int)17);
  en[18] = new EnumItem("INT64_TO_BYTE", "INT64_TO_BYTE", (unsigned int)18);
  en[19] = new EnumItem("INT64_TO_CHAR", "INT64_TO_CHAR", (unsigned int)19);
  en[20] = new EnumItem("INT64_TO_ENUM", "INT64_TO_ENUM", (unsigned int)20);
  en[21] = new EnumItem("FLOAT_TO_FLOAT", "FLOAT_TO_FLOAT", (unsigned int)21);
  en[22] = new EnumItem("FLOAT_TO_INT16", "FLOAT_TO_INT16", (unsigned int)22);
  en[23] = new EnumItem("FLOAT_TO_INT32", "FLOAT_TO_INT32", (unsigned int)23);
  en[24] = new EnumItem("FLOAT_TO_INT64", "FLOAT_TO_INT64", (unsigned int)24);
  en[25] = new EnumItem("FLOAT_TO_BYTE", "FLOAT_TO_BYTE", (unsigned int)25);
  en[26] = new EnumItem("FLOAT_TO_CHAR", "FLOAT_TO_CHAR", (unsigned int)26);
  en[27] = new EnumItem("FLOAT_TO_ENUM", "FLOAT_TO_ENUM", (unsigned int)27);
  en[28] = new EnumItem("CHAR_TO_CHAR", "CHAR_TO_CHAR", (unsigned int)28);
  en[29] = new EnumItem("CHAR_TO_INT16", "CHAR_TO_INT16", (unsigned int)29);
  en[30] = new EnumItem("CHAR_TO_INT32", "CHAR_TO_INT32", (unsigned int)30);
  en[31] = new EnumItem("CHAR_TO_INT64", "CHAR_TO_INT64", (unsigned int)31);
  en[32] = new EnumItem("CHAR_TO_FLOAT", "CHAR_TO_FLOAT", (unsigned int)32);
  en[33] = new EnumItem("CHAR_TO_BYTE", "CHAR_TO_BYTE", (unsigned int)33);
  en[34] = new EnumItem("CHAR_TO_ENUM", "CHAR_TO_ENUM", (unsigned int)34);
  en[35] = new EnumItem("BYTE_TO_BYTE", "BYTE_TO_BYTE", (unsigned int)35);
  en[36] = new EnumItem("BYTE_TO_INT16", "BYTE_TO_INT16", (unsigned int)36);
  en[37] = new EnumItem("BYTE_TO_INT32", "BYTE_TO_INT32", (unsigned int)37);
  en[38] = new EnumItem("BYTE_TO_INT64", "BYTE_TO_INT64", (unsigned int)38);
  en[39] = new EnumItem("BYTE_TO_FLOAT", "BYTE_TO_FLOAT", (unsigned int)39);
  en[40] = new EnumItem("BYTE_TO_CHAR", "BYTE_TO_CHAR", (unsigned int)40);
  en[41] = new EnumItem("BYTE_TO_ENUM", "BYTE_TO_ENUM", (unsigned int)41);
  en[42] = new EnumItem("ENUM_TO_ENUM", "ENUM_TO_ENUM", (unsigned int)42);
  en[43] = new EnumItem("ENUM_TO_INT16", "ENUM_TO_INT16", (unsigned int)43);
  en[44] = new EnumItem("ENUM_TO_INT32", "ENUM_TO_INT32", (unsigned int)44);
  en[45] = new EnumItem("ENUM_TO_INT64", "ENUM_TO_INT64", (unsigned int)45);
  en[46] = new EnumItem("ENUM_TO_FLOAT", "ENUM_TO_FLOAT", (unsigned int)46);
  en[47] = new EnumItem("ENUM_TO_CHAR", "ENUM_TO_CHAR", (unsigned int)47);
  en[48] = new EnumItem("ENUM_TO_BYTE", "ENUM_TO_BYTE", (unsigned int)48);
  en[49] = new EnumItem("CHAR_TO_STRING", "CHAR_TO_STRING", (unsigned int)49);
  en[50] = new EnumItem("STRING_TO_CHAR", "STRING_TO_CHAR", (unsigned int)50);
  en[51] = new EnumItem("INT16_TO_STRING", "INT16_TO_STRING", (unsigned int)51);
  en[52] = new EnumItem("STRING_TO_INT16", "STRING_TO_INT16", (unsigned int)52);
  en[53] = new EnumItem("INT32_TO_STRING", "INT32_TO_STRING", (unsigned int)53);
  en[54] = new EnumItem("STRING_TO_INT32", "STRING_TO_INT32", (unsigned int)54);
  en[55] = new EnumItem("INT64_TO_STRING", "INT64_TO_STRING", (unsigned int)55);
  en[56] = new EnumItem("STRING_TO_INT64", "STRING_TO_INT64", (unsigned int)56);
  en[57] = new EnumItem("FLOAT_TO_STRING", "FLOAT_TO_STRING", (unsigned int)57);
  en[58] = new EnumItem("STRING_TO_FLOAT", "STRING_TO_FLOAT", (unsigned int)58);
  en[59] = new EnumItem("BYTE_TO_STRING", "BYTE_TO_STRING", (unsigned int)59);
  en[60] = new EnumItem("STRING_TO_BYTE", "STRING_TO_BYTE", (unsigned int)60);
  en[61] = new EnumItem("SET_TO_BAG", "SET_TO_BAG", (unsigned int)61);
  en[62] = new EnumItem("SET_TO_ARRAY", "SET_TO_ARRAY", (unsigned int)62);
  en[63] = new EnumItem("SET_TO_LIST", "SET_TO_LIST", (unsigned int)63);
  en[64] = new EnumItem("BAG_TO_SET", "BAG_TO_SET", (unsigned int)64);
  en[65] = new EnumItem("BAG_TO_ARRAY", "BAG_TO_ARRAY", (unsigned int)65);
  en[66] = new EnumItem("BAG_TO_LIST", "BAG_TO_LIST", (unsigned int)66);
  en[67] = new EnumItem("ARRAY_TO_BAG", "ARRAY_TO_BAG", (unsigned int)67);
  en[68] = new EnumItem("ARRAY_TO_SET", "ARRAY_TO_SET", (unsigned int)68);
  en[69] = new EnumItem("ARRAY_TO_LIST", "ARRAY_TO_LIST", (unsigned int)69);
  en[70] = new EnumItem("LIST_TO_BAG", "LIST_TO_BAG", (unsigned int)70);
  en[71] = new EnumItem("LIST_TO_ARRAY", "LIST_TO_ARRAY", (unsigned int)71);
  en[72] = new EnumItem("LIST_TO_SET", "LIST_TO_SET", (unsigned int)72);
  en[73] = new EnumItem("CLASS_TO_CLASS", "CLASS_TO_CLASS", (unsigned int)73);
  en[74] = new EnumItem("USER_CNV", "USER_CNV", (unsigned int)74);
  en[75] = new EnumItem("NIL_CNV", "NIL_CNV", (unsigned int)75);

  AttributeConvertType_class->setEnumItems(en, 76);

  delete en[0];
  delete en[1];
  delete en[2];
  delete en[3];
  delete en[4];
  delete en[5];
  delete en[6];
  delete en[7];
  delete en[8];
  delete en[9];
  delete en[10];
  delete en[11];
  delete en[12];
  delete en[13];
  delete en[14];
  delete en[15];
  delete en[16];
  delete en[17];
  delete en[18];
  delete en[19];
  delete en[20];
  delete en[21];
  delete en[22];
  delete en[23];
  delete en[24];
  delete en[25];
  delete en[26];
  delete en[27];
  delete en[28];
  delete en[29];
  delete en[30];
  delete en[31];
  delete en[32];
  delete en[33];
  delete en[34];
  delete en[35];
  delete en[36];
  delete en[37];
  delete en[38];
  delete en[39];
  delete en[40];
  delete en[41];
  delete en[42];
  delete en[43];
  delete en[44];
  delete en[45];
  delete en[46];
  delete en[47];
  delete en[48];
  delete en[49];
  delete en[50];
  delete en[51];
  delete en[52];
  delete en[53];
  delete en[54];
  delete en[55];
  delete en[56];
  delete en[57];
  delete en[58];
  delete en[59];
  delete en[60];
  delete en[61];
  delete en[62];
  delete en[63];
  delete en[64];
  delete en[65];
  delete en[66];
  delete en[67];
  delete en[68];
  delete en[69];
  delete en[70];
  delete en[71];
  delete en[72];
  delete en[73];
  delete en[74];
  delete en[75];

  ClassPeer::setMType(AttributeConvertType_class, Class::System);

  return AttributeConvertType_class;
}

static void AttributeConvertType_init_p()
{
  AttributeConvertType_Class = AttributeConvertType_make();
}

static void AttributeConvertType_init()
{
  AttributeConvertType_make(AttributeConvertType_Class);

  AttributeConvertType_idr_objsz = AttributeConvertType_Class->getIDRObjectSize(&AttributeConvertType_idr_psize, 0);

  ObjectPeer::setUnrealizable(AttributeConvertType_Class, True);
}

static const Attribute **AttributeComponent_agritems;
static Size AttributeComponent_idr_objsz, AttributeComponent_idr_psize;

static StructClass *AttributeComponent_make(StructClass *AttributeComponent_class = 0, Schema *m = 0)
{
  if (!AttributeComponent_class)
    return new StructClass("attribute_component", (m ? m->getClass("struct") : Struct_Class));
  Attribute *attr[6];
  int *dims;

  dims = new int[1];
  dims[0] = -1;
  attr[2] = new Attribute((m ? m->getClass("char") : Char_Class), "name", False, 1, dims);
  delete[] dims;

  dims = new int[1];
  dims[0] = -1;
  attr[3] = new Attribute((m ? m->getClass("char") : Char_Class), "attrpath", False, 1, dims);
  delete[] dims;

  dims = 0;
  attr[4] = new Attribute((m ? m->getClass("class") : Class_Class), "class_owner", True, 0, dims);

  dims = 0;
  attr[5] = new Attribute((m ? m->getClass("bool") : Bool_Class), "propagate", False, 0, dims);

  AttributeComponent_class->setAttributes(&attr[2], 4);

  delete attr[2];
  delete attr[3];
  delete attr[4];
  delete attr[5];

  ClassPeer::setMType(AttributeComponent_class, Class::System);

  return AttributeComponent_class;
}

Object *AttributeComponent_construct_x(const Class *cls, Data idr)
{
  return new AttributeComponent(cls, idr);
}

Object *AttributeComponent_construct(const Object *o, Bool share)
{
  return new AttributeComponent((const Struct *)o, share);
}

static void AttributeComponent_init_p()
{
  AttributeComponent_Class = AttributeComponent_make();
  constructors_x[class_ind] = AttributeComponent_construct_x;
  constructors[class_ind] = AttributeComponent_construct;
  hash->insert("attribute_component", class_ind++);
}

static void AttributeComponent_init()
{
  AttributeComponent_make(AttributeComponent_Class);

  AttributeComponent_agritems = AttributeComponent_Class->getAttributes();
  AttributeComponent_idr_objsz = AttributeComponent_Class->getIDRObjectSize(&AttributeComponent_idr_psize, 0);

  ObjectPeer::setUnrealizable(AttributeComponent_Class, True);
}

static Status AttributeComponent_attrcomp_realize(Database *db, Class *cls)
{
  return Success;
}

AttributeComponent::AttributeComponent(Database *_db, const Dataspace *_dataspace) : Struct(_db, _dataspace)
{
  initialize(_db);
}

AttributeComponent::AttributeComponent(const Class *_cls, Data _idr)
{
  setClass((Class *)_cls);

  Size idr_psize;
  Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  ClassPeer::newObjRealize(getClass(), this);
  ObjectPeer::setGRTObject(this, True);
  userInitialize();
}

void AttributeComponent::initialize(Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("attribute_component") : AttributeComponent_Class));

  Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  ClassPeer::newObjRealize(getClass(), this);
  ObjectPeer::setGRTObject(this, True);
  userInitialize();
}

AttributeComponent::AttributeComponent(const AttributeComponent& x) : Struct(x)
{
  userCopy(x);
}

AttributeComponent& AttributeComponent::operator=(const AttributeComponent& x)
{
  *(Struct *)this = Struct::operator=((const Struct &)x);
  userCopy(x);
  return *this;
}

AttributeComponent::AttributeComponent(const Struct *x, Bool share) : Struct(x, share)
{
  setClass((db ? db->getSchema()->getClass("attribute_component") : AttributeComponent_Class));

  Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      ClassPeer::newObjRealize(getClass(), this);
    }

  ObjectPeer::setGRTObject(this, True);
  userCopy(*x);
}

AttributeComponent::AttributeComponent(const AttributeComponent *x, Bool share) : Struct(x, share)
{
  setClass((db ? db->getSchema()->getClass("attribute_component") : AttributeComponent_Class));

  Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      ClassPeer::newObjRealize(getClass(), this);
    }

  ObjectPeer::setGRTObject(this, True);
  userCopy(*x);
}

Status AttributeComponent::setName(const char *_name)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;
  Size size;
  Size len = ::strlen(_name) + 1;

  status = getClass()->getAttributes()[2]->getSize(this, size);
  if (status)
    return status;

  if (size != len)
    status = getClass()->getAttributes()[2]->setSize(this, len);
  if (status)
    return status;

  status = getClass()->getAttributes()[2]->setValue(this, (Data)_name, len, 0);
  return status;

}

Status AttributeComponent::setName(unsigned int a0, char _name)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;
  Size from = a0;

  Size size;
  status = getClass()->getAttributes()[2]->getSize(this, size);
  if (status)
    return status;

  if (size <= from)
    status = getClass()->getAttributes()[2]->setSize(this, from+1);
  if (status)
    return status;

  status = getClass()->getAttributes()[2]->setValue(this, (Data)&_name, 1, from);
  return status;
}

const char *AttributeComponent::getName(Bool *isnull, Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  Data data;
  Status s;

  s = getClass()->getAttributes()[2]->getValue(this, (Data *)&data, Attribute::directAccess, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  if (!data) data = nulldata;
  return (const char *)data;
}

char AttributeComponent::getName(unsigned int a0, Bool *isnull, Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  char __tmp = 0;
  Status s;
  Size from = a0;

  s = getClass()->getAttributes()[2]->getValue(this, (Data *)&__tmp, 1, from, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

Status AttributeComponent::setAttrpath(const char *_attrpath)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;
  Size size;
  Size len = ::strlen(_attrpath) + 1;

  status = getClass()->getAttributes()[3]->getSize(this, size);
  if (status)
    return status;

  if (size != len)
    status = getClass()->getAttributes()[3]->setSize(this, len);
  if (status)
    return status;

  status = getClass()->getAttributes()[3]->setValue(this, (Data)_attrpath, len, 0);
  return status;

}

Status AttributeComponent::setAttrpath(unsigned int a0, char _attrpath)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;
  Size from = a0;

  Size size;
  status = getClass()->getAttributes()[3]->getSize(this, size);
  if (status)
    return status;

  if (size <= from)
    status = getClass()->getAttributes()[3]->setSize(this, from+1);
  if (status)
    return status;

  status = getClass()->getAttributes()[3]->setValue(this, (Data)&_attrpath, 1, from);
  return status;
}

const char *AttributeComponent::getAttrpath(Bool *isnull, Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  Data data;
  Status s;

  s = getClass()->getAttributes()[3]->getValue(this, (Data *)&data, Attribute::directAccess, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  if (!data) data = nulldata;
  return (const char *)data;
}

char AttributeComponent::getAttrpath(unsigned int a0, Bool *isnull, Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  char __tmp = 0;
  Status s;
  Size from = a0;

  s = getClass()->getAttributes()[3]->getValue(this, (Data *)&__tmp, 1, from, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

Status AttributeComponent::setClassOwner(Class *_class_owner)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;

  status = getClass()->getAttributes()[4]->setValue(this, (Data)&_class_owner, 1, 0);
  return status;
}

const Class *AttributeComponent::getClassOwner(Bool *isnull, Status *rs) const 
{
  gbxAutoGarbSuspender _gbxsusp_;
  Object *__o = 0, *__go;
  Status s;

  s = getClass()->getAttributes()[4]->getValue(this, (Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (ObjectPeer::isGRTObject(__o)) {
       return (Class *)__o;
     }
     __go = (Class *)make_object(__o, False);
     if (__go)
      {
       __o = __go;
       s = getClass()->getAttributes()[4]->setValue((Agregat *)this, (Data)&__o, 1, 0);
       ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
     return (Class *)__o;
    }

  Bool wasnull = (!__o ? True : False);
  if (!__o && db)
    {
      Oid toid;
      s = getClass()->getAttributes()[4]->getOid(this, &toid, 1, 0);
      if (s) {if (rs) *rs = s; return 0;}
      if (toid.isValid())
        {
          s = db->loadObject(&toid, &__o);
          if (s) {if (rs) *rs = s; return 0;}
          if (!ObjectPeer::isGRTObject(__o))
           {
             __go = (Class *)make_object(__o, False);
             if (__go) __o = __go;
           }
        }
    }

  if (__o && wasnull)
    {
     s = getClass()->getAttributes()[4]->setValue((Agregat *)this, (Data)&__o, 1, 0);
     if (s) {if (rs) *rs = s; return 0;}
     __o->release();
    }
  return (Class *)__o;
}

Class *AttributeComponent::getClassOwner(Bool *isnull, Status *rs) 
{
  gbxAutoGarbSuspender _gbxsusp_;
  Object *__o = 0, *__go;
  Status s;

  s = getClass()->getAttributes()[4]->getValue(this, (Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (ObjectPeer::isGRTObject(__o)) {
       return (Class *)__o;
     }
     __go = (Class *)make_object(__o, False);
     if (__go)
      {
       __o = __go;
       s = getClass()->getAttributes()[4]->setValue((Agregat *)this, (Data)&__o, 1, 0);
       ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
     return (Class *)__o;
    }

  Bool wasnull = (!__o ? True : False);
  if (!__o && db)
    {
      Oid toid;
      s = getClass()->getAttributes()[4]->getOid(this, &toid, 1, 0);
      if (s) {if (rs) *rs = s; return 0;}
      if (toid.isValid())
        {
          s = db->loadObject(&toid, &__o);
          if (s) {if (rs) *rs = s; return 0;}
          if (!ObjectPeer::isGRTObject(__o))
           {
             __go = (Class *)make_object(__o, False);
             if (__go) __o = __go;
           }
        }
    }

  if (__o && wasnull)
    {
     s = getClass()->getAttributes()[4]->setValue((Agregat *)this, (Data)&__o, 1, 0);
     if (s) {if (rs) *rs = s; return 0;}
     __o->release();
    }
  return (Class *)__o;
}

Status AttributeComponent::setClassOwnerOid(const Oid &_oid)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;

  status = getClass()->getAttributes()[4]->setOid(this, &_oid, 1, 0, oid_check);
  return status;
}

Oid AttributeComponent::getClassOwnerOid(Status *rs) 
{
  gbxAutoGarbSuspender _gbxsusp_;
  Oid __tmp;
  Status s;

  s = getClass()->getAttributes()[4]->getOid(this, &__tmp, 1, 0);
  if (s) {if (rs) *rs = s; return nulloid;}

  return __tmp;
}

Status AttributeComponent::setPropagate(Bool _propagate, Bool _check_value)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;
  eyedblib::int32 __tmp = _propagate;

  status = getClass()->getAttributes()[5]->setValue(this, (Data)&__tmp, 1, 0, _check_value);
  return status;
}

Bool AttributeComponent::getPropagate(Bool *isnull, Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int32 __tmp = 0;
  Status s;

  s = getClass()->getAttributes()[5]->getValue(this, (Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return (Bool)0;}
  return (Bool)__tmp;
}

static const Attribute **AttributeComponentSet_agritems;
static Size AttributeComponentSet_idr_objsz, AttributeComponentSet_idr_psize;

static StructClass *AttributeComponentSet_make(StructClass *AttributeComponentSet_class = 0, Schema *m = 0)
{
  if (!AttributeComponentSet_class)
    return new StructClass("attribute_component_set", (m ? m->getClass("struct") : Struct_Class));
  Attribute *attr[5];
  int *dims;

  dims = new int[1];
  dims[0] = -1;
  attr[2] = new Attribute((m ? m->getClass("char") : Char_Class), "attrname", False, 1, dims);
  delete[] dims;

  dims = 0;
  attr[3] = new Attribute((m ? m->getClass("set<attribute_component*>") : set_class_AttributeComponent_ref_Class), "comps", False, 0, dims);

  dims = 0;
  attr[4] = new Attribute((m ? m->getClass("class") : Class_Class), "class_owner", True, 0, dims);

  AttributeComponentSet_class->setAttributes(&attr[2], 3);

  delete attr[2];
  delete attr[3];
  delete attr[4];

  ClassPeer::setMType(AttributeComponentSet_class, Class::System);

  return AttributeComponentSet_class;
}

Object *AttributeComponentSet_construct_x(const Class *cls, Data idr)
{
  return new AttributeComponentSet(cls, idr);
}

Object *AttributeComponentSet_construct(const Object *o, Bool share)
{
  return new AttributeComponentSet((const Struct *)o, share);
}

static void AttributeComponentSet_init_p()
{
  AttributeComponentSet_Class = AttributeComponentSet_make();
  constructors_x[class_ind] = AttributeComponentSet_construct_x;
  constructors[class_ind] = AttributeComponentSet_construct;
  hash->insert("attribute_component_set", class_ind++);
}

static void AttributeComponentSet_init()
{
  AttributeComponentSet_make(AttributeComponentSet_Class);

  AttributeComponentSet_agritems = AttributeComponentSet_Class->getAttributes();
  AttributeComponentSet_idr_objsz = AttributeComponentSet_Class->getIDRObjectSize(&AttributeComponentSet_idr_psize, 0);

  ObjectPeer::setUnrealizable(AttributeComponentSet_Class, True);
}

static Status AttributeComponentSet_attrcomp_realize(Database *db, Class *cls)
{
  return Success;
}

AttributeComponentSet::AttributeComponentSet(Database *_db, const Dataspace *_dataspace) : Struct(_db, _dataspace)
{
  initialize(_db);
}

AttributeComponentSet::AttributeComponentSet(const Class *_cls, Data _idr)
{
  setClass((Class *)_cls);

  Size idr_psize;
  Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  ClassPeer::newObjRealize(getClass(), this);
  ObjectPeer::setGRTObject(this, True);
  userInitialize();
}

void AttributeComponentSet::initialize(Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("attribute_component_set") : AttributeComponentSet_Class));

  Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  ClassPeer::newObjRealize(getClass(), this);
  ObjectPeer::setGRTObject(this, True);
  userInitialize();
}

AttributeComponentSet::AttributeComponentSet(const AttributeComponentSet& x) : Struct(x)
{
  userCopy(x);
}

AttributeComponentSet& AttributeComponentSet::operator=(const AttributeComponentSet& x)
{
  *(Struct *)this = Struct::operator=((const Struct &)x);
  userCopy(x);
  return *this;
}

AttributeComponentSet::AttributeComponentSet(const Struct *x, Bool share) : Struct(x, share)
{
  setClass((db ? db->getSchema()->getClass("attribute_component_set") : AttributeComponentSet_Class));

  Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      ClassPeer::newObjRealize(getClass(), this);
    }

  ObjectPeer::setGRTObject(this, True);
  userCopy(*x);
}

AttributeComponentSet::AttributeComponentSet(const AttributeComponentSet *x, Bool share) : Struct(x, share)
{
  setClass((db ? db->getSchema()->getClass("attribute_component_set") : AttributeComponentSet_Class));

  Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      ClassPeer::newObjRealize(getClass(), this);
    }

  ObjectPeer::setGRTObject(this, True);
  userCopy(*x);
}

Status AttributeComponentSet::setAttrname(const char *_attrname)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;
  Size size;
  Size len = ::strlen(_attrname) + 1;

  status = getClass()->getAttributes()[2]->getSize(this, size);
  if (status)
    return status;

  if (size != len)
    status = getClass()->getAttributes()[2]->setSize(this, len);
  if (status)
    return status;

  status = getClass()->getAttributes()[2]->setValue(this, (Data)_attrname, len, 0);
  return status;

}

Status AttributeComponentSet::setAttrname(unsigned int a0, char _attrname)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;
  Size from = a0;

  Size size;
  status = getClass()->getAttributes()[2]->getSize(this, size);
  if (status)
    return status;

  if (size <= from)
    status = getClass()->getAttributes()[2]->setSize(this, from+1);
  if (status)
    return status;

  status = getClass()->getAttributes()[2]->setValue(this, (Data)&_attrname, 1, from);
  return status;
}

const char *AttributeComponentSet::getAttrname(Bool *isnull, Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  Data data;
  Status s;

  s = getClass()->getAttributes()[2]->getValue(this, (Data *)&data, Attribute::directAccess, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  if (!data) data = nulldata;
  return (const char *)data;
}

char AttributeComponentSet::getAttrname(unsigned int a0, Bool *isnull, Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  char __tmp = 0;
  Status s;
  Size from = a0;

  s = getClass()->getAttributes()[2]->getValue(this, (Data *)&__tmp, 1, from, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

Status AttributeComponentSet::setCompsColl(CollSet *_comps)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;

  status = getClass()->getAttributes()[3]->setValue(this, (Data)&_comps, 1, 0);
  return status;
}

const CollSet *AttributeComponentSet::getCompsColl(Bool *isnull, Status *rs) const 
{
  gbxAutoGarbSuspender _gbxsusp_;
  Object *__o = 0, *__go;
  Status s;

  s = getClass()->getAttributes()[3]->getValue(this, (Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return (CollSet *)__o;
}

CollSet *AttributeComponentSet::getCompsColl(Bool *isnull, Status *rs) 
{
  gbxAutoGarbSuspender _gbxsusp_;
  Object *__o = 0, *__go;
  Status s;

  s = getClass()->getAttributes()[3]->getValue(this, (Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return (CollSet *)__o;
}

Status AttributeComponentSet::addToCompsColl(AttributeComponent *_comps, Bool noDup, const IndexImpl *idximpl)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;
  CollSet *_coll;
  Bool _not_set = False;
  Size from = 0;

  status = getClass()->getAttributes()[3]->getValue(this, (Data *)&_coll, 1, from);
  if (status)
    return status;

  if (!_coll)
    {
     _not_set = True;
     Oid _coll_oid;
     status = getClass()->getAttributes()[3]->getOid(this, &_coll_oid, 1, from);
     if (status)
      return status;

     if (_coll_oid.isValid())
       {
       status = db->loadObject(&_coll_oid, (Object **)&_coll);
       if (status)
        return status;
       }
     else
       {
         _coll = new CollSet(db, "", db->getSchema()->getClass("attribute_component"), True, idximpl);
       }
    }

  status = _coll->insert(_comps, noDup);
  if (status || !_not_set)
    return status;


  status = getClass()->getAttributes()[3]->setValue(this, (Data)&_coll, 1, from);
     _coll->release();

  return status;
}

Status AttributeComponentSet::addToCompsColl(const Oid &_oid, const IndexImpl *idximpl)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;
  CollSet *_coll;
  Bool _not_set = False;
  Size from = 0;

  status = getClass()->getAttributes()[3]->getValue(this, (Data *)&_coll, 1, from);
  if (status)
    return status;

  if (!_coll)
    {
     _not_set = True;
     Oid _coll_oid;
     status = getClass()->getAttributes()[3]->getOid(this, &_coll_oid, 1, from);
     if (status)
      return status;

     if (_coll_oid.isValid())
       {
       status = db->loadObject(&_coll_oid, (Object **)&_coll);
       if (status)
        return status;
       }
     else
       {
         _coll = new CollSet(db, "", db->getSchema()->getClass("attribute_component"), True, idximpl);
       }
    }

  status = _coll->insert(_oid);
  if (status || !_not_set)
    return status;


  status = getClass()->getAttributes()[3]->setValue(this, (Data)&_coll, 1, from);
     _coll->release();

  return status;
}

Status AttributeComponentSet::rmvFromCompsColl(AttributeComponent *_comps, Bool checkFirst)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;
  CollSet *_coll;
  Bool _not_set = False;
  Size from = 0;

  status = getClass()->getAttributes()[3]->getValue(this, (Data *)&_coll, 1, from);
  if (status)
    return status;

  if (!_coll)
    {
     _not_set = True;
     Oid _coll_oid;
     status = getClass()->getAttributes()[3]->getOid(this, &_coll_oid, 1, from);
     if (status)
      return status;

     if (_coll_oid.isValid())
       {
       status = db->loadObject(&_coll_oid, (Object **)&_coll);
       if (status)
        return status;
       }
     else
        return Exception::make(IDB_ERROR, "no valid collection in attribute AttributeComponentSet::comps");

    }

  status = _coll->suppress(_comps, checkFirst);
  if (status || !_not_set)
    return status;


  status = getClass()->getAttributes()[3]->setValue(this, (Data)&_coll, 1, from);
     _coll->release();

  return status;
}

Status AttributeComponentSet::rmvFromCompsColl(const Oid &_oid)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;
  CollSet *_coll;
  Bool _not_set = False;
  Size from = 0;

  status = getClass()->getAttributes()[3]->getValue(this, (Data *)&_coll, 1, from);
  if (status)
    return status;

  if (!_coll)
    {
     _not_set = True;
     Oid _coll_oid;
     status = getClass()->getAttributes()[3]->getOid(this, &_coll_oid, 1, from);
     if (status)
      return status;

     if (_coll_oid.isValid())
       {
       status = db->loadObject(&_coll_oid, (Object **)&_coll);
       if (status)
        return status;
       }
     else
        return Exception::make(IDB_ERROR, "no valid collection in attribute AttributeComponentSet::comps");

    }

  status = _coll->suppress(_oid);
  if (status || !_not_set)
    return status;


  status = getClass()->getAttributes()[3]->setValue(this, (Data)&_coll, 1, from);
     _coll->release();

  return status;
}

Status AttributeComponentSet::setClassOwner(Class *_class_owner)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;

  status = getClass()->getAttributes()[4]->setValue(this, (Data)&_class_owner, 1, 0);
  return status;
}

const Class *AttributeComponentSet::getClassOwner(Bool *isnull, Status *rs) const 
{
  gbxAutoGarbSuspender _gbxsusp_;
  Object *__o = 0, *__go;
  Status s;

  s = getClass()->getAttributes()[4]->getValue(this, (Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (ObjectPeer::isGRTObject(__o)) {
       return (Class *)__o;
     }
     __go = (Class *)make_object(__o, False);
     if (__go)
      {
       __o = __go;
       s = getClass()->getAttributes()[4]->setValue((Agregat *)this, (Data)&__o, 1, 0);
       ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
     return (Class *)__o;
    }

  Bool wasnull = (!__o ? True : False);
  if (!__o && db)
    {
      Oid toid;
      s = getClass()->getAttributes()[4]->getOid(this, &toid, 1, 0);
      if (s) {if (rs) *rs = s; return 0;}
      if (toid.isValid())
        {
          s = db->loadObject(&toid, &__o);
          if (s) {if (rs) *rs = s; return 0;}
          if (!ObjectPeer::isGRTObject(__o))
           {
             __go = (Class *)make_object(__o, False);
             if (__go) __o = __go;
           }
        }
    }

  if (__o && wasnull)
    {
     s = getClass()->getAttributes()[4]->setValue((Agregat *)this, (Data)&__o, 1, 0);
     if (s) {if (rs) *rs = s; return 0;}
     __o->release();
    }
  return (Class *)__o;
}

Class *AttributeComponentSet::getClassOwner(Bool *isnull, Status *rs) 
{
  gbxAutoGarbSuspender _gbxsusp_;
  Object *__o = 0, *__go;
  Status s;

  s = getClass()->getAttributes()[4]->getValue(this, (Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (ObjectPeer::isGRTObject(__o)) {
       return (Class *)__o;
     }
     __go = (Class *)make_object(__o, False);
     if (__go)
      {
       __o = __go;
       s = getClass()->getAttributes()[4]->setValue((Agregat *)this, (Data)&__o, 1, 0);
       ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
     return (Class *)__o;
    }

  Bool wasnull = (!__o ? True : False);
  if (!__o && db)
    {
      Oid toid;
      s = getClass()->getAttributes()[4]->getOid(this, &toid, 1, 0);
      if (s) {if (rs) *rs = s; return 0;}
      if (toid.isValid())
        {
          s = db->loadObject(&toid, &__o);
          if (s) {if (rs) *rs = s; return 0;}
          if (!ObjectPeer::isGRTObject(__o))
           {
             __go = (Class *)make_object(__o, False);
             if (__go) __o = __go;
           }
        }
    }

  if (__o && wasnull)
    {
     s = getClass()->getAttributes()[4]->setValue((Agregat *)this, (Data)&__o, 1, 0);
     if (s) {if (rs) *rs = s; return 0;}
     __o->release();
    }
  return (Class *)__o;
}

Status AttributeComponentSet::setClassOwnerOid(const Oid &_oid)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;

  status = getClass()->getAttributes()[4]->setOid(this, &_oid, 1, 0, oid_check);
  return status;
}

Oid AttributeComponentSet::getClassOwnerOid(Status *rs) 
{
  gbxAutoGarbSuspender _gbxsusp_;
  Oid __tmp;
  Status s;

  s = getClass()->getAttributes()[4]->getOid(this, &__tmp, 1, 0);
  if (s) {if (rs) *rs = s; return nulloid;}

  return __tmp;
}

static const Attribute **ClassComponent_agritems;
static Size ClassComponent_idr_objsz, ClassComponent_idr_psize;

static StructClass *ClassComponent_make(StructClass *ClassComponent_class = 0, Schema *m = 0)
{
  if (!ClassComponent_class)
    return new StructClass("class_component", (m ? m->getClass("struct") : Struct_Class));
  Attribute *attr[4];
  int *dims;

  dims = 0;
  attr[2] = new Attribute((m ? m->getClass("class") : Class_Class), "class_owner", True, 0, dims);

  dims = new int[1];
  dims[0] = -1;
  attr[3] = new Attribute((m ? m->getClass("char") : Char_Class), "name", False, 1, dims);
  delete[] dims;

  ClassComponent_class->setAttributes(&attr[2], 2);

  delete attr[2];
  delete attr[3];

  ClassPeer::setMType(ClassComponent_class, Class::System);

  return ClassComponent_class;
}

Object *ClassComponent_construct_x(const Class *cls, Data idr)
{
  return new ClassComponent(cls, idr);
}

Object *ClassComponent_construct(const Object *o, Bool share)
{
  return new ClassComponent((const Struct *)o, share);
}

static void ClassComponent_init_p()
{
  ClassComponent_Class = ClassComponent_make();
  constructors_x[class_ind] = ClassComponent_construct_x;
  constructors[class_ind] = ClassComponent_construct;
  hash->insert("class_component", class_ind++);
}

static void ClassComponent_init()
{
  ClassComponent_make(ClassComponent_Class);

  ClassComponent_agritems = ClassComponent_Class->getAttributes();
  ClassComponent_idr_objsz = ClassComponent_Class->getIDRObjectSize(&ClassComponent_idr_psize, 0);

  ObjectPeer::setUnrealizable(ClassComponent_Class, True);
}

static Status ClassComponent_attrcomp_realize(Database *db, Class *cls)
{
  return Success;
}

ClassComponent::ClassComponent(Database *_db, const Dataspace *_dataspace) : Struct(_db, _dataspace)
{
  initialize(_db);
}

ClassComponent::ClassComponent(const Class *_cls, Data _idr)
{
  setClass((Class *)_cls);

  Size idr_psize;
  Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  ClassPeer::newObjRealize(getClass(), this);
  ObjectPeer::setGRTObject(this, True);
  userInitialize();
}

void ClassComponent::initialize(Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("class_component") : ClassComponent_Class));

  Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  ClassPeer::newObjRealize(getClass(), this);
  ObjectPeer::setGRTObject(this, True);
  userInitialize();
}

ClassComponent::ClassComponent(const ClassComponent& x) : Struct(x)
{
  userCopy(x);
}

ClassComponent& ClassComponent::operator=(const ClassComponent& x)
{
  *(Struct *)this = Struct::operator=((const Struct &)x);
  userCopy(x);
  return *this;
}

ClassComponent::ClassComponent(const Struct *x, Bool share) : Struct(x, share)
{
  setClass((db ? db->getSchema()->getClass("class_component") : ClassComponent_Class));

  Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      ClassPeer::newObjRealize(getClass(), this);
    }

  ObjectPeer::setGRTObject(this, True);
  userCopy(*x);
}

ClassComponent::ClassComponent(const ClassComponent *x, Bool share) : Struct(x, share)
{
  setClass((db ? db->getSchema()->getClass("class_component") : ClassComponent_Class));

  Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      ClassPeer::newObjRealize(getClass(), this);
    }

  ObjectPeer::setGRTObject(this, True);
  userCopy(*x);
}

Status ClassComponent::setClassOwner(Class *_class_owner)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;

  status = getClass()->getAttributes()[2]->setValue(this, (Data)&_class_owner, 1, 0);
  return status;
}

const Class *ClassComponent::getClassOwner(Bool *isnull, Status *rs) const 
{
  gbxAutoGarbSuspender _gbxsusp_;
  Object *__o = 0, *__go;
  Status s;

  s = getClass()->getAttributes()[2]->getValue(this, (Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (ObjectPeer::isGRTObject(__o)) {
       return (Class *)__o;
     }
     __go = (Class *)make_object(__o, False);
     if (__go)
      {
       __o = __go;
       s = getClass()->getAttributes()[2]->setValue((Agregat *)this, (Data)&__o, 1, 0);
       ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
     return (Class *)__o;
    }

  Bool wasnull = (!__o ? True : False);
  if (!__o && db)
    {
      Oid toid;
      s = getClass()->getAttributes()[2]->getOid(this, &toid, 1, 0);
      if (s) {if (rs) *rs = s; return 0;}
      if (toid.isValid())
        {
          s = db->loadObject(&toid, &__o);
          if (s) {if (rs) *rs = s; return 0;}
          if (!ObjectPeer::isGRTObject(__o))
           {
             __go = (Class *)make_object(__o, False);
             if (__go) __o = __go;
           }
        }
    }

  if (__o && wasnull)
    {
     s = getClass()->getAttributes()[2]->setValue((Agregat *)this, (Data)&__o, 1, 0);
     if (s) {if (rs) *rs = s; return 0;}
     __o->release();
    }
  return (Class *)__o;
}

Class *ClassComponent::getClassOwner(Bool *isnull, Status *rs) 
{
  gbxAutoGarbSuspender _gbxsusp_;
  Object *__o = 0, *__go;
  Status s;

  s = getClass()->getAttributes()[2]->getValue(this, (Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (ObjectPeer::isGRTObject(__o)) {
       return (Class *)__o;
     }
     __go = (Class *)make_object(__o, False);
     if (__go)
      {
       __o = __go;
       s = getClass()->getAttributes()[2]->setValue((Agregat *)this, (Data)&__o, 1, 0);
       ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
     return (Class *)__o;
    }

  Bool wasnull = (!__o ? True : False);
  if (!__o && db)
    {
      Oid toid;
      s = getClass()->getAttributes()[2]->getOid(this, &toid, 1, 0);
      if (s) {if (rs) *rs = s; return 0;}
      if (toid.isValid())
        {
          s = db->loadObject(&toid, &__o);
          if (s) {if (rs) *rs = s; return 0;}
          if (!ObjectPeer::isGRTObject(__o))
           {
             __go = (Class *)make_object(__o, False);
             if (__go) __o = __go;
           }
        }
    }

  if (__o && wasnull)
    {
     s = getClass()->getAttributes()[2]->setValue((Agregat *)this, (Data)&__o, 1, 0);
     if (s) {if (rs) *rs = s; return 0;}
     __o->release();
    }
  return (Class *)__o;
}

Status ClassComponent::setClassOwnerOid(const Oid &_oid)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;

  status = getClass()->getAttributes()[2]->setOid(this, &_oid, 1, 0, oid_check);
  return status;
}

Oid ClassComponent::getClassOwnerOid(Status *rs) 
{
  gbxAutoGarbSuspender _gbxsusp_;
  Oid __tmp;
  Status s;

  s = getClass()->getAttributes()[2]->getOid(this, &__tmp, 1, 0);
  if (s) {if (rs) *rs = s; return nulloid;}

  return __tmp;
}

Status ClassComponent::setName(const char *_name)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;
  Size size;
  Size len = ::strlen(_name) + 1;

  status = getClass()->getAttributes()[3]->getSize(this, size);
  if (status)
    return status;

  if (size != len)
    status = getClass()->getAttributes()[3]->setSize(this, len);
  if (status)
    return status;

  status = getClass()->getAttributes()[3]->setValue(this, (Data)_name, len, 0);
  return status;

}

Status ClassComponent::setName(unsigned int a0, char _name)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;
  Size from = a0;

  Size size;
  status = getClass()->getAttributes()[3]->getSize(this, size);
  if (status)
    return status;

  if (size <= from)
    status = getClass()->getAttributes()[3]->setSize(this, from+1);
  if (status)
    return status;

  status = getClass()->getAttributes()[3]->setValue(this, (Data)&_name, 1, from);
  return status;
}

const char *ClassComponent::getName(Bool *isnull, Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  Data data;
  Status s;

  s = getClass()->getAttributes()[3]->getValue(this, (Data *)&data, Attribute::directAccess, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  if (!data) data = nulldata;
  return (const char *)data;
}

char ClassComponent::getName(unsigned int a0, Bool *isnull, Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  char __tmp = 0;
  Status s;
  Size from = a0;

  s = getClass()->getAttributes()[3]->getValue(this, (Data *)&__tmp, 1, from, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

static const Attribute **AgregatClassComponent_agritems;
static Size AgregatClassComponent_idr_objsz, AgregatClassComponent_idr_psize;

static StructClass *AgregatClassComponent_make(StructClass *AgregatClassComponent_class = 0, Schema *m = 0)
{
  if (!AgregatClassComponent_class)
    return new StructClass("agregat_class_component", (m ? m->getClass("class_component") : ClassComponent_Class));
  Attribute *attr[4];

  AgregatClassComponent_class->setAttributes(&attr[4], 0);


  ClassPeer::setMType(AgregatClassComponent_class, Class::System);

  return AgregatClassComponent_class;
}

Object *AgregatClassComponent_construct_x(const Class *cls, Data idr)
{
  return new AgregatClassComponent(cls, idr);
}

Object *AgregatClassComponent_construct(const Object *o, Bool share)
{
  return new AgregatClassComponent((const Struct *)o, share);
}

static void AgregatClassComponent_init_p()
{
  AgregatClassComponent_Class = AgregatClassComponent_make();
  constructors_x[class_ind] = AgregatClassComponent_construct_x;
  constructors[class_ind] = AgregatClassComponent_construct;
  hash->insert("agregat_class_component", class_ind++);
}

static void AgregatClassComponent_init()
{
  AgregatClassComponent_make(AgregatClassComponent_Class);

  AgregatClassComponent_agritems = AgregatClassComponent_Class->getAttributes();
  AgregatClassComponent_idr_objsz = AgregatClassComponent_Class->getIDRObjectSize(&AgregatClassComponent_idr_psize, 0);

  ObjectPeer::setUnrealizable(AgregatClassComponent_Class, True);
}

static Status AgregatClassComponent_attrcomp_realize(Database *db, Class *cls)
{
  return Success;
}

AgregatClassComponent::AgregatClassComponent(Database *_db, const Dataspace *_dataspace) : ClassComponent(_db, _dataspace, 1)
{
  initialize(_db);
}

AgregatClassComponent::AgregatClassComponent(const Class *_cls, Data _idr): ClassComponent((Database *)0, (const Dataspace *)0, 1)
{
  setClass((Class *)_cls);

  Size idr_psize;
  Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  ClassPeer::newObjRealize(getClass(), this);
  ObjectPeer::setGRTObject(this, True);
  userInitialize();
}

void AgregatClassComponent::initialize(Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("agregat_class_component") : AgregatClassComponent_Class));

  Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  ClassPeer::newObjRealize(getClass(), this);
  ObjectPeer::setGRTObject(this, True);
  userInitialize();
}

AgregatClassComponent::AgregatClassComponent(const AgregatClassComponent& x) : ClassComponent(x)
{
  userCopy(x);
}

AgregatClassComponent& AgregatClassComponent::operator=(const AgregatClassComponent& x)
{
  *(ClassComponent *)this = ClassComponent::operator=((const ClassComponent &)x);
  userCopy(x);
  return *this;
}

AgregatClassComponent::AgregatClassComponent(const Struct *x, Bool share) : ClassComponent(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("agregat_class_component") : AgregatClassComponent_Class));

  Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      ClassPeer::newObjRealize(getClass(), this);
    }

  ObjectPeer::setGRTObject(this, True);
  userCopy(*x);
}

AgregatClassComponent::AgregatClassComponent(const AgregatClassComponent *x, Bool share) : ClassComponent(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("agregat_class_component") : AgregatClassComponent_Class));

  Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      ClassPeer::newObjRealize(getClass(), this);
    }

  ObjectPeer::setGRTObject(this, True);
  userCopy(*x);
}

static const Attribute **ClassVariable_agritems;
static Size ClassVariable_idr_objsz, ClassVariable_idr_psize;

static StructClass *ClassVariable_make(StructClass *ClassVariable_class = 0, Schema *m = 0)
{
  if (!ClassVariable_class)
    return new StructClass("class_variable", (m ? m->getClass("class_component") : ClassComponent_Class));
  Attribute *attr[6];
  int *dims;

  dims = new int[1];
  dims[0] = -1;
  attr[4] = new Attribute((m ? m->getClass("char") : Char_Class), "vname", False, 1, dims);
  delete[] dims;

  dims = 0;
  attr[5] = new Attribute((m ? m->getClass("object") : Object_Class), "val", True, 0, dims);

  ClassVariable_class->setAttributes(&attr[4], 2);

  delete attr[4];
  delete attr[5];

  ClassPeer::setMType(ClassVariable_class, Class::System);

  return ClassVariable_class;
}

Object *ClassVariable_construct_x(const Class *cls, Data idr)
{
  return new ClassVariable(cls, idr);
}

Object *ClassVariable_construct(const Object *o, Bool share)
{
  return new ClassVariable((const Struct *)o, share);
}

static void ClassVariable_init_p()
{
  ClassVariable_Class = ClassVariable_make();
  constructors_x[class_ind] = ClassVariable_construct_x;
  constructors[class_ind] = ClassVariable_construct;
  hash->insert("class_variable", class_ind++);
}

static void ClassVariable_init()
{
  ClassVariable_make(ClassVariable_Class);

  ClassVariable_agritems = ClassVariable_Class->getAttributes();
  ClassVariable_idr_objsz = ClassVariable_Class->getIDRObjectSize(&ClassVariable_idr_psize, 0);

  ObjectPeer::setUnrealizable(ClassVariable_Class, True);
}

static Status ClassVariable_attrcomp_realize(Database *db, Class *cls)
{
  return Success;
}

ClassVariable::ClassVariable(Database *_db, const Dataspace *_dataspace) : ClassComponent(_db, _dataspace, 1)
{
  initialize(_db);
}

ClassVariable::ClassVariable(const Class *_cls, Data _idr): ClassComponent((Database *)0, (const Dataspace *)0, 1)
{
  setClass((Class *)_cls);

  Size idr_psize;
  Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  ClassPeer::newObjRealize(getClass(), this);
  ObjectPeer::setGRTObject(this, True);
  userInitialize();
}

void ClassVariable::initialize(Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("class_variable") : ClassVariable_Class));

  Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  ClassPeer::newObjRealize(getClass(), this);
  ObjectPeer::setGRTObject(this, True);
  userInitialize();
}

ClassVariable::ClassVariable(const ClassVariable& x) : ClassComponent(x)
{
  userCopy(x);
}

ClassVariable& ClassVariable::operator=(const ClassVariable& x)
{
  *(ClassComponent *)this = ClassComponent::operator=((const ClassComponent &)x);
  userCopy(x);
  return *this;
}

ClassVariable::ClassVariable(const Struct *x, Bool share) : ClassComponent(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("class_variable") : ClassVariable_Class));

  Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      ClassPeer::newObjRealize(getClass(), this);
    }

  ObjectPeer::setGRTObject(this, True);
  userCopy(*x);
}

ClassVariable::ClassVariable(const ClassVariable *x, Bool share) : ClassComponent(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("class_variable") : ClassVariable_Class));

  Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      ClassPeer::newObjRealize(getClass(), this);
    }

  ObjectPeer::setGRTObject(this, True);
  userCopy(*x);
}

Status ClassVariable::setVname(const char *_vname)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;
  Size size;
  Size len = ::strlen(_vname) + 1;

  status = getClass()->getAttributes()[4]->getSize(this, size);
  if (status)
    return status;

  if (size != len)
    status = getClass()->getAttributes()[4]->setSize(this, len);
  if (status)
    return status;

  status = getClass()->getAttributes()[4]->setValue(this, (Data)_vname, len, 0);
  return status;

}

Status ClassVariable::setVname(unsigned int a0, char _vname)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;
  Size from = a0;

  Size size;
  status = getClass()->getAttributes()[4]->getSize(this, size);
  if (status)
    return status;

  if (size <= from)
    status = getClass()->getAttributes()[4]->setSize(this, from+1);
  if (status)
    return status;

  status = getClass()->getAttributes()[4]->setValue(this, (Data)&_vname, 1, from);
  return status;
}

const char *ClassVariable::getVname(Bool *isnull, Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  Data data;
  Status s;

  s = getClass()->getAttributes()[4]->getValue(this, (Data *)&data, Attribute::directAccess, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  if (!data) data = nulldata;
  return (const char *)data;
}

char ClassVariable::getVname(unsigned int a0, Bool *isnull, Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  char __tmp = 0;
  Status s;
  Size from = a0;

  s = getClass()->getAttributes()[4]->getValue(this, (Data *)&__tmp, 1, from, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

Status ClassVariable::setVal(Object *_val)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;

  status = getClass()->getAttributes()[5]->setValue(this, (Data)&_val, 1, 0);
  return status;
}

const Object *ClassVariable::getVal(Bool *isnull, Status *rs) const 
{
  gbxAutoGarbSuspender _gbxsusp_;
  Object *__o = 0, *__go;
  Status s;

  s = getClass()->getAttributes()[5]->getValue(this, (Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (ObjectPeer::isGRTObject(__o)) {
       return (Object *)__o;
     }
     __go = (Object *)make_object(__o, False);
     if (__go)
      {
       __o = __go;
       s = getClass()->getAttributes()[5]->setValue((Agregat *)this, (Data)&__o, 1, 0);
       ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
     return (Object *)__o;
    }

  Bool wasnull = (!__o ? True : False);
  if (!__o && db)
    {
      Oid toid;
      s = getClass()->getAttributes()[5]->getOid(this, &toid, 1, 0);
      if (s) {if (rs) *rs = s; return 0;}
      if (toid.isValid())
        {
          s = db->loadObject(&toid, &__o);
          if (s) {if (rs) *rs = s; return 0;}
          if (!ObjectPeer::isGRTObject(__o))
           {
             __go = (Object *)make_object(__o, False);
             if (__go) __o = __go;
           }
        }
    }

  if (__o && wasnull)
    {
     s = getClass()->getAttributes()[5]->setValue((Agregat *)this, (Data)&__o, 1, 0);
     if (s) {if (rs) *rs = s; return 0;}
     __o->release();
    }
  return (Object *)__o;
}

Object *ClassVariable::getVal(Bool *isnull, Status *rs) 
{
  gbxAutoGarbSuspender _gbxsusp_;
  Object *__o = 0, *__go;
  Status s;

  s = getClass()->getAttributes()[5]->getValue(this, (Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (ObjectPeer::isGRTObject(__o)) {
       return (Object *)__o;
     }
     __go = (Object *)make_object(__o, False);
     if (__go)
      {
       __o = __go;
       s = getClass()->getAttributes()[5]->setValue((Agregat *)this, (Data)&__o, 1, 0);
       ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
     return (Object *)__o;
    }

  Bool wasnull = (!__o ? True : False);
  if (!__o && db)
    {
      Oid toid;
      s = getClass()->getAttributes()[5]->getOid(this, &toid, 1, 0);
      if (s) {if (rs) *rs = s; return 0;}
      if (toid.isValid())
        {
          s = db->loadObject(&toid, &__o);
          if (s) {if (rs) *rs = s; return 0;}
          if (!ObjectPeer::isGRTObject(__o))
           {
             __go = (Object *)make_object(__o, False);
             if (__go) __o = __go;
           }
        }
    }

  if (__o && wasnull)
    {
     s = getClass()->getAttributes()[5]->setValue((Agregat *)this, (Data)&__o, 1, 0);
     if (s) {if (rs) *rs = s; return 0;}
     __o->release();
    }
  return (Object *)__o;
}

Status ClassVariable::setValOid(const Oid &_oid)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;

  status = getClass()->getAttributes()[5]->setOid(this, &_oid, 1, 0, oid_check);
  return status;
}

Oid ClassVariable::getValOid(Status *rs) 
{
  gbxAutoGarbSuspender _gbxsusp_;
  Oid __tmp;
  Status s;

  s = getClass()->getAttributes()[5]->getOid(this, &__tmp, 1, 0);
  if (s) {if (rs) *rs = s; return nulloid;}

  return __tmp;
}

static const Attribute **Index_agritems;
static Size Index_idr_objsz, Index_idr_psize;

static StructClass *Index_make(StructClass *Index_class = 0, Schema *m = 0)
{
  if (!Index_class)
    return new StructClass("index", (m ? m->getClass("attribute_component") : AttributeComponent_Class));
  Attribute *attr[10];
  int *dims;

  dims = 0;
  attr[6] = new Attribute((m ? m->getClass("oid") : OidP_Class), "idx_oid", False, 0, dims);

  dims = 0;
  attr[7] = new Attribute((m ? m->getClass("short") : Int16_Class), "dspid", False, 0, dims);

  dims = 0;
  attr[8] = new Attribute((m ? m->getClass("bool") : Bool_Class), "is_string", False, 0, dims);

  dims = new int[1];
  dims[0] = -1;
  attr[9] = new Attribute((m ? m->getClass("int") : Int32_Class), "impl_hints", False, 1, dims);
  delete[] dims;

  Index_class->setAttributes(&attr[6], 4);

  delete attr[6];
  delete attr[7];
  delete attr[8];
  delete attr[9];

  ClassPeer::setMType(Index_class, Class::System);

  return Index_class;
}

Object *Index_construct_x(const Class *cls, Data idr)
{
  return new Index(cls, idr);
}

Object *Index_construct(const Object *o, Bool share)
{
  return new Index((const Struct *)o, share);
}

static void Index_init_p()
{
  Index_Class = Index_make();
  constructors_x[class_ind] = Index_construct_x;
  constructors[class_ind] = Index_construct;
  hash->insert("index", class_ind++);
}

static void Index_init()
{
  Index_make(Index_Class);

  Index_agritems = Index_Class->getAttributes();
  Index_idr_objsz = Index_Class->getIDRObjectSize(&Index_idr_psize, 0);

  ObjectPeer::setUnrealizable(Index_Class, True);
}

static Status Index_attrcomp_realize(Database *db, Class *cls)
{
  return Success;
}

Index::Index(Database *_db, const Dataspace *_dataspace) : AttributeComponent(_db, _dataspace, 1)
{
  initialize(_db);
}

Index::Index(const Class *_cls, Data _idr): AttributeComponent((Database *)0, (const Dataspace *)0, 1)
{
  setClass((Class *)_cls);

  Size idr_psize;
  Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  ClassPeer::newObjRealize(getClass(), this);
  ObjectPeer::setGRTObject(this, True);
  userInitialize();
}

void Index::initialize(Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("index") : Index_Class));

  Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  ClassPeer::newObjRealize(getClass(), this);
  ObjectPeer::setGRTObject(this, True);
  userInitialize();
}

Index::Index(const Index& x) : AttributeComponent(x)
{
  userCopy(x);
}

Index& Index::operator=(const Index& x)
{
  *(AttributeComponent *)this = AttributeComponent::operator=((const AttributeComponent &)x);
  userCopy(x);
  return *this;
}

Index::Index(const Struct *x, Bool share) : AttributeComponent(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("index") : Index_Class));

  Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      ClassPeer::newObjRealize(getClass(), this);
    }

  ObjectPeer::setGRTObject(this, True);
  userCopy(*x);
}

Index::Index(const Index *x, Bool share) : AttributeComponent(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("index") : Index_Class));

  Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      ClassPeer::newObjRealize(getClass(), this);
    }

  ObjectPeer::setGRTObject(this, True);
  userCopy(*x);
}

Status Index::setIdxOid(Oid _idx_oid)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;

  status = getClass()->getAttributes()[6]->setValue(this, (Data)&_idx_oid, 1, 0);
  return status;
}

Oid Index::getIdxOid(Bool *isnull, Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  Oid __tmp;
  Status s;

  s = getClass()->getAttributes()[6]->getValue(this, (Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return nulloid;}

  return __tmp;
}

Status Index::setDspid(eyedblib::int16 _dspid)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;

  status = getClass()->getAttributes()[7]->setValue(this, (Data)&_dspid, 1, 0);
  return status;
}

eyedblib::int16 Index::getDspid(Bool *isnull, Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int16 __tmp = 0;
  Status s;

  s = getClass()->getAttributes()[7]->getValue(this, (Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

Status Index::setIsString(Bool _is_string, Bool _check_value)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;
  eyedblib::int32 __tmp = _is_string;

  status = getClass()->getAttributes()[8]->setValue(this, (Data)&__tmp, 1, 0, _check_value);
  return status;
}

Bool Index::getIsString(Bool *isnull, Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int32 __tmp = 0;
  Status s;

  s = getClass()->getAttributes()[8]->getValue(this, (Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return (Bool)0;}
  return (Bool)__tmp;
}

Status Index::setImplHints(unsigned int a0, eyedblib::int32 _impl_hints)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;
  Size from = a0;

  Size size;
  status = getClass()->getAttributes()[9]->getSize(this, size);
  if (status)
    return status;

  if (size <= from)
    status = getClass()->getAttributes()[9]->setSize(this, from+1);
  if (status)
    return status;

  status = getClass()->getAttributes()[9]->setValue(this, (Data)&_impl_hints, 1, from);
  return status;
}

Status Index::setImplHintsCount(unsigned int a0)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;
  Size from = a0;
  status = getClass()->getAttributes()[9]->setSize(this, from);
  return status;
}

eyedblib::int32 Index::getImplHints(unsigned int a0, Bool *isnull, Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int32 __tmp = 0;
  Status s;
  Size from = a0;

  s = getClass()->getAttributes()[9]->getValue(this, (Data *)&__tmp, 1, from, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

unsigned int Index::getImplHintsCount(Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  Size size;
  Status s;
  s = getClass()->getAttributes()[9]->getSize(this, size);
  if (s) {if (rs) *rs = s; return 0;}
  return (int)size;
}

static const Attribute **HashIndex_agritems;
static Size HashIndex_idr_objsz, HashIndex_idr_psize;

static StructClass *HashIndex_make(StructClass *HashIndex_class = 0, Schema *m = 0)
{
  if (!HashIndex_class)
    return new StructClass("hashindex", (m ? m->getClass("index") : Index_Class));
  Attribute *attr[12];
  int *dims;

  dims = 0;
  attr[10] = new Attribute((m ? m->getClass("be_method_C") : BEMethod_C_Class), "hash_method", True, 0, dims);

  dims = 0;
  attr[11] = new Attribute((m ? m->getClass("int") : Int32_Class), "key_count", False, 0, dims);

  HashIndex_class->setAttributes(&attr[10], 2);

  delete attr[10];
  delete attr[11];

  ClassPeer::setMType(HashIndex_class, Class::System);

  return HashIndex_class;
}

Object *HashIndex_construct_x(const Class *cls, Data idr)
{
  return new HashIndex(cls, idr);
}

Object *HashIndex_construct(const Object *o, Bool share)
{
  return new HashIndex((const Struct *)o, share);
}

static void HashIndex_init_p()
{
  HashIndex_Class = HashIndex_make();
  constructors_x[class_ind] = HashIndex_construct_x;
  constructors[class_ind] = HashIndex_construct;
  hash->insert("hashindex", class_ind++);
}

static void HashIndex_init()
{
  HashIndex_make(HashIndex_Class);

  HashIndex_agritems = HashIndex_Class->getAttributes();
  HashIndex_idr_objsz = HashIndex_Class->getIDRObjectSize(&HashIndex_idr_psize, 0);

  ObjectPeer::setUnrealizable(HashIndex_Class, True);
}

static Status HashIndex_attrcomp_realize(Database *db, Class *cls)
{
  return Success;
}

HashIndex::HashIndex(Database *_db, const Dataspace *_dataspace) : Index(_db, _dataspace, 1)
{
  initialize(_db);
}

HashIndex::HashIndex(const Class *_cls, Data _idr): Index((Database *)0, (const Dataspace *)0, 1)
{
  setClass((Class *)_cls);

  Size idr_psize;
  Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  ClassPeer::newObjRealize(getClass(), this);
  ObjectPeer::setGRTObject(this, True);
  userInitialize();
}

void HashIndex::initialize(Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("hashindex") : HashIndex_Class));

  Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  ClassPeer::newObjRealize(getClass(), this);
  ObjectPeer::setGRTObject(this, True);
  userInitialize();
}

HashIndex::HashIndex(const HashIndex& x) : Index(x)
{
  userCopy(x);
}

HashIndex& HashIndex::operator=(const HashIndex& x)
{
  *(Index *)this = Index::operator=((const Index &)x);
  userCopy(x);
  return *this;
}

HashIndex::HashIndex(const Struct *x, Bool share) : Index(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("hashindex") : HashIndex_Class));

  Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      ClassPeer::newObjRealize(getClass(), this);
    }

  ObjectPeer::setGRTObject(this, True);
  userCopy(*x);
}

HashIndex::HashIndex(const HashIndex *x, Bool share) : Index(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("hashindex") : HashIndex_Class));

  Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      ClassPeer::newObjRealize(getClass(), this);
    }

  ObjectPeer::setGRTObject(this, True);
  userCopy(*x);
}

Status HashIndex::setHashMethod(BEMethod_C *_hash_method)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;

  status = getClass()->getAttributes()[10]->setValue(this, (Data)&_hash_method, 1, 0);
  return status;
}

const BEMethod_C *HashIndex::getHashMethod(Bool *isnull, Status *rs) const 
{
  gbxAutoGarbSuspender _gbxsusp_;
  Object *__o = 0, *__go;
  Status s;

  s = getClass()->getAttributes()[10]->getValue(this, (Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (ObjectPeer::isGRTObject(__o)) {
       return (BEMethod_C *)__o;
     }
     __go = (BEMethod_C *)make_object(__o, False);
     if (__go)
      {
       __o = __go;
       s = getClass()->getAttributes()[10]->setValue((Agregat *)this, (Data)&__o, 1, 0);
       ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
     return (BEMethod_C *)__o;
    }

  Bool wasnull = (!__o ? True : False);
  if (!__o && db)
    {
      Oid toid;
      s = getClass()->getAttributes()[10]->getOid(this, &toid, 1, 0);
      if (s) {if (rs) *rs = s; return 0;}
      if (toid.isValid())
        {
          s = db->loadObject(&toid, &__o);
          if (s) {if (rs) *rs = s; return 0;}
          if (!ObjectPeer::isGRTObject(__o))
           {
             __go = (BEMethod_C *)make_object(__o, False);
             if (__go) __o = __go;
           }
        }
    }

  if (__o && wasnull)
    {
     s = getClass()->getAttributes()[10]->setValue((Agregat *)this, (Data)&__o, 1, 0);
     if (s) {if (rs) *rs = s; return 0;}
     __o->release();
    }
  return (BEMethod_C *)__o;
}

BEMethod_C *HashIndex::getHashMethod(Bool *isnull, Status *rs) 
{
  gbxAutoGarbSuspender _gbxsusp_;
  Object *__o = 0, *__go;
  Status s;

  s = getClass()->getAttributes()[10]->getValue(this, (Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (ObjectPeer::isGRTObject(__o)) {
       return (BEMethod_C *)__o;
     }
     __go = (BEMethod_C *)make_object(__o, False);
     if (__go)
      {
       __o = __go;
       s = getClass()->getAttributes()[10]->setValue((Agregat *)this, (Data)&__o, 1, 0);
       ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
     return (BEMethod_C *)__o;
    }

  Bool wasnull = (!__o ? True : False);
  if (!__o && db)
    {
      Oid toid;
      s = getClass()->getAttributes()[10]->getOid(this, &toid, 1, 0);
      if (s) {if (rs) *rs = s; return 0;}
      if (toid.isValid())
        {
          s = db->loadObject(&toid, &__o);
          if (s) {if (rs) *rs = s; return 0;}
          if (!ObjectPeer::isGRTObject(__o))
           {
             __go = (BEMethod_C *)make_object(__o, False);
             if (__go) __o = __go;
           }
        }
    }

  if (__o && wasnull)
    {
     s = getClass()->getAttributes()[10]->setValue((Agregat *)this, (Data)&__o, 1, 0);
     if (s) {if (rs) *rs = s; return 0;}
     __o->release();
    }
  return (BEMethod_C *)__o;
}

Status HashIndex::setHashMethodOid(const Oid &_oid)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;

  status = getClass()->getAttributes()[10]->setOid(this, &_oid, 1, 0, oid_check);
  return status;
}

Oid HashIndex::getHashMethodOid(Status *rs) 
{
  gbxAutoGarbSuspender _gbxsusp_;
  Oid __tmp;
  Status s;

  s = getClass()->getAttributes()[10]->getOid(this, &__tmp, 1, 0);
  if (s) {if (rs) *rs = s; return nulloid;}

  return __tmp;
}

Status HashIndex::setKeyCount(eyedblib::int32 _key_count)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;

  status = getClass()->getAttributes()[11]->setValue(this, (Data)&_key_count, 1, 0);
  return status;
}

eyedblib::int32 HashIndex::getKeyCount(Bool *isnull, Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int32 __tmp = 0;
  Status s;

  s = getClass()->getAttributes()[11]->getValue(this, (Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

static const Attribute **BTreeIndex_agritems;
static Size BTreeIndex_idr_objsz, BTreeIndex_idr_psize;

static StructClass *BTreeIndex_make(StructClass *BTreeIndex_class = 0, Schema *m = 0)
{
  if (!BTreeIndex_class)
    return new StructClass("btreeindex", (m ? m->getClass("index") : Index_Class));
  Attribute *attr[11];
  int *dims;

  dims = 0;
  attr[10] = new Attribute((m ? m->getClass("int") : Int32_Class), "degree", False, 0, dims);

  BTreeIndex_class->setAttributes(&attr[10], 1);

  delete attr[10];

  ClassPeer::setMType(BTreeIndex_class, Class::System);

  return BTreeIndex_class;
}

Object *BTreeIndex_construct_x(const Class *cls, Data idr)
{
  return new BTreeIndex(cls, idr);
}

Object *BTreeIndex_construct(const Object *o, Bool share)
{
  return new BTreeIndex((const Struct *)o, share);
}

static void BTreeIndex_init_p()
{
  BTreeIndex_Class = BTreeIndex_make();
  constructors_x[class_ind] = BTreeIndex_construct_x;
  constructors[class_ind] = BTreeIndex_construct;
  hash->insert("btreeindex", class_ind++);
}

static void BTreeIndex_init()
{
  BTreeIndex_make(BTreeIndex_Class);

  BTreeIndex_agritems = BTreeIndex_Class->getAttributes();
  BTreeIndex_idr_objsz = BTreeIndex_Class->getIDRObjectSize(&BTreeIndex_idr_psize, 0);

  ObjectPeer::setUnrealizable(BTreeIndex_Class, True);
}

static Status BTreeIndex_attrcomp_realize(Database *db, Class *cls)
{
  return Success;
}

BTreeIndex::BTreeIndex(Database *_db, const Dataspace *_dataspace) : Index(_db, _dataspace, 1)
{
  initialize(_db);
}

BTreeIndex::BTreeIndex(const Class *_cls, Data _idr): Index((Database *)0, (const Dataspace *)0, 1)
{
  setClass((Class *)_cls);

  Size idr_psize;
  Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  ClassPeer::newObjRealize(getClass(), this);
  ObjectPeer::setGRTObject(this, True);
  userInitialize();
}

void BTreeIndex::initialize(Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("btreeindex") : BTreeIndex_Class));

  Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  ClassPeer::newObjRealize(getClass(), this);
  ObjectPeer::setGRTObject(this, True);
  userInitialize();
}

BTreeIndex::BTreeIndex(const BTreeIndex& x) : Index(x)
{
  userCopy(x);
}

BTreeIndex& BTreeIndex::operator=(const BTreeIndex& x)
{
  *(Index *)this = Index::operator=((const Index &)x);
  userCopy(x);
  return *this;
}

BTreeIndex::BTreeIndex(const Struct *x, Bool share) : Index(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("btreeindex") : BTreeIndex_Class));

  Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      ClassPeer::newObjRealize(getClass(), this);
    }

  ObjectPeer::setGRTObject(this, True);
  userCopy(*x);
}

BTreeIndex::BTreeIndex(const BTreeIndex *x, Bool share) : Index(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("btreeindex") : BTreeIndex_Class));

  Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      ClassPeer::newObjRealize(getClass(), this);
    }

  ObjectPeer::setGRTObject(this, True);
  userCopy(*x);
}

Status BTreeIndex::setDegree(eyedblib::int32 _degree)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;

  status = getClass()->getAttributes()[10]->setValue(this, (Data)&_degree, 1, 0);
  return status;
}

eyedblib::int32 BTreeIndex::getDegree(Bool *isnull, Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int32 __tmp = 0;
  Status s;

  s = getClass()->getAttributes()[10]->getValue(this, (Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

static const Attribute **CollAttrImpl_agritems;
static Size CollAttrImpl_idr_objsz, CollAttrImpl_idr_psize;

static StructClass *CollAttrImpl_make(StructClass *CollAttrImpl_class = 0, Schema *m = 0)
{
  if (!CollAttrImpl_class)
    return new StructClass("collection_attribute_implementation", (m ? m->getClass("attribute_component") : AttributeComponent_Class));
  Attribute *attr[11];
  int *dims;

  dims = 0;
  attr[6] = new Attribute((m ? m->getClass("int") : Int32_Class), "idxtype", False, 0, dims);

  dims = 0;
  attr[7] = new Attribute((m ? m->getClass("short") : Int16_Class), "dspid", False, 0, dims);

  dims = 0;
  attr[8] = new Attribute((m ? m->getClass("int") : Int32_Class), "key_count_or_degree", False, 0, dims);

  dims = 0;
  attr[9] = new Attribute((m ? m->getClass("be_method_C") : BEMethod_C_Class), "hash_method", True, 0, dims);

  dims = new int[1];
  dims[0] = -1;
  attr[10] = new Attribute((m ? m->getClass("int") : Int32_Class), "impl_hints", False, 1, dims);
  delete[] dims;

  CollAttrImpl_class->setAttributes(&attr[6], 5);

  delete attr[6];
  delete attr[7];
  delete attr[8];
  delete attr[9];
  delete attr[10];

  ClassPeer::setMType(CollAttrImpl_class, Class::System);

  return CollAttrImpl_class;
}

Object *CollAttrImpl_construct_x(const Class *cls, Data idr)
{
  return new CollAttrImpl(cls, idr);
}

Object *CollAttrImpl_construct(const Object *o, Bool share)
{
  return new CollAttrImpl((const Struct *)o, share);
}

static void CollAttrImpl_init_p()
{
  CollAttrImpl_Class = CollAttrImpl_make();
  constructors_x[class_ind] = CollAttrImpl_construct_x;
  constructors[class_ind] = CollAttrImpl_construct;
  hash->insert("collection_attribute_implementation", class_ind++);
}

static void CollAttrImpl_init()
{
  CollAttrImpl_make(CollAttrImpl_Class);

  CollAttrImpl_agritems = CollAttrImpl_Class->getAttributes();
  CollAttrImpl_idr_objsz = CollAttrImpl_Class->getIDRObjectSize(&CollAttrImpl_idr_psize, 0);

  ObjectPeer::setUnrealizable(CollAttrImpl_Class, True);
}

static Status CollAttrImpl_attrcomp_realize(Database *db, Class *cls)
{
  return Success;
}

CollAttrImpl::CollAttrImpl(Database *_db, const Dataspace *_dataspace) : AttributeComponent(_db, _dataspace, 1)
{
  initialize(_db);
}

CollAttrImpl::CollAttrImpl(const Class *_cls, Data _idr): AttributeComponent((Database *)0, (const Dataspace *)0, 1)
{
  setClass((Class *)_cls);

  Size idr_psize;
  Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  ClassPeer::newObjRealize(getClass(), this);
  ObjectPeer::setGRTObject(this, True);
  userInitialize();
}

void CollAttrImpl::initialize(Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("collection_attribute_implementation") : CollAttrImpl_Class));

  Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  ClassPeer::newObjRealize(getClass(), this);
  ObjectPeer::setGRTObject(this, True);
  userInitialize();
}

CollAttrImpl::CollAttrImpl(const CollAttrImpl& x) : AttributeComponent(x)
{
  userCopy(x);
}

CollAttrImpl& CollAttrImpl::operator=(const CollAttrImpl& x)
{
  *(AttributeComponent *)this = AttributeComponent::operator=((const AttributeComponent &)x);
  userCopy(x);
  return *this;
}

CollAttrImpl::CollAttrImpl(const Struct *x, Bool share) : AttributeComponent(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("collection_attribute_implementation") : CollAttrImpl_Class));

  Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      ClassPeer::newObjRealize(getClass(), this);
    }

  ObjectPeer::setGRTObject(this, True);
  userCopy(*x);
}

CollAttrImpl::CollAttrImpl(const CollAttrImpl *x, Bool share) : AttributeComponent(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("collection_attribute_implementation") : CollAttrImpl_Class));

  Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      ClassPeer::newObjRealize(getClass(), this);
    }

  ObjectPeer::setGRTObject(this, True);
  userCopy(*x);
}

Status CollAttrImpl::setIdxtype(eyedblib::int32 _idxtype)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;

  status = getClass()->getAttributes()[6]->setValue(this, (Data)&_idxtype, 1, 0);
  return status;
}

eyedblib::int32 CollAttrImpl::getIdxtype(Bool *isnull, Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int32 __tmp = 0;
  Status s;

  s = getClass()->getAttributes()[6]->getValue(this, (Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

Status CollAttrImpl::setDspid(eyedblib::int16 _dspid)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;

  status = getClass()->getAttributes()[7]->setValue(this, (Data)&_dspid, 1, 0);
  return status;
}

eyedblib::int16 CollAttrImpl::getDspid(Bool *isnull, Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int16 __tmp = 0;
  Status s;

  s = getClass()->getAttributes()[7]->getValue(this, (Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

Status CollAttrImpl::setKeyCountOrDegree(eyedblib::int32 _key_count_or_degree)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;

  status = getClass()->getAttributes()[8]->setValue(this, (Data)&_key_count_or_degree, 1, 0);
  return status;
}

eyedblib::int32 CollAttrImpl::getKeyCountOrDegree(Bool *isnull, Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int32 __tmp = 0;
  Status s;

  s = getClass()->getAttributes()[8]->getValue(this, (Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

Status CollAttrImpl::setHashMethod(BEMethod_C *_hash_method)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;

  status = getClass()->getAttributes()[9]->setValue(this, (Data)&_hash_method, 1, 0);
  return status;
}

const BEMethod_C *CollAttrImpl::getHashMethod(Bool *isnull, Status *rs) const 
{
  gbxAutoGarbSuspender _gbxsusp_;
  Object *__o = 0, *__go;
  Status s;

  s = getClass()->getAttributes()[9]->getValue(this, (Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (ObjectPeer::isGRTObject(__o)) {
       return (BEMethod_C *)__o;
     }
     __go = (BEMethod_C *)make_object(__o, False);
     if (__go)
      {
       __o = __go;
       s = getClass()->getAttributes()[9]->setValue((Agregat *)this, (Data)&__o, 1, 0);
       ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
     return (BEMethod_C *)__o;
    }

  Bool wasnull = (!__o ? True : False);
  if (!__o && db)
    {
      Oid toid;
      s = getClass()->getAttributes()[9]->getOid(this, &toid, 1, 0);
      if (s) {if (rs) *rs = s; return 0;}
      if (toid.isValid())
        {
          s = db->loadObject(&toid, &__o);
          if (s) {if (rs) *rs = s; return 0;}
          if (!ObjectPeer::isGRTObject(__o))
           {
             __go = (BEMethod_C *)make_object(__o, False);
             if (__go) __o = __go;
           }
        }
    }

  if (__o && wasnull)
    {
     s = getClass()->getAttributes()[9]->setValue((Agregat *)this, (Data)&__o, 1, 0);
     if (s) {if (rs) *rs = s; return 0;}
     __o->release();
    }
  return (BEMethod_C *)__o;
}

BEMethod_C *CollAttrImpl::getHashMethod(Bool *isnull, Status *rs) 
{
  gbxAutoGarbSuspender _gbxsusp_;
  Object *__o = 0, *__go;
  Status s;

  s = getClass()->getAttributes()[9]->getValue(this, (Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (ObjectPeer::isGRTObject(__o)) {
       return (BEMethod_C *)__o;
     }
     __go = (BEMethod_C *)make_object(__o, False);
     if (__go)
      {
       __o = __go;
       s = getClass()->getAttributes()[9]->setValue((Agregat *)this, (Data)&__o, 1, 0);
       ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
     return (BEMethod_C *)__o;
    }

  Bool wasnull = (!__o ? True : False);
  if (!__o && db)
    {
      Oid toid;
      s = getClass()->getAttributes()[9]->getOid(this, &toid, 1, 0);
      if (s) {if (rs) *rs = s; return 0;}
      if (toid.isValid())
        {
          s = db->loadObject(&toid, &__o);
          if (s) {if (rs) *rs = s; return 0;}
          if (!ObjectPeer::isGRTObject(__o))
           {
             __go = (BEMethod_C *)make_object(__o, False);
             if (__go) __o = __go;
           }
        }
    }

  if (__o && wasnull)
    {
     s = getClass()->getAttributes()[9]->setValue((Agregat *)this, (Data)&__o, 1, 0);
     if (s) {if (rs) *rs = s; return 0;}
     __o->release();
    }
  return (BEMethod_C *)__o;
}

Status CollAttrImpl::setHashMethodOid(const Oid &_oid)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;

  status = getClass()->getAttributes()[9]->setOid(this, &_oid, 1, 0, oid_check);
  return status;
}

Oid CollAttrImpl::getHashMethodOid(Status *rs) 
{
  gbxAutoGarbSuspender _gbxsusp_;
  Oid __tmp;
  Status s;

  s = getClass()->getAttributes()[9]->getOid(this, &__tmp, 1, 0);
  if (s) {if (rs) *rs = s; return nulloid;}

  return __tmp;
}

Status CollAttrImpl::setImplHints(unsigned int a0, eyedblib::int32 _impl_hints)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;
  Size from = a0;

  Size size;
  status = getClass()->getAttributes()[10]->getSize(this, size);
  if (status)
    return status;

  if (size <= from)
    status = getClass()->getAttributes()[10]->setSize(this, from+1);
  if (status)
    return status;

  status = getClass()->getAttributes()[10]->setValue(this, (Data)&_impl_hints, 1, from);
  return status;
}

Status CollAttrImpl::setImplHintsCount(unsigned int a0)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;
  Size from = a0;
  status = getClass()->getAttributes()[10]->setSize(this, from);
  return status;
}

eyedblib::int32 CollAttrImpl::getImplHints(unsigned int a0, Bool *isnull, Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int32 __tmp = 0;
  Status s;
  Size from = a0;

  s = getClass()->getAttributes()[10]->getValue(this, (Data *)&__tmp, 1, from, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

unsigned int CollAttrImpl::getImplHintsCount(Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  Size size;
  Status s;
  s = getClass()->getAttributes()[10]->getSize(this, size);
  if (s) {if (rs) *rs = s; return 0;}
  return (int)size;
}

static const Attribute **ArgType_agritems;
static Size ArgType_idr_objsz, ArgType_idr_psize;

static StructClass *ArgType_make(StructClass *ArgType_class = 0, Schema *m = 0)
{
  if (!ArgType_class)
    return new StructClass("argtype", (m ? m->getClass("struct") : Struct_Class));
  Attribute *attr[4];
  int *dims;

  dims = 0;
  attr[2] = new Attribute((m ? m->getClass("argtype_type") : ArgType_Type_Class), "type", False, 0, dims);

  dims = new int[1];
  dims[0] = -1;
  attr[3] = new Attribute((m ? m->getClass("char") : Char_Class), "clname", False, 1, dims);
  delete[] dims;

  ArgType_class->setAttributes(&attr[2], 2);

  delete attr[2];
  delete attr[3];

  ClassPeer::setMType(ArgType_class, Class::System);

  return ArgType_class;
}

Object *ArgType_construct_x(const Class *cls, Data idr)
{
  return new ArgType(cls, idr);
}

Object *ArgType_construct(const Object *o, Bool share)
{
  return new ArgType((const Struct *)o, share);
}

static void ArgType_init_p()
{
  ArgType_Class = ArgType_make();
  constructors_x[class_ind] = ArgType_construct_x;
  constructors[class_ind] = ArgType_construct;
  hash->insert("argtype", class_ind++);
}

static void ArgType_init()
{
  ArgType_make(ArgType_Class);

  ArgType_agritems = ArgType_Class->getAttributes();
  ArgType_idr_objsz = ArgType_Class->getIDRObjectSize(&ArgType_idr_psize, 0);

  ObjectPeer::setUnrealizable(ArgType_Class, True);
}

static Status ArgType_attrcomp_realize(Database *db, Class *cls)
{
  return Success;
}

ArgType::ArgType(Database *_db, const Dataspace *_dataspace) : Struct(_db, _dataspace)
{
  initialize(_db);
}

ArgType::ArgType(const Class *_cls, Data _idr)
{
  setClass((Class *)_cls);

  Size idr_psize;
  Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  ClassPeer::newObjRealize(getClass(), this);
  ObjectPeer::setGRTObject(this, True);
  userInitialize();
}

void ArgType::initialize(Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("argtype") : ArgType_Class));

  Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  ClassPeer::newObjRealize(getClass(), this);
  ObjectPeer::setGRTObject(this, True);
  userInitialize();
}

ArgType::ArgType(const ArgType& x) : Struct(x)
{
  userCopy(x);
}

ArgType& ArgType::operator=(const ArgType& x)
{
  *(Struct *)this = Struct::operator=((const Struct &)x);
  userCopy(x);
  return *this;
}

ArgType::ArgType(const Struct *x, Bool share) : Struct(x, share)
{
  setClass((db ? db->getSchema()->getClass("argtype") : ArgType_Class));

  Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      ClassPeer::newObjRealize(getClass(), this);
    }

  ObjectPeer::setGRTObject(this, True);
  userCopy(*x);
}

ArgType::ArgType(const ArgType *x, Bool share) : Struct(x, share)
{
  setClass((db ? db->getSchema()->getClass("argtype") : ArgType_Class));

  Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      ClassPeer::newObjRealize(getClass(), this);
    }

  ObjectPeer::setGRTObject(this, True);
  userCopy(*x);
}

Status ArgType::setType(ArgType_Type _type, Bool _check_value)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;
  eyedblib::int32 __tmp = _type;

  status = getClass()->getAttributes()[2]->setValue(this, (Data)&__tmp, 1, 0, _check_value);
  return status;
}

ArgType_Type ArgType::getType(Bool *isnull, Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int32 __tmp = 0;
  Status s;

  s = getClass()->getAttributes()[2]->getValue(this, (Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return (ArgType_Type)0;}
  return (ArgType_Type)__tmp;
}

Status ArgType::setClname(const char *_clname)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;
  Size size;
  Size len = ::strlen(_clname) + 1;

  status = getClass()->getAttributes()[3]->getSize(this, size);
  if (status)
    return status;

  if (size != len)
    status = getClass()->getAttributes()[3]->setSize(this, len);
  if (status)
    return status;

  status = getClass()->getAttributes()[3]->setValue(this, (Data)_clname, len, 0);
  return status;

}

Status ArgType::setClname(unsigned int a0, char _clname)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;
  Size from = a0;

  Size size;
  status = getClass()->getAttributes()[3]->getSize(this, size);
  if (status)
    return status;

  if (size <= from)
    status = getClass()->getAttributes()[3]->setSize(this, from+1);
  if (status)
    return status;

  status = getClass()->getAttributes()[3]->setValue(this, (Data)&_clname, 1, from);
  return status;
}

const char *ArgType::getClname(Bool *isnull, Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  Data data;
  Status s;

  s = getClass()->getAttributes()[3]->getValue(this, (Data *)&data, Attribute::directAccess, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  if (!data) data = nulldata;
  return (const char *)data;
}

char ArgType::getClname(unsigned int a0, Bool *isnull, Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  char __tmp = 0;
  Status s;
  Size from = a0;

  s = getClass()->getAttributes()[3]->getValue(this, (Data *)&__tmp, 1, from, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

static const Attribute **Signature_agritems;
static Size Signature_idr_objsz, Signature_idr_psize;

static StructClass *Signature_make(StructClass *Signature_class = 0, Schema *m = 0)
{
  if (!Signature_class)
    return new StructClass("signature", (m ? m->getClass("struct") : Struct_Class));
  Attribute *attr[5];
  int *dims;

  dims = 0;
  attr[2] = new Attribute((m ? m->getClass("argtype") : ArgType_Class), "rettype", False, 0, dims);

  dims = 0;
  attr[3] = new Attribute((m ? m->getClass("int") : Int32_Class), "nargs", False, 0, dims);

  dims = new int[1];
  dims[0] = -1;
  attr[4] = new Attribute((m ? m->getClass("argtype") : ArgType_Class), "types", False, 1, dims);
  delete[] dims;

  Signature_class->setAttributes(&attr[2], 3);

  delete attr[2];
  delete attr[3];
  delete attr[4];

  ClassPeer::setMType(Signature_class, Class::System);

  return Signature_class;
}

Object *Signature_construct_x(const Class *cls, Data idr)
{
  return new Signature(cls, idr);
}

Object *Signature_construct(const Object *o, Bool share)
{
  return new Signature((const Struct *)o, share);
}

static void Signature_init_p()
{
  Signature_Class = Signature_make();
  constructors_x[class_ind] = Signature_construct_x;
  constructors[class_ind] = Signature_construct;
  hash->insert("signature", class_ind++);
}

static void Signature_init()
{
  Signature_make(Signature_Class);

  Signature_agritems = Signature_Class->getAttributes();
  Signature_idr_objsz = Signature_Class->getIDRObjectSize(&Signature_idr_psize, 0);

  ObjectPeer::setUnrealizable(Signature_Class, True);
}

static Status Signature_attrcomp_realize(Database *db, Class *cls)
{
  return Success;
}

Signature::Signature(Database *_db, const Dataspace *_dataspace) : Struct(_db, _dataspace)
{
  initialize(_db);
}

Signature::Signature(const Class *_cls, Data _idr)
{
  setClass((Class *)_cls);

  Size idr_psize;
  Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  ClassPeer::newObjRealize(getClass(), this);
  ObjectPeer::setGRTObject(this, True);
  userInitialize();
}

void Signature::initialize(Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("signature") : Signature_Class));

  Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  ClassPeer::newObjRealize(getClass(), this);
  ObjectPeer::setGRTObject(this, True);
  userInitialize();
}

Signature::Signature(const Signature& x) : Struct(x)
{
  userCopy(x);
}

Signature& Signature::operator=(const Signature& x)
{
  *(Struct *)this = Struct::operator=((const Struct &)x);
  userCopy(x);
  return *this;
}

Signature::Signature(const Struct *x, Bool share) : Struct(x, share)
{
  setClass((db ? db->getSchema()->getClass("signature") : Signature_Class));

  Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      ClassPeer::newObjRealize(getClass(), this);
    }

  ObjectPeer::setGRTObject(this, True);
  userCopy(*x);
}

Signature::Signature(const Signature *x, Bool share) : Struct(x, share)
{
  setClass((db ? db->getSchema()->getClass("signature") : Signature_Class));

  Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      ClassPeer::newObjRealize(getClass(), this);
    }

  ObjectPeer::setGRTObject(this, True);
  userCopy(*x);
}

Status Signature::setRettype(ArgType *_rettype)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;

  status = getClass()->getAttributes()[2]->setValue(this, (Data)&_rettype, 1, 0);
  return status;
}

const ArgType *Signature::getRettype(Bool *isnull, Status *rs) const 
{
  gbxAutoGarbSuspender _gbxsusp_;
  Object *__o = 0, *__go;
  Status s;

  s = getClass()->getAttributes()[2]->getValue(this, (Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (ObjectPeer::isGRTObject(__o)) {
       return (ArgType *)__o;
     }
     __go = (ArgType *)make_object(__o, False);
     if (__go)
      {
       __o = __go;;
       s = getClass()->getAttributes()[2]->setValue((Agregat *)this, (Data)&__o, 1, 0);
       ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
    }
  return (ArgType *)__o;
}

ArgType *Signature::getRettype(Bool *isnull, Status *rs) 
{
  gbxAutoGarbSuspender _gbxsusp_;
  Object *__o = 0, *__go;
  Status s;

  s = getClass()->getAttributes()[2]->getValue(this, (Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (ObjectPeer::isGRTObject(__o)) {
       return (ArgType *)__o;
     }
     __go = (ArgType *)make_object(__o, False);
     if (__go)
      {
       __o = __go;;
       s = getClass()->getAttributes()[2]->setValue((Agregat *)this, (Data)&__o, 1, 0);
       ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
    }
  return (ArgType *)__o;
}

Status Signature::setNargs(eyedblib::int32 _nargs)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;

  status = getClass()->getAttributes()[3]->setValue(this, (Data)&_nargs, 1, 0);
  return status;
}

eyedblib::int32 Signature::getNargs(Bool *isnull, Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int32 __tmp = 0;
  Status s;

  s = getClass()->getAttributes()[3]->getValue(this, (Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

Status Signature::setTypes(unsigned int a0, ArgType *_types)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;
  Size from = a0;

  Size size;
  status = getClass()->getAttributes()[4]->getSize(this, size);
  if (status)
    return status;

  if (size <= from)
    status = getClass()->getAttributes()[4]->setSize(this, from+1);
  if (status)
    return status;

  status = getClass()->getAttributes()[4]->setValue(this, (Data)&_types, 1, from);
  return status;
}

Status Signature::setTypesCount(unsigned int a0)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;
  Size from = a0;
  status = getClass()->getAttributes()[4]->setSize(this, from);
  return status;
}

const ArgType *Signature::getTypes(unsigned int a0, Bool *isnull, Status *rs) const 
{
  gbxAutoGarbSuspender _gbxsusp_;
  Object *__o = 0, *__go;
  Status s;
  Size from = a0;

  s = getClass()->getAttributes()[4]->getValue(this, (Data *)&__o, 1, from, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (ObjectPeer::isGRTObject(__o)) {
       return (ArgType *)__o;
     }
     __go = (ArgType *)make_object(__o, False);
     if (__go)
      {
       __o = __go;;
       s = getClass()->getAttributes()[4]->setValue((Agregat *)this, (Data)&__o, 1, from);
       ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
    }
  return (ArgType *)__o;
}

ArgType *Signature::getTypes(unsigned int a0, Bool *isnull, Status *rs) 
{
  gbxAutoGarbSuspender _gbxsusp_;
  Object *__o = 0, *__go;
  Status s;
  Size from = a0;

  s = getClass()->getAttributes()[4]->getValue(this, (Data *)&__o, 1, from, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (ObjectPeer::isGRTObject(__o)) {
       return (ArgType *)__o;
     }
     __go = (ArgType *)make_object(__o, False);
     if (__go)
      {
       __o = __go;;
       s = getClass()->getAttributes()[4]->setValue((Agregat *)this, (Data)&__o, 1, from);
       ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
    }
  return (ArgType *)__o;
}

unsigned int Signature::getTypesCount(Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  Size size;
  Status s;
  s = getClass()->getAttributes()[4]->getSize(this, size);
  if (s) {if (rs) *rs = s; return 0;}
  return (int)size;
}

static const Attribute **Executable_agritems;
static Size Executable_idr_objsz, Executable_idr_psize;

static StructClass *Executable_make(StructClass *Executable_class = 0, Schema *m = 0)
{
  if (!Executable_class)
    return new StructClass("executable", (m ? m->getClass("struct") : Struct_Class));
  Attribute *attr[8];
  int *dims;

  dims = new int[1];
  dims[0] = -1;
  attr[2] = new Attribute((m ? m->getClass("char") : Char_Class), "exname", False, 1, dims);
  delete[] dims;

  dims = 0;
  attr[3] = new Attribute((m ? m->getClass("executable_lang") : ExecutableLang_Class), "lang", False, 0, dims);

  dims = 0;
  attr[4] = new Attribute((m ? m->getClass("executable_localisation") : ExecutableLocalisation_Class), "loc", False, 0, dims);

  dims = 0;
  attr[5] = new Attribute((m ? m->getClass("signature") : Signature_Class), "sign", False, 0, dims);

  dims = new int[1];
  dims[0] = -1;
  attr[6] = new Attribute((m ? m->getClass("char") : Char_Class), "intname", False, 1, dims);
  delete[] dims;

  dims = new int[1];
  dims[0] = -1;
  attr[7] = new Attribute((m ? m->getClass("char") : Char_Class), "extref_body", False, 1, dims);
  delete[] dims;

  Executable_class->setAttributes(&attr[2], 6);

  delete attr[2];
  delete attr[3];
  delete attr[4];
  delete attr[5];
  delete attr[6];
  delete attr[7];

  ClassPeer::setMType(Executable_class, Class::System);

  return Executable_class;
}

Object *Executable_construct_x(const Class *cls, Data idr)
{
  return new Executable(cls, idr);
}

Object *Executable_construct(const Object *o, Bool share)
{
  return new Executable((const Struct *)o, share);
}

static void Executable_init_p()
{
  Executable_Class = Executable_make();
  constructors_x[class_ind] = Executable_construct_x;
  constructors[class_ind] = Executable_construct;
  hash->insert("executable", class_ind++);
}

static void Executable_init()
{
  Executable_make(Executable_Class);

  Executable_agritems = Executable_Class->getAttributes();
  Executable_idr_objsz = Executable_Class->getIDRObjectSize(&Executable_idr_psize, 0);

  ObjectPeer::setUnrealizable(Executable_Class, True);
}

static Status Executable_attrcomp_realize(Database *db, Class *cls)
{
  AttributeComponent *comp;
  const Dataspace *dataspace;
  ClassComponent *clcomp;
  Status status;
  int *impl_hints;
  comp = new NotNullConstraint(db, cls, "executable.exname", True);
  cls->add(comp->getInd(), comp);

  return Success;
}

Executable::Executable(Database *_db, const Dataspace *_dataspace) : Struct(_db, _dataspace)
{
  initialize(_db);
}

Executable::Executable(const Class *_cls, Data _idr)
{
  setClass((Class *)_cls);

  Size idr_psize;
  Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  ClassPeer::newObjRealize(getClass(), this);
  ObjectPeer::setGRTObject(this, True);
  userInitialize();
}

void Executable::initialize(Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("executable") : Executable_Class));

  Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  ClassPeer::newObjRealize(getClass(), this);
  ObjectPeer::setGRTObject(this, True);
  userInitialize();
}

Executable::Executable(const Executable& x) : Struct(x)
{
  userCopy(x);
}

Executable& Executable::operator=(const Executable& x)
{
  *(Struct *)this = Struct::operator=((const Struct &)x);
  userCopy(x);
  return *this;
}

Executable::Executable(const Struct *x, Bool share) : Struct(x, share)
{
  setClass((db ? db->getSchema()->getClass("executable") : Executable_Class));

  Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      ClassPeer::newObjRealize(getClass(), this);
    }

  ObjectPeer::setGRTObject(this, True);
  userCopy(*x);
}

Executable::Executable(const Executable *x, Bool share) : Struct(x, share)
{
  setClass((db ? db->getSchema()->getClass("executable") : Executable_Class));

  Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      ClassPeer::newObjRealize(getClass(), this);
    }

  ObjectPeer::setGRTObject(this, True);
  userCopy(*x);
}

Status Executable::setExname(const char *_exname)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;
  Size size;
  Size len = ::strlen(_exname) + 1;

  status = getClass()->getAttributes()[2]->getSize(this, size);
  if (status)
    return status;

  if (size != len)
    status = getClass()->getAttributes()[2]->setSize(this, len);
  if (status)
    return status;

  status = getClass()->getAttributes()[2]->setValue(this, (Data)_exname, len, 0);
  return status;

}

Status Executable::setExname(unsigned int a0, char _exname)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;
  Size from = a0;

  Size size;
  status = getClass()->getAttributes()[2]->getSize(this, size);
  if (status)
    return status;

  if (size <= from)
    status = getClass()->getAttributes()[2]->setSize(this, from+1);
  if (status)
    return status;

  status = getClass()->getAttributes()[2]->setValue(this, (Data)&_exname, 1, from);
  return status;
}

const char *Executable::getExname(Bool *isnull, Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  Data data;
  Status s;

  s = getClass()->getAttributes()[2]->getValue(this, (Data *)&data, Attribute::directAccess, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  if (!data) data = nulldata;
  return (const char *)data;
}

char Executable::getExname(unsigned int a0, Bool *isnull, Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  char __tmp = 0;
  Status s;
  Size from = a0;

  s = getClass()->getAttributes()[2]->getValue(this, (Data *)&__tmp, 1, from, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

Status Executable::setLang(ExecutableLang _lang, Bool _check_value)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;
  eyedblib::int32 __tmp = _lang;

  status = getClass()->getAttributes()[3]->setValue(this, (Data)&__tmp, 1, 0, _check_value);
  return status;
}

ExecutableLang Executable::getLang(Bool *isnull, Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int32 __tmp = 0;
  Status s;

  s = getClass()->getAttributes()[3]->getValue(this, (Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return (ExecutableLang)0;}
  return (ExecutableLang)__tmp;
}

Status Executable::setLoc(ExecutableLocalisation _loc, Bool _check_value)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;
  eyedblib::int32 __tmp = _loc;

  status = getClass()->getAttributes()[4]->setValue(this, (Data)&__tmp, 1, 0, _check_value);
  return status;
}

ExecutableLocalisation Executable::getLoc(Bool *isnull, Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int32 __tmp = 0;
  Status s;

  s = getClass()->getAttributes()[4]->getValue(this, (Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return (ExecutableLocalisation)0;}
  return (ExecutableLocalisation)__tmp;
}

Status Executable::setSign(Signature *_sign)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;

  status = getClass()->getAttributes()[5]->setValue(this, (Data)&_sign, 1, 0);
  return status;
}

const Signature *Executable::getSign(Bool *isnull, Status *rs) const 
{
  gbxAutoGarbSuspender _gbxsusp_;
  Object *__o = 0, *__go;
  Status s;

  s = getClass()->getAttributes()[5]->getValue(this, (Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (ObjectPeer::isGRTObject(__o)) {
       return (Signature *)__o;
     }
     __go = (Signature *)make_object(__o, False);
     if (__go)
      {
       __o = __go;;
       s = getClass()->getAttributes()[5]->setValue((Agregat *)this, (Data)&__o, 1, 0);
       ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
    }
  return (Signature *)__o;
}

Signature *Executable::getSign(Bool *isnull, Status *rs) 
{
  gbxAutoGarbSuspender _gbxsusp_;
  Object *__o = 0, *__go;
  Status s;

  s = getClass()->getAttributes()[5]->getValue(this, (Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (ObjectPeer::isGRTObject(__o)) {
       return (Signature *)__o;
     }
     __go = (Signature *)make_object(__o, False);
     if (__go)
      {
       __o = __go;;
       s = getClass()->getAttributes()[5]->setValue((Agregat *)this, (Data)&__o, 1, 0);
       ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
    }
  return (Signature *)__o;
}

Status Executable::setIntname(const char *_intname)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;
  Size size;
  Size len = ::strlen(_intname) + 1;

  status = getClass()->getAttributes()[6]->getSize(this, size);
  if (status)
    return status;

  if (size != len)
    status = getClass()->getAttributes()[6]->setSize(this, len);
  if (status)
    return status;

  status = getClass()->getAttributes()[6]->setValue(this, (Data)_intname, len, 0);
  return status;

}

Status Executable::setIntname(unsigned int a0, char _intname)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;
  Size from = a0;

  Size size;
  status = getClass()->getAttributes()[6]->getSize(this, size);
  if (status)
    return status;

  if (size <= from)
    status = getClass()->getAttributes()[6]->setSize(this, from+1);
  if (status)
    return status;

  status = getClass()->getAttributes()[6]->setValue(this, (Data)&_intname, 1, from);
  return status;
}

const char *Executable::getIntname(Bool *isnull, Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  Data data;
  Status s;

  s = getClass()->getAttributes()[6]->getValue(this, (Data *)&data, Attribute::directAccess, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  if (!data) data = nulldata;
  return (const char *)data;
}

char Executable::getIntname(unsigned int a0, Bool *isnull, Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  char __tmp = 0;
  Status s;
  Size from = a0;

  s = getClass()->getAttributes()[6]->getValue(this, (Data *)&__tmp, 1, from, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

Status Executable::setExtrefBody(const char *_extref_body)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;
  Size size;
  Size len = ::strlen(_extref_body) + 1;

  status = getClass()->getAttributes()[7]->getSize(this, size);
  if (status)
    return status;

  if (size != len)
    status = getClass()->getAttributes()[7]->setSize(this, len);
  if (status)
    return status;

  status = getClass()->getAttributes()[7]->setValue(this, (Data)_extref_body, len, 0);
  return status;

}

Status Executable::setExtrefBody(unsigned int a0, char _extref_body)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;
  Size from = a0;

  Size size;
  status = getClass()->getAttributes()[7]->getSize(this, size);
  if (status)
    return status;

  if (size <= from)
    status = getClass()->getAttributes()[7]->setSize(this, from+1);
  if (status)
    return status;

  status = getClass()->getAttributes()[7]->setValue(this, (Data)&_extref_body, 1, from);
  return status;
}

const char *Executable::getExtrefBody(Bool *isnull, Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  Data data;
  Status s;

  s = getClass()->getAttributes()[7]->getValue(this, (Data *)&data, Attribute::directAccess, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  if (!data) data = nulldata;
  return (const char *)data;
}

char Executable::getExtrefBody(unsigned int a0, Bool *isnull, Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  char __tmp = 0;
  Status s;
  Size from = a0;

  s = getClass()->getAttributes()[7]->getValue(this, (Data *)&__tmp, 1, from, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

static const Attribute **AgregatClassExecutable_agritems;
static Size AgregatClassExecutable_idr_objsz, AgregatClassExecutable_idr_psize;

static StructClass *AgregatClassExecutable_make(StructClass *AgregatClassExecutable_class = 0, Schema *m = 0)
{
  if (!AgregatClassExecutable_class)
    return new StructClass("agregat_class_executable", (m ? m->getClass("agregat_class_component") : AgregatClassComponent_Class));
  Attribute *attr[5];
  int *dims;

  dims = 0;
  attr[4] = new Attribute((m ? m->getClass("executable") : Executable_Class), "ex", False, 0, dims);

  AgregatClassExecutable_class->setAttributes(&attr[4], 1);

  delete attr[4];

  ClassPeer::setMType(AgregatClassExecutable_class, Class::System);

  return AgregatClassExecutable_class;
}

Object *AgregatClassExecutable_construct_x(const Class *cls, Data idr)
{
  return new AgregatClassExecutable(cls, idr);
}

Object *AgregatClassExecutable_construct(const Object *o, Bool share)
{
  return new AgregatClassExecutable((const Struct *)o, share);
}

static void AgregatClassExecutable_init_p()
{
  AgregatClassExecutable_Class = AgregatClassExecutable_make();
  constructors_x[class_ind] = AgregatClassExecutable_construct_x;
  constructors[class_ind] = AgregatClassExecutable_construct;
  hash->insert("agregat_class_executable", class_ind++);
}

static void AgregatClassExecutable_init()
{
  AgregatClassExecutable_make(AgregatClassExecutable_Class);

  AgregatClassExecutable_agritems = AgregatClassExecutable_Class->getAttributes();
  AgregatClassExecutable_idr_objsz = AgregatClassExecutable_Class->getIDRObjectSize(&AgregatClassExecutable_idr_psize, 0);

  ObjectPeer::setUnrealizable(AgregatClassExecutable_Class, True);
}

static Status AgregatClassExecutable_attrcomp_realize(Database *db, Class *cls)
{
  AttributeComponent *comp;
  const Dataspace *dataspace;
  ClassComponent *clcomp;
  Status status;
  int *impl_hints;
  impl_hints = new int[8];
  impl_hints[0] = 0;
  impl_hints[1] = 0;
  impl_hints[2] = 0;
  impl_hints[3] = 0;
  impl_hints[4] = 0;
  impl_hints[5] = 0;
  impl_hints[6] = 0;
  impl_hints[7] = 0;
  dataspace = 0;;
  comp = new HashIndex(db, cls, "agregat_class_executable.ex.exname", False, True, dataspace, 0, 0, impl_hints, 8);
  delete [] impl_hints;
  cls->add(comp->getInd(), comp);

  impl_hints = new int[8];
  impl_hints[0] = 0;
  impl_hints[1] = 0;
  impl_hints[2] = 0;
  impl_hints[3] = 0;
  impl_hints[4] = 0;
  impl_hints[5] = 0;
  impl_hints[6] = 0;
  impl_hints[7] = 0;
  dataspace = 0;;
  comp = new HashIndex(db, cls, "agregat_class_executable.ex.intname", False, True, dataspace, 0, 0, impl_hints, 8);
  delete [] impl_hints;
  cls->add(comp->getInd(), comp);

  return Success;
}

AgregatClassExecutable::AgregatClassExecutable(Database *_db, const Dataspace *_dataspace) : AgregatClassComponent(_db, _dataspace, 1)
{
  initialize(_db);
}

AgregatClassExecutable::AgregatClassExecutable(const Class *_cls, Data _idr): AgregatClassComponent((Database *)0, (const Dataspace *)0, 1)
{
  setClass((Class *)_cls);

  Size idr_psize;
  Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  ClassPeer::newObjRealize(getClass(), this);
  ObjectPeer::setGRTObject(this, True);
  userInitialize();
}

void AgregatClassExecutable::initialize(Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("agregat_class_executable") : AgregatClassExecutable_Class));

  Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  ClassPeer::newObjRealize(getClass(), this);
  ObjectPeer::setGRTObject(this, True);
  userInitialize();
}

AgregatClassExecutable::AgregatClassExecutable(const AgregatClassExecutable& x) : AgregatClassComponent(x)
{
  userCopy(x);
}

AgregatClassExecutable& AgregatClassExecutable::operator=(const AgregatClassExecutable& x)
{
  *(AgregatClassComponent *)this = AgregatClassComponent::operator=((const AgregatClassComponent &)x);
  userCopy(x);
  return *this;
}

AgregatClassExecutable::AgregatClassExecutable(const Struct *x, Bool share) : AgregatClassComponent(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("agregat_class_executable") : AgregatClassExecutable_Class));

  Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      ClassPeer::newObjRealize(getClass(), this);
    }

  ObjectPeer::setGRTObject(this, True);
  userCopy(*x);
}

AgregatClassExecutable::AgregatClassExecutable(const AgregatClassExecutable *x, Bool share) : AgregatClassComponent(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("agregat_class_executable") : AgregatClassExecutable_Class));

  Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      ClassPeer::newObjRealize(getClass(), this);
    }

  ObjectPeer::setGRTObject(this, True);
  userCopy(*x);
}

Status AgregatClassExecutable::setEx(Executable *_ex)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;

  status = getClass()->getAttributes()[4]->setValue(this, (Data)&_ex, 1, 0);
  return status;
}

const Executable *AgregatClassExecutable::getEx(Bool *isnull, Status *rs) const 
{
  gbxAutoGarbSuspender _gbxsusp_;
  Object *__o = 0, *__go;
  Status s;

  s = getClass()->getAttributes()[4]->getValue(this, (Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (ObjectPeer::isGRTObject(__o)) {
       return (Executable *)__o;
     }
     __go = (Executable *)make_object(__o, False);
     if (__go)
      {
       __o = __go;;
       s = getClass()->getAttributes()[4]->setValue((Agregat *)this, (Data)&__o, 1, 0);
       ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
    }
  return (Executable *)__o;
}

Executable *AgregatClassExecutable::getEx(Bool *isnull, Status *rs) 
{
  gbxAutoGarbSuspender _gbxsusp_;
  Object *__o = 0, *__go;
  Status s;

  s = getClass()->getAttributes()[4]->getValue(this, (Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (ObjectPeer::isGRTObject(__o)) {
       return (Executable *)__o;
     }
     __go = (Executable *)make_object(__o, False);
     if (__go)
      {
       __o = __go;;
       s = getClass()->getAttributes()[4]->setValue((Agregat *)this, (Data)&__o, 1, 0);
       ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
    }
  return (Executable *)__o;
}

static const Attribute **Method_agritems;
static Size Method_idr_objsz, Method_idr_psize;

static StructClass *Method_make(StructClass *Method_class = 0, Schema *m = 0)
{
  if (!Method_class)
    return new StructClass("method", (m ? m->getClass("agregat_class_executable") : AgregatClassExecutable_Class));
  Attribute *attr[5];

  Method_class->setAttributes(&attr[5], 0);


  ClassPeer::setMType(Method_class, Class::System);

  return Method_class;
}

Object *Method_construct_x(const Class *cls, Data idr)
{
  return new Method(cls, idr);
}

Object *Method_construct(const Object *o, Bool share)
{
  return new Method((const Struct *)o, share);
}

static void Method_init_p()
{
  Method_Class = Method_make();
  constructors_x[class_ind] = Method_construct_x;
  constructors[class_ind] = Method_construct;
  hash->insert("method", class_ind++);
}

static void Method_init()
{
  Method_make(Method_Class);

  Method_agritems = Method_Class->getAttributes();
  Method_idr_objsz = Method_Class->getIDRObjectSize(&Method_idr_psize, 0);

  ObjectPeer::setUnrealizable(Method_Class, True);
}

static Status Method_attrcomp_realize(Database *db, Class *cls)
{
  AttributeComponent *comp;
  const Dataspace *dataspace;
  ClassComponent *clcomp;
  Status status;
  int *impl_hints;
  impl_hints = new int[8];
  impl_hints[0] = 0;
  impl_hints[1] = 0;
  impl_hints[2] = 0;
  impl_hints[3] = 0;
  impl_hints[4] = 0;
  impl_hints[5] = 0;
  impl_hints[6] = 0;
  impl_hints[7] = 0;
  dataspace = 0;;
  comp = new HashIndex(db, cls, "method.ex.exname", False, True, dataspace, 0, 0, impl_hints, 8);
  delete [] impl_hints;
  cls->add(comp->getInd(), comp);

  impl_hints = new int[8];
  impl_hints[0] = 0;
  impl_hints[1] = 0;
  impl_hints[2] = 0;
  impl_hints[3] = 0;
  impl_hints[4] = 0;
  impl_hints[5] = 0;
  impl_hints[6] = 0;
  impl_hints[7] = 0;
  dataspace = 0;;
  comp = new HashIndex(db, cls, "method.ex.intname", False, True, dataspace, 0, 0, impl_hints, 8);
  delete [] impl_hints;
  cls->add(comp->getInd(), comp);

  return Success;
}

Method::Method(Database *_db, const Dataspace *_dataspace) : AgregatClassExecutable(_db, _dataspace, 1)
{
  initialize(_db);
}

Method::Method(const Class *_cls, Data _idr): AgregatClassExecutable((Database *)0, (const Dataspace *)0, 1)
{
  setClass((Class *)_cls);

  Size idr_psize;
  Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  ClassPeer::newObjRealize(getClass(), this);
  ObjectPeer::setGRTObject(this, True);
  userInitialize();
}

void Method::initialize(Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("method") : Method_Class));

  Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  ClassPeer::newObjRealize(getClass(), this);
  ObjectPeer::setGRTObject(this, True);
  userInitialize();
}

Method::Method(const Method& x) : AgregatClassExecutable(x)
{
  userCopy(x);
}

Method& Method::operator=(const Method& x)
{
  *(AgregatClassExecutable *)this = AgregatClassExecutable::operator=((const AgregatClassExecutable &)x);
  userCopy(x);
  return *this;
}

Method::Method(const Struct *x, Bool share) : AgregatClassExecutable(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("method") : Method_Class));

  Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      ClassPeer::newObjRealize(getClass(), this);
    }

  ObjectPeer::setGRTObject(this, True);
  userCopy(*x);
}

Method::Method(const Method *x, Bool share) : AgregatClassExecutable(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("method") : Method_Class));

  Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      ClassPeer::newObjRealize(getClass(), this);
    }

  ObjectPeer::setGRTObject(this, True);
  userCopy(*x);
}

static const Attribute **FEMethod_agritems;
static Size FEMethod_idr_objsz, FEMethod_idr_psize;

static StructClass *FEMethod_make(StructClass *FEMethod_class = 0, Schema *m = 0)
{
  if (!FEMethod_class)
    return new StructClass("fe_method", (m ? m->getClass("method") : Method_Class));
  Attribute *attr[5];

  FEMethod_class->setAttributes(&attr[5], 0);


  ClassPeer::setMType(FEMethod_class, Class::System);

  return FEMethod_class;
}

Object *FEMethod_construct_x(const Class *cls, Data idr)
{
  return new FEMethod(cls, idr);
}

Object *FEMethod_construct(const Object *o, Bool share)
{
  return new FEMethod((const Struct *)o, share);
}

static void FEMethod_init_p()
{
  FEMethod_Class = FEMethod_make();
  constructors_x[class_ind] = FEMethod_construct_x;
  constructors[class_ind] = FEMethod_construct;
  hash->insert("fe_method", class_ind++);
}

static void FEMethod_init()
{
  FEMethod_make(FEMethod_Class);

  FEMethod_agritems = FEMethod_Class->getAttributes();
  FEMethod_idr_objsz = FEMethod_Class->getIDRObjectSize(&FEMethod_idr_psize, 0);

  ObjectPeer::setUnrealizable(FEMethod_Class, True);
}

static Status FEMethod_attrcomp_realize(Database *db, Class *cls)
{
  AttributeComponent *comp;
  const Dataspace *dataspace;
  ClassComponent *clcomp;
  Status status;
  int *impl_hints;
  impl_hints = new int[8];
  impl_hints[0] = 0;
  impl_hints[1] = 0;
  impl_hints[2] = 0;
  impl_hints[3] = 0;
  impl_hints[4] = 0;
  impl_hints[5] = 0;
  impl_hints[6] = 0;
  impl_hints[7] = 0;
  dataspace = 0;;
  comp = new HashIndex(db, cls, "fe_method.ex.exname", False, True, dataspace, 0, 0, impl_hints, 8);
  delete [] impl_hints;
  cls->add(comp->getInd(), comp);

  impl_hints = new int[8];
  impl_hints[0] = 0;
  impl_hints[1] = 0;
  impl_hints[2] = 0;
  impl_hints[3] = 0;
  impl_hints[4] = 0;
  impl_hints[5] = 0;
  impl_hints[6] = 0;
  impl_hints[7] = 0;
  dataspace = 0;;
  comp = new HashIndex(db, cls, "fe_method.ex.intname", False, True, dataspace, 0, 0, impl_hints, 8);
  delete [] impl_hints;
  cls->add(comp->getInd(), comp);

  return Success;
}

FEMethod::FEMethod(Database *_db, const Dataspace *_dataspace) : Method(_db, _dataspace, 1)
{
  initialize(_db);
}

FEMethod::FEMethod(const Class *_cls, Data _idr): Method((Database *)0, (const Dataspace *)0, 1)
{
  setClass((Class *)_cls);

  Size idr_psize;
  Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  ClassPeer::newObjRealize(getClass(), this);
  ObjectPeer::setGRTObject(this, True);
  userInitialize();
}

void FEMethod::initialize(Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("fe_method") : FEMethod_Class));

  Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  ClassPeer::newObjRealize(getClass(), this);
  ObjectPeer::setGRTObject(this, True);
  userInitialize();
}

FEMethod::FEMethod(const FEMethod& x) : Method(x)
{
  userCopy(x);
}

FEMethod& FEMethod::operator=(const FEMethod& x)
{
  *(Method *)this = Method::operator=((const Method &)x);
  userCopy(x);
  return *this;
}

FEMethod::FEMethod(const Struct *x, Bool share) : Method(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("fe_method") : FEMethod_Class));

  Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      ClassPeer::newObjRealize(getClass(), this);
    }

  ObjectPeer::setGRTObject(this, True);
  userCopy(*x);
}

FEMethod::FEMethod(const FEMethod *x, Bool share) : Method(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("fe_method") : FEMethod_Class));

  Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      ClassPeer::newObjRealize(getClass(), this);
    }

  ObjectPeer::setGRTObject(this, True);
  userCopy(*x);
}

static const Attribute **FEMethod_C_agritems;
static Size FEMethod_C_idr_objsz, FEMethod_C_idr_psize;

static StructClass *FEMethod_C_make(StructClass *FEMethod_C_class = 0, Schema *m = 0)
{
  if (!FEMethod_C_class)
    return new StructClass("fe_method_C", (m ? m->getClass("fe_method") : FEMethod_Class));
  Attribute *attr[5];

  FEMethod_C_class->setAttributes(&attr[5], 0);


  ClassPeer::setMType(FEMethod_C_class, Class::System);

  return FEMethod_C_class;
}

Object *FEMethod_C_construct_x(const Class *cls, Data idr)
{
  return new FEMethod_C(cls, idr);
}

Object *FEMethod_C_construct(const Object *o, Bool share)
{
  return new FEMethod_C((const Struct *)o, share);
}

static void FEMethod_C_init_p()
{
  FEMethod_C_Class = FEMethod_C_make();
  constructors_x[class_ind] = FEMethod_C_construct_x;
  constructors[class_ind] = FEMethod_C_construct;
  hash->insert("fe_method_C", class_ind++);
}

static void FEMethod_C_init()
{
  FEMethod_C_make(FEMethod_C_Class);

  FEMethod_C_agritems = FEMethod_C_Class->getAttributes();
  FEMethod_C_idr_objsz = FEMethod_C_Class->getIDRObjectSize(&FEMethod_C_idr_psize, 0);

  ObjectPeer::setUnrealizable(FEMethod_C_Class, True);
}

static Status FEMethod_C_attrcomp_realize(Database *db, Class *cls)
{
  AttributeComponent *comp;
  const Dataspace *dataspace;
  ClassComponent *clcomp;
  Status status;
  int *impl_hints;
  impl_hints = new int[8];
  impl_hints[0] = 0;
  impl_hints[1] = 0;
  impl_hints[2] = 0;
  impl_hints[3] = 0;
  impl_hints[4] = 0;
  impl_hints[5] = 0;
  impl_hints[6] = 0;
  impl_hints[7] = 0;
  dataspace = 0;;
  comp = new HashIndex(db, cls, "fe_method_C.ex.exname", False, True, dataspace, 0, 0, impl_hints, 8);
  delete [] impl_hints;
  cls->add(comp->getInd(), comp);

  impl_hints = new int[8];
  impl_hints[0] = 0;
  impl_hints[1] = 0;
  impl_hints[2] = 0;
  impl_hints[3] = 0;
  impl_hints[4] = 0;
  impl_hints[5] = 0;
  impl_hints[6] = 0;
  impl_hints[7] = 0;
  dataspace = 0;;
  comp = new HashIndex(db, cls, "fe_method_C.ex.intname", False, True, dataspace, 0, 0, impl_hints, 8);
  delete [] impl_hints;
  cls->add(comp->getInd(), comp);

  return Success;
}

FEMethod_C::FEMethod_C(Database *_db, const Dataspace *_dataspace) : FEMethod(_db, _dataspace, 1)
{
  initialize(_db);
}

FEMethod_C::FEMethod_C(const Class *_cls, Data _idr): FEMethod((Database *)0, (const Dataspace *)0, 1)
{
  setClass((Class *)_cls);

  Size idr_psize;
  Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  ClassPeer::newObjRealize(getClass(), this);
  ObjectPeer::setGRTObject(this, True);
  userInitialize();
}

void FEMethod_C::initialize(Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("fe_method_C") : FEMethod_C_Class));

  Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  ClassPeer::newObjRealize(getClass(), this);
  ObjectPeer::setGRTObject(this, True);
  userInitialize();
}

FEMethod_C::FEMethod_C(const FEMethod_C& x) : FEMethod(x)
{
  userCopy(x);
}

FEMethod_C& FEMethod_C::operator=(const FEMethod_C& x)
{
  *(FEMethod *)this = FEMethod::operator=((const FEMethod &)x);
  userCopy(x);
  return *this;
}

FEMethod_C::FEMethod_C(const Struct *x, Bool share) : FEMethod(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("fe_method_C") : FEMethod_C_Class));

  Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      ClassPeer::newObjRealize(getClass(), this);
    }

  ObjectPeer::setGRTObject(this, True);
  userCopy(*x);
}

FEMethod_C::FEMethod_C(const FEMethod_C *x, Bool share) : FEMethod(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("fe_method_C") : FEMethod_C_Class));

  Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      ClassPeer::newObjRealize(getClass(), this);
    }

  ObjectPeer::setGRTObject(this, True);
  userCopy(*x);
}

static const Attribute **BEMethod_agritems;
static Size BEMethod_idr_objsz, BEMethod_idr_psize;

static StructClass *BEMethod_make(StructClass *BEMethod_class = 0, Schema *m = 0)
{
  if (!BEMethod_class)
    return new StructClass("be_method", (m ? m->getClass("method") : Method_Class));
  Attribute *attr[5];

  BEMethod_class->setAttributes(&attr[5], 0);


  ClassPeer::setMType(BEMethod_class, Class::System);

  return BEMethod_class;
}

Object *BEMethod_construct_x(const Class *cls, Data idr)
{
  return new BEMethod(cls, idr);
}

Object *BEMethod_construct(const Object *o, Bool share)
{
  return new BEMethod((const Struct *)o, share);
}

static void BEMethod_init_p()
{
  BEMethod_Class = BEMethod_make();
  constructors_x[class_ind] = BEMethod_construct_x;
  constructors[class_ind] = BEMethod_construct;
  hash->insert("be_method", class_ind++);
}

static void BEMethod_init()
{
  BEMethod_make(BEMethod_Class);

  BEMethod_agritems = BEMethod_Class->getAttributes();
  BEMethod_idr_objsz = BEMethod_Class->getIDRObjectSize(&BEMethod_idr_psize, 0);

  ObjectPeer::setUnrealizable(BEMethod_Class, True);
}

static Status BEMethod_attrcomp_realize(Database *db, Class *cls)
{
  AttributeComponent *comp;
  const Dataspace *dataspace;
  ClassComponent *clcomp;
  Status status;
  int *impl_hints;
  impl_hints = new int[8];
  impl_hints[0] = 0;
  impl_hints[1] = 0;
  impl_hints[2] = 0;
  impl_hints[3] = 0;
  impl_hints[4] = 0;
  impl_hints[5] = 0;
  impl_hints[6] = 0;
  impl_hints[7] = 0;
  dataspace = 0;;
  comp = new HashIndex(db, cls, "be_method.ex.exname", False, True, dataspace, 0, 0, impl_hints, 8);
  delete [] impl_hints;
  cls->add(comp->getInd(), comp);

  impl_hints = new int[8];
  impl_hints[0] = 0;
  impl_hints[1] = 0;
  impl_hints[2] = 0;
  impl_hints[3] = 0;
  impl_hints[4] = 0;
  impl_hints[5] = 0;
  impl_hints[6] = 0;
  impl_hints[7] = 0;
  dataspace = 0;;
  comp = new HashIndex(db, cls, "be_method.ex.intname", False, True, dataspace, 0, 0, impl_hints, 8);
  delete [] impl_hints;
  cls->add(comp->getInd(), comp);

  return Success;
}

BEMethod::BEMethod(Database *_db, const Dataspace *_dataspace) : Method(_db, _dataspace, 1)
{
  initialize(_db);
}

BEMethod::BEMethod(const Class *_cls, Data _idr): Method((Database *)0, (const Dataspace *)0, 1)
{
  setClass((Class *)_cls);

  Size idr_psize;
  Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  ClassPeer::newObjRealize(getClass(), this);
  ObjectPeer::setGRTObject(this, True);
  userInitialize();
}

void BEMethod::initialize(Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("be_method") : BEMethod_Class));

  Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  ClassPeer::newObjRealize(getClass(), this);
  ObjectPeer::setGRTObject(this, True);
  userInitialize();
}

BEMethod::BEMethod(const BEMethod& x) : Method(x)
{
  userCopy(x);
}

BEMethod& BEMethod::operator=(const BEMethod& x)
{
  *(Method *)this = Method::operator=((const Method &)x);
  userCopy(x);
  return *this;
}

BEMethod::BEMethod(const Struct *x, Bool share) : Method(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("be_method") : BEMethod_Class));

  Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      ClassPeer::newObjRealize(getClass(), this);
    }

  ObjectPeer::setGRTObject(this, True);
  userCopy(*x);
}

BEMethod::BEMethod(const BEMethod *x, Bool share) : Method(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("be_method") : BEMethod_Class));

  Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      ClassPeer::newObjRealize(getClass(), this);
    }

  ObjectPeer::setGRTObject(this, True);
  userCopy(*x);
}

static const Attribute **BEMethod_C_agritems;
static Size BEMethod_C_idr_objsz, BEMethod_C_idr_psize;

static StructClass *BEMethod_C_make(StructClass *BEMethod_C_class = 0, Schema *m = 0)
{
  if (!BEMethod_C_class)
    return new StructClass("be_method_C", (m ? m->getClass("be_method") : BEMethod_Class));
  Attribute *attr[5];

  BEMethod_C_class->setAttributes(&attr[5], 0);


  ClassPeer::setMType(BEMethod_C_class, Class::System);

  return BEMethod_C_class;
}

Object *BEMethod_C_construct_x(const Class *cls, Data idr)
{
  return new BEMethod_C(cls, idr);
}

Object *BEMethod_C_construct(const Object *o, Bool share)
{
  return new BEMethod_C((const Struct *)o, share);
}

static void BEMethod_C_init_p()
{
  BEMethod_C_Class = BEMethod_C_make();
  constructors_x[class_ind] = BEMethod_C_construct_x;
  constructors[class_ind] = BEMethod_C_construct;
  hash->insert("be_method_C", class_ind++);
}

static void BEMethod_C_init()
{
  BEMethod_C_make(BEMethod_C_Class);

  BEMethod_C_agritems = BEMethod_C_Class->getAttributes();
  BEMethod_C_idr_objsz = BEMethod_C_Class->getIDRObjectSize(&BEMethod_C_idr_psize, 0);

  ObjectPeer::setUnrealizable(BEMethod_C_Class, True);
}

static Status BEMethod_C_attrcomp_realize(Database *db, Class *cls)
{
  AttributeComponent *comp;
  const Dataspace *dataspace;
  ClassComponent *clcomp;
  Status status;
  int *impl_hints;
  impl_hints = new int[8];
  impl_hints[0] = 0;
  impl_hints[1] = 0;
  impl_hints[2] = 0;
  impl_hints[3] = 0;
  impl_hints[4] = 0;
  impl_hints[5] = 0;
  impl_hints[6] = 0;
  impl_hints[7] = 0;
  dataspace = 0;;
  comp = new HashIndex(db, cls, "be_method_C.ex.exname", False, True, dataspace, 0, 0, impl_hints, 8);
  delete [] impl_hints;
  cls->add(comp->getInd(), comp);

  impl_hints = new int[8];
  impl_hints[0] = 0;
  impl_hints[1] = 0;
  impl_hints[2] = 0;
  impl_hints[3] = 0;
  impl_hints[4] = 0;
  impl_hints[5] = 0;
  impl_hints[6] = 0;
  impl_hints[7] = 0;
  dataspace = 0;;
  comp = new HashIndex(db, cls, "be_method_C.ex.intname", False, True, dataspace, 0, 0, impl_hints, 8);
  delete [] impl_hints;
  cls->add(comp->getInd(), comp);

  return Success;
}

BEMethod_C::BEMethod_C(Database *_db, const Dataspace *_dataspace) : BEMethod(_db, _dataspace, 1)
{
  initialize(_db);
}

BEMethod_C::BEMethod_C(const Class *_cls, Data _idr): BEMethod((Database *)0, (const Dataspace *)0, 1)
{
  setClass((Class *)_cls);

  Size idr_psize;
  Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  ClassPeer::newObjRealize(getClass(), this);
  ObjectPeer::setGRTObject(this, True);
  userInitialize();
}

void BEMethod_C::initialize(Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("be_method_C") : BEMethod_C_Class));

  Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  ClassPeer::newObjRealize(getClass(), this);
  ObjectPeer::setGRTObject(this, True);
  userInitialize();
}

BEMethod_C::BEMethod_C(const BEMethod_C& x) : BEMethod(x)
{
  userCopy(x);
}

BEMethod_C& BEMethod_C::operator=(const BEMethod_C& x)
{
  *(BEMethod *)this = BEMethod::operator=((const BEMethod &)x);
  userCopy(x);
  return *this;
}

BEMethod_C::BEMethod_C(const Struct *x, Bool share) : BEMethod(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("be_method_C") : BEMethod_C_Class));

  Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      ClassPeer::newObjRealize(getClass(), this);
    }

  ObjectPeer::setGRTObject(this, True);
  userCopy(*x);
}

BEMethod_C::BEMethod_C(const BEMethod_C *x, Bool share) : BEMethod(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("be_method_C") : BEMethod_C_Class));

  Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      ClassPeer::newObjRealize(getClass(), this);
    }

  ObjectPeer::setGRTObject(this, True);
  userCopy(*x);
}

static const Attribute **BEMethod_OQL_agritems;
static Size BEMethod_OQL_idr_objsz, BEMethod_OQL_idr_psize;

static StructClass *BEMethod_OQL_make(StructClass *BEMethod_OQL_class = 0, Schema *m = 0)
{
  if (!BEMethod_OQL_class)
    return new StructClass("be_method_OQL", (m ? m->getClass("be_method") : BEMethod_Class));
  Attribute *attr[5];

  BEMethod_OQL_class->setAttributes(&attr[5], 0);


  ClassPeer::setMType(BEMethod_OQL_class, Class::System);

  return BEMethod_OQL_class;
}

Object *BEMethod_OQL_construct_x(const Class *cls, Data idr)
{
  return new BEMethod_OQL(cls, idr);
}

Object *BEMethod_OQL_construct(const Object *o, Bool share)
{
  return new BEMethod_OQL((const Struct *)o, share);
}

static void BEMethod_OQL_init_p()
{
  BEMethod_OQL_Class = BEMethod_OQL_make();
  constructors_x[class_ind] = BEMethod_OQL_construct_x;
  constructors[class_ind] = BEMethod_OQL_construct;
  hash->insert("be_method_OQL", class_ind++);
}

static void BEMethod_OQL_init()
{
  BEMethod_OQL_make(BEMethod_OQL_Class);

  BEMethod_OQL_agritems = BEMethod_OQL_Class->getAttributes();
  BEMethod_OQL_idr_objsz = BEMethod_OQL_Class->getIDRObjectSize(&BEMethod_OQL_idr_psize, 0);

  ObjectPeer::setUnrealizable(BEMethod_OQL_Class, True);
}

static Status BEMethod_OQL_attrcomp_realize(Database *db, Class *cls)
{
  AttributeComponent *comp;
  const Dataspace *dataspace;
  ClassComponent *clcomp;
  Status status;
  int *impl_hints;
  impl_hints = new int[8];
  impl_hints[0] = 0;
  impl_hints[1] = 0;
  impl_hints[2] = 0;
  impl_hints[3] = 0;
  impl_hints[4] = 0;
  impl_hints[5] = 0;
  impl_hints[6] = 0;
  impl_hints[7] = 0;
  dataspace = 0;;
  comp = new HashIndex(db, cls, "be_method_OQL.ex.exname", False, True, dataspace, 0, 0, impl_hints, 8);
  delete [] impl_hints;
  cls->add(comp->getInd(), comp);

  impl_hints = new int[8];
  impl_hints[0] = 0;
  impl_hints[1] = 0;
  impl_hints[2] = 0;
  impl_hints[3] = 0;
  impl_hints[4] = 0;
  impl_hints[5] = 0;
  impl_hints[6] = 0;
  impl_hints[7] = 0;
  dataspace = 0;;
  comp = new HashIndex(db, cls, "be_method_OQL.ex.intname", False, True, dataspace, 0, 0, impl_hints, 8);
  delete [] impl_hints;
  cls->add(comp->getInd(), comp);

  return Success;
}

BEMethod_OQL::BEMethod_OQL(Database *_db, const Dataspace *_dataspace) : BEMethod(_db, _dataspace, 1)
{
  initialize(_db);
}

BEMethod_OQL::BEMethod_OQL(const Class *_cls, Data _idr): BEMethod((Database *)0, (const Dataspace *)0, 1)
{
  setClass((Class *)_cls);

  Size idr_psize;
  Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  ClassPeer::newObjRealize(getClass(), this);
  ObjectPeer::setGRTObject(this, True);
  userInitialize();
}

void BEMethod_OQL::initialize(Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("be_method_OQL") : BEMethod_OQL_Class));

  Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  ClassPeer::newObjRealize(getClass(), this);
  ObjectPeer::setGRTObject(this, True);
  userInitialize();
}

BEMethod_OQL::BEMethod_OQL(const BEMethod_OQL& x) : BEMethod(x)
{
  userCopy(x);
}

BEMethod_OQL& BEMethod_OQL::operator=(const BEMethod_OQL& x)
{
  *(BEMethod *)this = BEMethod::operator=((const BEMethod &)x);
  userCopy(x);
  return *this;
}

BEMethod_OQL::BEMethod_OQL(const Struct *x, Bool share) : BEMethod(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("be_method_OQL") : BEMethod_OQL_Class));

  Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      ClassPeer::newObjRealize(getClass(), this);
    }

  ObjectPeer::setGRTObject(this, True);
  userCopy(*x);
}

BEMethod_OQL::BEMethod_OQL(const BEMethod_OQL *x, Bool share) : BEMethod(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("be_method_OQL") : BEMethod_OQL_Class));

  Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      ClassPeer::newObjRealize(getClass(), this);
    }

  ObjectPeer::setGRTObject(this, True);
  userCopy(*x);
}

static const Attribute **Trigger_agritems;
static Size Trigger_idr_objsz, Trigger_idr_psize;

static StructClass *Trigger_make(StructClass *Trigger_class = 0, Schema *m = 0)
{
  if (!Trigger_class)
    return new StructClass("trigger", (m ? m->getClass("agregat_class_executable") : AgregatClassExecutable_Class));
  Attribute *attr[8];
  int *dims;

  dims = 0;
  attr[5] = new Attribute((m ? m->getClass("trigger_type") : TriggerType_Class), "type", False, 0, dims);

  dims = 0;
  attr[6] = new Attribute((m ? m->getClass("int") : Int32_Class), "light", False, 0, dims);

  dims = new int[1];
  dims[0] = 16;
  attr[7] = new Attribute((m ? m->getClass("char") : Char_Class), "suffix", False, 1, dims);
  delete[] dims;

  Trigger_class->setAttributes(&attr[5], 3);

  delete attr[5];
  delete attr[6];
  delete attr[7];

  ClassPeer::setMType(Trigger_class, Class::System);

  return Trigger_class;
}

Object *Trigger_construct_x(const Class *cls, Data idr)
{
  return new Trigger(cls, idr);
}

Object *Trigger_construct(const Object *o, Bool share)
{
  return new Trigger((const Struct *)o, share);
}

static void Trigger_init_p()
{
  Trigger_Class = Trigger_make();
  constructors_x[class_ind] = Trigger_construct_x;
  constructors[class_ind] = Trigger_construct;
  hash->insert("trigger", class_ind++);
}

static void Trigger_init()
{
  Trigger_make(Trigger_Class);

  Trigger_agritems = Trigger_Class->getAttributes();
  Trigger_idr_objsz = Trigger_Class->getIDRObjectSize(&Trigger_idr_psize, 0);

  ObjectPeer::setUnrealizable(Trigger_Class, True);
}

static Status Trigger_attrcomp_realize(Database *db, Class *cls)
{
  AttributeComponent *comp;
  const Dataspace *dataspace;
  ClassComponent *clcomp;
  Status status;
  int *impl_hints;
  impl_hints = new int[8];
  impl_hints[0] = 0;
  impl_hints[1] = 0;
  impl_hints[2] = 0;
  impl_hints[3] = 0;
  impl_hints[4] = 0;
  impl_hints[5] = 0;
  impl_hints[6] = 0;
  impl_hints[7] = 0;
  dataspace = 0;;
  comp = new HashIndex(db, cls, "trigger.ex.exname", False, True, dataspace, 0, 0, impl_hints, 8);
  delete [] impl_hints;
  cls->add(comp->getInd(), comp);

  impl_hints = new int[8];
  impl_hints[0] = 0;
  impl_hints[1] = 0;
  impl_hints[2] = 0;
  impl_hints[3] = 0;
  impl_hints[4] = 0;
  impl_hints[5] = 0;
  impl_hints[6] = 0;
  impl_hints[7] = 0;
  dataspace = 0;;
  comp = new HashIndex(db, cls, "trigger.ex.intname", False, True, dataspace, 0, 0, impl_hints, 8);
  delete [] impl_hints;
  cls->add(comp->getInd(), comp);

  return Success;
}

Trigger::Trigger(Database *_db, const Dataspace *_dataspace) : AgregatClassExecutable(_db, _dataspace, 1)
{
  initialize(_db);
}

Trigger::Trigger(const Class *_cls, Data _idr): AgregatClassExecutable((Database *)0, (const Dataspace *)0, 1)
{
  setClass((Class *)_cls);

  Size idr_psize;
  Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  ClassPeer::newObjRealize(getClass(), this);
  ObjectPeer::setGRTObject(this, True);
  userInitialize();
}

void Trigger::initialize(Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("trigger") : Trigger_Class));

  Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  ClassPeer::newObjRealize(getClass(), this);
  ObjectPeer::setGRTObject(this, True);
  userInitialize();
}

Trigger::Trigger(const Trigger& x) : AgregatClassExecutable(x)
{
  userCopy(x);
}

Trigger& Trigger::operator=(const Trigger& x)
{
  *(AgregatClassExecutable *)this = AgregatClassExecutable::operator=((const AgregatClassExecutable &)x);
  userCopy(x);
  return *this;
}

Trigger::Trigger(const Struct *x, Bool share) : AgregatClassExecutable(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("trigger") : Trigger_Class));

  Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      ClassPeer::newObjRealize(getClass(), this);
    }

  ObjectPeer::setGRTObject(this, True);
  userCopy(*x);
}

Trigger::Trigger(const Trigger *x, Bool share) : AgregatClassExecutable(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("trigger") : Trigger_Class));

  Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      ClassPeer::newObjRealize(getClass(), this);
    }

  ObjectPeer::setGRTObject(this, True);
  userCopy(*x);
}

Status Trigger::setType(TriggerType _type, Bool _check_value)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;
  eyedblib::int32 __tmp = _type;

  status = getClass()->getAttributes()[5]->setValue(this, (Data)&__tmp, 1, 0, _check_value);
  return status;
}

TriggerType Trigger::getType(Bool *isnull, Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int32 __tmp = 0;
  Status s;

  s = getClass()->getAttributes()[5]->getValue(this, (Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return (TriggerType)0;}
  return (TriggerType)__tmp;
}

Status Trigger::setLight(eyedblib::int32 _light)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;

  status = getClass()->getAttributes()[6]->setValue(this, (Data)&_light, 1, 0);
  return status;
}

eyedblib::int32 Trigger::getLight(Bool *isnull, Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int32 __tmp = 0;
  Status s;

  s = getClass()->getAttributes()[6]->getValue(this, (Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

Status Trigger::setSuffix(const char *_suffix)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;
  unsigned char data[16];
  Size len = ::strlen(_suffix);
  if (len >= 16)
    return Exception::make(IDB_ERROR, "string `%s' [%d] too long for attribute Trigger::suffix, maximum is 16\n", _suffix, len);
  memset(data, 0, 16);
  strncpy((char *)data, _suffix, min(15, len));
  status = getClass()->getAttributes()[7]->setValue(this, data, 16, 0);
  return status;

}

Status Trigger::setSuffix(unsigned int a0, char _suffix)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;
  Size from = a0;

  status = getClass()->getAttributes()[7]->setValue(this, (Data)&_suffix, 1, from);
  return status;
}

const char *Trigger::getSuffix(Bool *isnull, Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  Data data;
  Status s;

  s = getClass()->getAttributes()[7]->getValue(this, (Data *)&data, Attribute::directAccess, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return (const char *)data;
}

char Trigger::getSuffix(unsigned int a0, Bool *isnull, Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  char __tmp = 0;
  Status s;
  Size from = a0;

  s = getClass()->getAttributes()[7]->getValue(this, (Data *)&__tmp, 1, from, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

static const Attribute **UniqueConstraint_agritems;
static Size UniqueConstraint_idr_objsz, UniqueConstraint_idr_psize;

static StructClass *UniqueConstraint_make(StructClass *UniqueConstraint_class = 0, Schema *m = 0)
{
  if (!UniqueConstraint_class)
    return new StructClass("unique_constraint", (m ? m->getClass("attribute_component") : AttributeComponent_Class));
  Attribute *attr[6];

  UniqueConstraint_class->setAttributes(&attr[6], 0);


  ClassPeer::setMType(UniqueConstraint_class, Class::System);

  return UniqueConstraint_class;
}

Object *UniqueConstraint_construct_x(const Class *cls, Data idr)
{
  return new UniqueConstraint(cls, idr);
}

Object *UniqueConstraint_construct(const Object *o, Bool share)
{
  return new UniqueConstraint((const Struct *)o, share);
}

static void UniqueConstraint_init_p()
{
  UniqueConstraint_Class = UniqueConstraint_make();
  constructors_x[class_ind] = UniqueConstraint_construct_x;
  constructors[class_ind] = UniqueConstraint_construct;
  hash->insert("unique_constraint", class_ind++);
}

static void UniqueConstraint_init()
{
  UniqueConstraint_make(UniqueConstraint_Class);

  UniqueConstraint_agritems = UniqueConstraint_Class->getAttributes();
  UniqueConstraint_idr_objsz = UniqueConstraint_Class->getIDRObjectSize(&UniqueConstraint_idr_psize, 0);

  ObjectPeer::setUnrealizable(UniqueConstraint_Class, True);
}

static Status UniqueConstraint_attrcomp_realize(Database *db, Class *cls)
{
  return Success;
}

UniqueConstraint::UniqueConstraint(Database *_db, const Dataspace *_dataspace) : AttributeComponent(_db, _dataspace, 1)
{
  initialize(_db);
}

UniqueConstraint::UniqueConstraint(const Class *_cls, Data _idr): AttributeComponent((Database *)0, (const Dataspace *)0, 1)
{
  setClass((Class *)_cls);

  Size idr_psize;
  Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  ClassPeer::newObjRealize(getClass(), this);
  ObjectPeer::setGRTObject(this, True);
  userInitialize();
}

void UniqueConstraint::initialize(Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("unique_constraint") : UniqueConstraint_Class));

  Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  ClassPeer::newObjRealize(getClass(), this);
  ObjectPeer::setGRTObject(this, True);
  userInitialize();
}

UniqueConstraint::UniqueConstraint(const UniqueConstraint& x) : AttributeComponent(x)
{
  userCopy(x);
}

UniqueConstraint& UniqueConstraint::operator=(const UniqueConstraint& x)
{
  *(AttributeComponent *)this = AttributeComponent::operator=((const AttributeComponent &)x);
  userCopy(x);
  return *this;
}

UniqueConstraint::UniqueConstraint(const Struct *x, Bool share) : AttributeComponent(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("unique_constraint") : UniqueConstraint_Class));

  Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      ClassPeer::newObjRealize(getClass(), this);
    }

  ObjectPeer::setGRTObject(this, True);
  userCopy(*x);
}

UniqueConstraint::UniqueConstraint(const UniqueConstraint *x, Bool share) : AttributeComponent(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("unique_constraint") : UniqueConstraint_Class));

  Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      ClassPeer::newObjRealize(getClass(), this);
    }

  ObjectPeer::setGRTObject(this, True);
  userCopy(*x);
}

static const Attribute **NotNullConstraint_agritems;
static Size NotNullConstraint_idr_objsz, NotNullConstraint_idr_psize;

static StructClass *NotNullConstraint_make(StructClass *NotNullConstraint_class = 0, Schema *m = 0)
{
  if (!NotNullConstraint_class)
    return new StructClass("notnull_constraint", (m ? m->getClass("attribute_component") : AttributeComponent_Class));
  Attribute *attr[6];

  NotNullConstraint_class->setAttributes(&attr[6], 0);


  ClassPeer::setMType(NotNullConstraint_class, Class::System);

  return NotNullConstraint_class;
}

Object *NotNullConstraint_construct_x(const Class *cls, Data idr)
{
  return new NotNullConstraint(cls, idr);
}

Object *NotNullConstraint_construct(const Object *o, Bool share)
{
  return new NotNullConstraint((const Struct *)o, share);
}

static void NotNullConstraint_init_p()
{
  NotNullConstraint_Class = NotNullConstraint_make();
  constructors_x[class_ind] = NotNullConstraint_construct_x;
  constructors[class_ind] = NotNullConstraint_construct;
  hash->insert("notnull_constraint", class_ind++);
}

static void NotNullConstraint_init()
{
  NotNullConstraint_make(NotNullConstraint_Class);

  NotNullConstraint_agritems = NotNullConstraint_Class->getAttributes();
  NotNullConstraint_idr_objsz = NotNullConstraint_Class->getIDRObjectSize(&NotNullConstraint_idr_psize, 0);

  ObjectPeer::setUnrealizable(NotNullConstraint_Class, True);
}

static Status NotNullConstraint_attrcomp_realize(Database *db, Class *cls)
{
  return Success;
}

NotNullConstraint::NotNullConstraint(Database *_db, const Dataspace *_dataspace) : AttributeComponent(_db, _dataspace, 1)
{
  initialize(_db);
}

NotNullConstraint::NotNullConstraint(const Class *_cls, Data _idr): AttributeComponent((Database *)0, (const Dataspace *)0, 1)
{
  setClass((Class *)_cls);

  Size idr_psize;
  Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  ClassPeer::newObjRealize(getClass(), this);
  ObjectPeer::setGRTObject(this, True);
  userInitialize();
}

void NotNullConstraint::initialize(Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("notnull_constraint") : NotNullConstraint_Class));

  Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  ClassPeer::newObjRealize(getClass(), this);
  ObjectPeer::setGRTObject(this, True);
  userInitialize();
}

NotNullConstraint::NotNullConstraint(const NotNullConstraint& x) : AttributeComponent(x)
{
  userCopy(x);
}

NotNullConstraint& NotNullConstraint::operator=(const NotNullConstraint& x)
{
  *(AttributeComponent *)this = AttributeComponent::operator=((const AttributeComponent &)x);
  userCopy(x);
  return *this;
}

NotNullConstraint::NotNullConstraint(const Struct *x, Bool share) : AttributeComponent(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("notnull_constraint") : NotNullConstraint_Class));

  Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      ClassPeer::newObjRealize(getClass(), this);
    }

  ObjectPeer::setGRTObject(this, True);
  userCopy(*x);
}

NotNullConstraint::NotNullConstraint(const NotNullConstraint *x, Bool share) : AttributeComponent(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("notnull_constraint") : NotNullConstraint_Class));

  Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      ClassPeer::newObjRealize(getClass(), this);
    }

  ObjectPeer::setGRTObject(this, True);
  userCopy(*x);
}

static const Attribute **CardinalityDescription_agritems;
static Size CardinalityDescription_idr_objsz, CardinalityDescription_idr_psize;

static StructClass *CardinalityDescription_make(StructClass *CardinalityDescription_class = 0, Schema *m = 0)
{
  if (!CardinalityDescription_class)
    return new StructClass("cardinality_description", (m ? m->getClass("struct") : Struct_Class));
  Attribute *attr[6];
  int *dims;

  dims = 0;
  attr[2] = new Attribute((m ? m->getClass("int") : Int32_Class), "bottom", False, 0, dims);

  dims = 0;
  attr[3] = new Attribute((m ? m->getClass("int") : Int32_Class), "bottom_excl", False, 0, dims);

  dims = 0;
  attr[4] = new Attribute((m ? m->getClass("int") : Int32_Class), "top", False, 0, dims);

  dims = 0;
  attr[5] = new Attribute((m ? m->getClass("int") : Int32_Class), "top_excl", False, 0, dims);

  CardinalityDescription_class->setAttributes(&attr[2], 4);

  delete attr[2];
  delete attr[3];
  delete attr[4];
  delete attr[5];

  ClassPeer::setMType(CardinalityDescription_class, Class::System);

  return CardinalityDescription_class;
}

Object *CardinalityDescription_construct_x(const Class *cls, Data idr)
{
  return new CardinalityDescription(cls, idr);
}

Object *CardinalityDescription_construct(const Object *o, Bool share)
{
  return new CardinalityDescription((const Struct *)o, share);
}

static void CardinalityDescription_init_p()
{
  CardinalityDescription_Class = CardinalityDescription_make();
  constructors_x[class_ind] = CardinalityDescription_construct_x;
  constructors[class_ind] = CardinalityDescription_construct;
  hash->insert("cardinality_description", class_ind++);
}

static void CardinalityDescription_init()
{
  CardinalityDescription_make(CardinalityDescription_Class);

  CardinalityDescription_agritems = CardinalityDescription_Class->getAttributes();
  CardinalityDescription_idr_objsz = CardinalityDescription_Class->getIDRObjectSize(&CardinalityDescription_idr_psize, 0);

  ObjectPeer::setUnrealizable(CardinalityDescription_Class, True);
}

static Status CardinalityDescription_attrcomp_realize(Database *db, Class *cls)
{
  return Success;
}

CardinalityDescription::CardinalityDescription(Database *_db, const Dataspace *_dataspace) : Struct(_db, _dataspace)
{
  initialize(_db);
}

CardinalityDescription::CardinalityDescription(const Class *_cls, Data _idr)
{
  setClass((Class *)_cls);

  Size idr_psize;
  Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  ClassPeer::newObjRealize(getClass(), this);
  ObjectPeer::setGRTObject(this, True);
  userInitialize();
}

void CardinalityDescription::initialize(Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("cardinality_description") : CardinalityDescription_Class));

  Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  ClassPeer::newObjRealize(getClass(), this);
  ObjectPeer::setGRTObject(this, True);
  userInitialize();
}

CardinalityDescription::CardinalityDescription(const CardinalityDescription& x) : Struct(x)
{
  userCopy(x);
}

CardinalityDescription& CardinalityDescription::operator=(const CardinalityDescription& x)
{
  *(Struct *)this = Struct::operator=((const Struct &)x);
  userCopy(x);
  return *this;
}

CardinalityDescription::CardinalityDescription(const Struct *x, Bool share) : Struct(x, share)
{
  setClass((db ? db->getSchema()->getClass("cardinality_description") : CardinalityDescription_Class));

  Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      ClassPeer::newObjRealize(getClass(), this);
    }

  ObjectPeer::setGRTObject(this, True);
  userCopy(*x);
}

CardinalityDescription::CardinalityDescription(const CardinalityDescription *x, Bool share) : Struct(x, share)
{
  setClass((db ? db->getSchema()->getClass("cardinality_description") : CardinalityDescription_Class));

  Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      ClassPeer::newObjRealize(getClass(), this);
    }

  ObjectPeer::setGRTObject(this, True);
  userCopy(*x);
}

Status CardinalityDescription::setBottom(eyedblib::int32 _bottom)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;

  status = getClass()->getAttributes()[2]->setValue(this, (Data)&_bottom, 1, 0);
  return status;
}

eyedblib::int32 CardinalityDescription::getBottom(Bool *isnull, Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int32 __tmp = 0;
  Status s;

  s = getClass()->getAttributes()[2]->getValue(this, (Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

Status CardinalityDescription::setBottomExcl(eyedblib::int32 _bottom_excl)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;

  status = getClass()->getAttributes()[3]->setValue(this, (Data)&_bottom_excl, 1, 0);
  return status;
}

eyedblib::int32 CardinalityDescription::getBottomExcl(Bool *isnull, Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int32 __tmp = 0;
  Status s;

  s = getClass()->getAttributes()[3]->getValue(this, (Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

Status CardinalityDescription::setTop(eyedblib::int32 _top)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;

  status = getClass()->getAttributes()[4]->setValue(this, (Data)&_top, 1, 0);
  return status;
}

eyedblib::int32 CardinalityDescription::getTop(Bool *isnull, Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int32 __tmp = 0;
  Status s;

  s = getClass()->getAttributes()[4]->getValue(this, (Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

Status CardinalityDescription::setTopExcl(eyedblib::int32 _top_excl)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;

  status = getClass()->getAttributes()[5]->setValue(this, (Data)&_top_excl, 1, 0);
  return status;
}

eyedblib::int32 CardinalityDescription::getTopExcl(Bool *isnull, Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int32 __tmp = 0;
  Status s;

  s = getClass()->getAttributes()[5]->getValue(this, (Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

static const Attribute **CardinalityConstraint_agritems;
static Size CardinalityConstraint_idr_objsz, CardinalityConstraint_idr_psize;

static StructClass *CardinalityConstraint_make(StructClass *CardinalityConstraint_class = 0, Schema *m = 0)
{
  if (!CardinalityConstraint_class)
    return new StructClass("cardinality_constraint", (m ? m->getClass("agregat_class_component") : AgregatClassComponent_Class));
  Attribute *attr[6];
  int *dims;

  dims = new int[1];
  dims[0] = -1;
  attr[4] = new Attribute((m ? m->getClass("char") : Char_Class), "attrname", False, 1, dims);
  delete[] dims;

  dims = 0;
  attr[5] = new Attribute((m ? m->getClass("cardinality_description") : CardinalityDescription_Class), "card_desc", False, 0, dims);

  CardinalityConstraint_class->setAttributes(&attr[4], 2);

  delete attr[4];
  delete attr[5];

  ClassPeer::setMType(CardinalityConstraint_class, Class::System);

  return CardinalityConstraint_class;
}

Object *CardinalityConstraint_construct_x(const Class *cls, Data idr)
{
  return new CardinalityConstraint(cls, idr);
}

Object *CardinalityConstraint_construct(const Object *o, Bool share)
{
  return new CardinalityConstraint((const Struct *)o, share);
}

static void CardinalityConstraint_init_p()
{
  CardinalityConstraint_Class = CardinalityConstraint_make();
  constructors_x[class_ind] = CardinalityConstraint_construct_x;
  constructors[class_ind] = CardinalityConstraint_construct;
  hash->insert("cardinality_constraint", class_ind++);
}

static void CardinalityConstraint_init()
{
  CardinalityConstraint_make(CardinalityConstraint_Class);

  CardinalityConstraint_agritems = CardinalityConstraint_Class->getAttributes();
  CardinalityConstraint_idr_objsz = CardinalityConstraint_Class->getIDRObjectSize(&CardinalityConstraint_idr_psize, 0);

  ObjectPeer::setUnrealizable(CardinalityConstraint_Class, True);
}

static Status CardinalityConstraint_attrcomp_realize(Database *db, Class *cls)
{
  return Success;
}

CardinalityConstraint::CardinalityConstraint(Database *_db, const Dataspace *_dataspace) : AgregatClassComponent(_db, _dataspace, 1)
{
  initialize(_db);
}

CardinalityConstraint::CardinalityConstraint(const Class *_cls, Data _idr): AgregatClassComponent((Database *)0, (const Dataspace *)0, 1)
{
  setClass((Class *)_cls);

  Size idr_psize;
  Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  ClassPeer::newObjRealize(getClass(), this);
  ObjectPeer::setGRTObject(this, True);
  userInitialize();
}

void CardinalityConstraint::initialize(Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("cardinality_constraint") : CardinalityConstraint_Class));

  Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  ClassPeer::newObjRealize(getClass(), this);
  ObjectPeer::setGRTObject(this, True);
  userInitialize();
}

CardinalityConstraint::CardinalityConstraint(const CardinalityConstraint& x) : AgregatClassComponent(x)
{
  userCopy(x);
}

CardinalityConstraint& CardinalityConstraint::operator=(const CardinalityConstraint& x)
{
  *(AgregatClassComponent *)this = AgregatClassComponent::operator=((const AgregatClassComponent &)x);
  userCopy(x);
  return *this;
}

CardinalityConstraint::CardinalityConstraint(const Struct *x, Bool share) : AgregatClassComponent(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("cardinality_constraint") : CardinalityConstraint_Class));

  Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      ClassPeer::newObjRealize(getClass(), this);
    }

  ObjectPeer::setGRTObject(this, True);
  userCopy(*x);
}

CardinalityConstraint::CardinalityConstraint(const CardinalityConstraint *x, Bool share) : AgregatClassComponent(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("cardinality_constraint") : CardinalityConstraint_Class));

  Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      ClassPeer::newObjRealize(getClass(), this);
    }

  ObjectPeer::setGRTObject(this, True);
  userCopy(*x);
}

Status CardinalityConstraint::setAttrname(const char *_attrname)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;
  Size size;
  Size len = ::strlen(_attrname) + 1;

  status = getClass()->getAttributes()[4]->getSize(this, size);
  if (status)
    return status;

  if (size != len)
    status = getClass()->getAttributes()[4]->setSize(this, len);
  if (status)
    return status;

  status = getClass()->getAttributes()[4]->setValue(this, (Data)_attrname, len, 0);
  return status;

}

Status CardinalityConstraint::setAttrname(unsigned int a0, char _attrname)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;
  Size from = a0;

  Size size;
  status = getClass()->getAttributes()[4]->getSize(this, size);
  if (status)
    return status;

  if (size <= from)
    status = getClass()->getAttributes()[4]->setSize(this, from+1);
  if (status)
    return status;

  status = getClass()->getAttributes()[4]->setValue(this, (Data)&_attrname, 1, from);
  return status;
}

const char *CardinalityConstraint::getAttrname(Bool *isnull, Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  Data data;
  Status s;

  s = getClass()->getAttributes()[4]->getValue(this, (Data *)&data, Attribute::directAccess, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  if (!data) data = nulldata;
  return (const char *)data;
}

char CardinalityConstraint::getAttrname(unsigned int a0, Bool *isnull, Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  char __tmp = 0;
  Status s;
  Size from = a0;

  s = getClass()->getAttributes()[4]->getValue(this, (Data *)&__tmp, 1, from, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

Status CardinalityConstraint::setCardDesc(CardinalityDescription *_card_desc)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;

  status = getClass()->getAttributes()[5]->setValue(this, (Data)&_card_desc, 1, 0);
  return status;
}

const CardinalityDescription *CardinalityConstraint::getCardDesc(Bool *isnull, Status *rs) const 
{
  gbxAutoGarbSuspender _gbxsusp_;
  Object *__o = 0, *__go;
  Status s;

  s = getClass()->getAttributes()[5]->getValue(this, (Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (ObjectPeer::isGRTObject(__o)) {
       return (CardinalityDescription *)__o;
     }
     __go = (CardinalityDescription *)make_object(__o, False);
     if (__go)
      {
       __o = __go;;
       s = getClass()->getAttributes()[5]->setValue((Agregat *)this, (Data)&__o, 1, 0);
       ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
    }
  return (CardinalityDescription *)__o;
}

CardinalityDescription *CardinalityConstraint::getCardDesc(Bool *isnull, Status *rs) 
{
  gbxAutoGarbSuspender _gbxsusp_;
  Object *__o = 0, *__go;
  Status s;

  s = getClass()->getAttributes()[5]->getValue(this, (Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (ObjectPeer::isGRTObject(__o)) {
       return (CardinalityDescription *)__o;
     }
     __go = (CardinalityDescription *)make_object(__o, False);
     if (__go)
      {
       __o = __go;;
       s = getClass()->getAttributes()[5]->setValue((Agregat *)this, (Data)&__o, 1, 0);
       ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
    }
  return (CardinalityDescription *)__o;
}

static const Attribute **CardinalityConstraint_Test_agritems;
static Size CardinalityConstraint_Test_idr_objsz, CardinalityConstraint_Test_idr_psize;

static StructClass *CardinalityConstraint_Test_make(StructClass *CardinalityConstraint_Test_class = 0, Schema *m = 0)
{
  if (!CardinalityConstraint_Test_class)
    return new StructClass("cardinality_constraint_test", (m ? m->getClass("attribute_component") : AttributeComponent_Class));
  Attribute *attr[7];
  int *dims;

  dims = 0;
  attr[6] = new Attribute((m ? m->getClass("cardinality_description") : CardinalityDescription_Class), "card_desc", False, 0, dims);

  CardinalityConstraint_Test_class->setAttributes(&attr[6], 1);

  delete attr[6];

  ClassPeer::setMType(CardinalityConstraint_Test_class, Class::System);

  return CardinalityConstraint_Test_class;
}

Object *CardinalityConstraint_Test_construct_x(const Class *cls, Data idr)
{
  return new CardinalityConstraint_Test(cls, idr);
}

Object *CardinalityConstraint_Test_construct(const Object *o, Bool share)
{
  return new CardinalityConstraint_Test((const Struct *)o, share);
}

static void CardinalityConstraint_Test_init_p()
{
  CardinalityConstraint_Test_Class = CardinalityConstraint_Test_make();
  constructors_x[class_ind] = CardinalityConstraint_Test_construct_x;
  constructors[class_ind] = CardinalityConstraint_Test_construct;
  hash->insert("cardinality_constraint_test", class_ind++);
}

static void CardinalityConstraint_Test_init()
{
  CardinalityConstraint_Test_make(CardinalityConstraint_Test_Class);

  CardinalityConstraint_Test_agritems = CardinalityConstraint_Test_Class->getAttributes();
  CardinalityConstraint_Test_idr_objsz = CardinalityConstraint_Test_Class->getIDRObjectSize(&CardinalityConstraint_Test_idr_psize, 0);

  ObjectPeer::setUnrealizable(CardinalityConstraint_Test_Class, True);
}

static Status CardinalityConstraint_Test_attrcomp_realize(Database *db, Class *cls)
{
  return Success;
}

CardinalityConstraint_Test::CardinalityConstraint_Test(Database *_db, const Dataspace *_dataspace) : AttributeComponent(_db, _dataspace, 1)
{
  initialize(_db);
}

CardinalityConstraint_Test::CardinalityConstraint_Test(const Class *_cls, Data _idr): AttributeComponent((Database *)0, (const Dataspace *)0, 1)
{
  setClass((Class *)_cls);

  Size idr_psize;
  Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  ClassPeer::newObjRealize(getClass(), this);
  ObjectPeer::setGRTObject(this, True);
  userInitialize();
}

void CardinalityConstraint_Test::initialize(Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("cardinality_constraint_test") : CardinalityConstraint_Test_Class));

  Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  ClassPeer::newObjRealize(getClass(), this);
  ObjectPeer::setGRTObject(this, True);
  userInitialize();
}

CardinalityConstraint_Test::CardinalityConstraint_Test(const CardinalityConstraint_Test& x) : AttributeComponent(x)
{
  userCopy(x);
}

CardinalityConstraint_Test& CardinalityConstraint_Test::operator=(const CardinalityConstraint_Test& x)
{
  *(AttributeComponent *)this = AttributeComponent::operator=((const AttributeComponent &)x);
  userCopy(x);
  return *this;
}

CardinalityConstraint_Test::CardinalityConstraint_Test(const Struct *x, Bool share) : AttributeComponent(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("cardinality_constraint_test") : CardinalityConstraint_Test_Class));

  Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      ClassPeer::newObjRealize(getClass(), this);
    }

  ObjectPeer::setGRTObject(this, True);
  userCopy(*x);
}

CardinalityConstraint_Test::CardinalityConstraint_Test(const CardinalityConstraint_Test *x, Bool share) : AttributeComponent(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("cardinality_constraint_test") : CardinalityConstraint_Test_Class));

  Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      ClassPeer::newObjRealize(getClass(), this);
    }

  ObjectPeer::setGRTObject(this, True);
  userCopy(*x);
}

Status CardinalityConstraint_Test::setCardDesc(CardinalityDescription *_card_desc)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;

  status = getClass()->getAttributes()[6]->setValue(this, (Data)&_card_desc, 1, 0);
  return status;
}

const CardinalityDescription *CardinalityConstraint_Test::getCardDesc(Bool *isnull, Status *rs) const 
{
  gbxAutoGarbSuspender _gbxsusp_;
  Object *__o = 0, *__go;
  Status s;

  s = getClass()->getAttributes()[6]->getValue(this, (Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (ObjectPeer::isGRTObject(__o)) {
       return (CardinalityDescription *)__o;
     }
     __go = (CardinalityDescription *)make_object(__o, False);
     if (__go)
      {
       __o = __go;;
       s = getClass()->getAttributes()[6]->setValue((Agregat *)this, (Data)&__o, 1, 0);
       ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
    }
  return (CardinalityDescription *)__o;
}

CardinalityDescription *CardinalityConstraint_Test::getCardDesc(Bool *isnull, Status *rs) 
{
  gbxAutoGarbSuspender _gbxsusp_;
  Object *__o = 0, *__go;
  Status s;

  s = getClass()->getAttributes()[6]->getValue(this, (Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (ObjectPeer::isGRTObject(__o)) {
       return (CardinalityDescription *)__o;
     }
     __go = (CardinalityDescription *)make_object(__o, False);
     if (__go)
      {
       __o = __go;;
       s = getClass()->getAttributes()[6]->setValue((Agregat *)this, (Data)&__o, 1, 0);
       ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
    }
  return (CardinalityDescription *)__o;
}

static const Attribute **ProtectionUser_agritems;
static Size ProtectionUser_idr_objsz, ProtectionUser_idr_psize;

static StructClass *ProtectionUser_make(StructClass *ProtectionUser_class = 0, Schema *m = 0)
{
  if (!ProtectionUser_class)
    return new StructClass("protection_user", (m ? m->getClass("struct") : Struct_Class));
  Attribute *attr[4];
  int *dims;

  dims = 0;
  attr[2] = new Attribute((m ? m->getClass("object") : Object_Class), "user", True, 0, dims);

  dims = 0;
  attr[3] = new Attribute((m ? m->getClass("protection_mode") : ProtectionMode_Class), "mode", False, 0, dims);

  ProtectionUser_class->setAttributes(&attr[2], 2);

  delete attr[2];
  delete attr[3];

  ClassPeer::setMType(ProtectionUser_class, Class::System);

  return ProtectionUser_class;
}

Object *ProtectionUser_construct_x(const Class *cls, Data idr)
{
  return new ProtectionUser(cls, idr);
}

Object *ProtectionUser_construct(const Object *o, Bool share)
{
  return new ProtectionUser((const Struct *)o, share);
}

static void ProtectionUser_init_p()
{
  ProtectionUser_Class = ProtectionUser_make();
  constructors_x[class_ind] = ProtectionUser_construct_x;
  constructors[class_ind] = ProtectionUser_construct;
  hash->insert("protection_user", class_ind++);
}

static void ProtectionUser_init()
{
  ProtectionUser_make(ProtectionUser_Class);

  ProtectionUser_agritems = ProtectionUser_Class->getAttributes();
  ProtectionUser_idr_objsz = ProtectionUser_Class->getIDRObjectSize(&ProtectionUser_idr_psize, 0);

  ObjectPeer::setUnrealizable(ProtectionUser_Class, True);
}

static Status ProtectionUser_attrcomp_realize(Database *db, Class *cls)
{
  return Success;
}

ProtectionUser::ProtectionUser(Database *_db, const Dataspace *_dataspace) : Struct(_db, _dataspace)
{
  initialize(_db);
}

ProtectionUser::ProtectionUser(const Class *_cls, Data _idr)
{
  setClass((Class *)_cls);

  Size idr_psize;
  Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  ClassPeer::newObjRealize(getClass(), this);
  ObjectPeer::setGRTObject(this, True);
  userInitialize();
}

void ProtectionUser::initialize(Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("protection_user") : ProtectionUser_Class));

  Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  ClassPeer::newObjRealize(getClass(), this);
  ObjectPeer::setGRTObject(this, True);
  userInitialize();
}

ProtectionUser::ProtectionUser(const ProtectionUser& x) : Struct(x)
{
  userCopy(x);
}

ProtectionUser& ProtectionUser::operator=(const ProtectionUser& x)
{
  *(Struct *)this = Struct::operator=((const Struct &)x);
  userCopy(x);
  return *this;
}

ProtectionUser::ProtectionUser(const Struct *x, Bool share) : Struct(x, share)
{
  setClass((db ? db->getSchema()->getClass("protection_user") : ProtectionUser_Class));

  Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      ClassPeer::newObjRealize(getClass(), this);
    }

  ObjectPeer::setGRTObject(this, True);
  userCopy(*x);
}

ProtectionUser::ProtectionUser(const ProtectionUser *x, Bool share) : Struct(x, share)
{
  setClass((db ? db->getSchema()->getClass("protection_user") : ProtectionUser_Class));

  Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      ClassPeer::newObjRealize(getClass(), this);
    }

  ObjectPeer::setGRTObject(this, True);
  userCopy(*x);
}

Status ProtectionUser::setUser(Object *_user)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;

  status = getClass()->getAttributes()[2]->setValue(this, (Data)&_user, 1, 0);
  return status;
}

const Object *ProtectionUser::getUser(Bool *isnull, Status *rs) const 
{
  gbxAutoGarbSuspender _gbxsusp_;
  Object *__o = 0, *__go;
  Status s;

  s = getClass()->getAttributes()[2]->getValue(this, (Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (ObjectPeer::isGRTObject(__o)) {
       return (Object *)__o;
     }
     __go = (Object *)make_object(__o, False);
     if (__go)
      {
       __o = __go;
       s = getClass()->getAttributes()[2]->setValue((Agregat *)this, (Data)&__o, 1, 0);
       ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
     return (Object *)__o;
    }

  Bool wasnull = (!__o ? True : False);
  if (!__o && db)
    {
      Oid toid;
      s = getClass()->getAttributes()[2]->getOid(this, &toid, 1, 0);
      if (s) {if (rs) *rs = s; return 0;}
      if (toid.isValid())
        {
          s = db->loadObject(&toid, &__o);
          if (s) {if (rs) *rs = s; return 0;}
          if (!ObjectPeer::isGRTObject(__o))
           {
             __go = (Object *)make_object(__o, False);
             if (__go) __o = __go;
           }
        }
    }

  if (__o && wasnull)
    {
     s = getClass()->getAttributes()[2]->setValue((Agregat *)this, (Data)&__o, 1, 0);
     if (s) {if (rs) *rs = s; return 0;}
     __o->release();
    }
  return (Object *)__o;
}

Object *ProtectionUser::getUser(Bool *isnull, Status *rs) 
{
  gbxAutoGarbSuspender _gbxsusp_;
  Object *__o = 0, *__go;
  Status s;

  s = getClass()->getAttributes()[2]->getValue(this, (Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (ObjectPeer::isGRTObject(__o)) {
       return (Object *)__o;
     }
     __go = (Object *)make_object(__o, False);
     if (__go)
      {
       __o = __go;
       s = getClass()->getAttributes()[2]->setValue((Agregat *)this, (Data)&__o, 1, 0);
       ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
     return (Object *)__o;
    }

  Bool wasnull = (!__o ? True : False);
  if (!__o && db)
    {
      Oid toid;
      s = getClass()->getAttributes()[2]->getOid(this, &toid, 1, 0);
      if (s) {if (rs) *rs = s; return 0;}
      if (toid.isValid())
        {
          s = db->loadObject(&toid, &__o);
          if (s) {if (rs) *rs = s; return 0;}
          if (!ObjectPeer::isGRTObject(__o))
           {
             __go = (Object *)make_object(__o, False);
             if (__go) __o = __go;
           }
        }
    }

  if (__o && wasnull)
    {
     s = getClass()->getAttributes()[2]->setValue((Agregat *)this, (Data)&__o, 1, 0);
     if (s) {if (rs) *rs = s; return 0;}
     __o->release();
    }
  return (Object *)__o;
}

Status ProtectionUser::setUserOid(const Oid &_oid)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;

  status = getClass()->getAttributes()[2]->setOid(this, &_oid, 1, 0, oid_check);
  return status;
}

Oid ProtectionUser::getUserOid(Status *rs) 
{
  gbxAutoGarbSuspender _gbxsusp_;
  Oid __tmp;
  Status s;

  s = getClass()->getAttributes()[2]->getOid(this, &__tmp, 1, 0);
  if (s) {if (rs) *rs = s; return nulloid;}

  return __tmp;
}

Status ProtectionUser::setMode(ProtectionMode _mode, Bool _check_value)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;
  eyedblib::int32 __tmp = _mode;

  status = getClass()->getAttributes()[3]->setValue(this, (Data)&__tmp, 1, 0, _check_value);
  return status;
}

ProtectionMode ProtectionUser::getMode(Bool *isnull, Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int32 __tmp = 0;
  Status s;

  s = getClass()->getAttributes()[3]->getValue(this, (Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return (ProtectionMode)0;}
  return (ProtectionMode)__tmp;
}

static const Attribute **Protection_agritems;
static Size Protection_idr_objsz, Protection_idr_psize;

static StructClass *Protection_make(StructClass *Protection_class = 0, Schema *m = 0)
{
  if (!Protection_class)
    return new StructClass("protection", (m ? m->getClass("struct") : Struct_Class));
  Attribute *attr[5];
  int *dims;

  dims = new int[1];
  dims[0] = -1;
  attr[2] = new Attribute((m ? m->getClass("char") : Char_Class), "name", False, 1, dims);
  delete[] dims;

  dims = new int[1];
  dims[0] = -1;
  attr[3] = new Attribute((m ? m->getClass("protection_user") : ProtectionUser_Class), "pusers", False, 1, dims);
  delete[] dims;

  dims = 0;
  attr[4] = new Attribute((m ? m->getClass("oid") : OidP_Class), "poid", False, 0, dims);

  Protection_class->setAttributes(&attr[2], 3);

  delete attr[2];
  delete attr[3];
  delete attr[4];

  ClassPeer::setMType(Protection_class, Class::System);

  return Protection_class;
}

Object *Protection_construct_x(const Class *cls, Data idr)
{
  return new Protection(cls, idr);
}

Object *Protection_construct(const Object *o, Bool share)
{
  return new Protection((const Struct *)o, share);
}

static void Protection_init_p()
{
  Protection_Class = Protection_make();
  constructors_x[class_ind] = Protection_construct_x;
  constructors[class_ind] = Protection_construct;
  hash->insert("protection", class_ind++);
}

static void Protection_init()
{
  Protection_make(Protection_Class);

  Protection_agritems = Protection_Class->getAttributes();
  Protection_idr_objsz = Protection_Class->getIDRObjectSize(&Protection_idr_psize, 0);

  ObjectPeer::setUnrealizable(Protection_Class, True);
}

static Status Protection_attrcomp_realize(Database *db, Class *cls)
{
  return Success;
}

Protection::Protection(Database *_db, const Dataspace *_dataspace) : Struct(_db, _dataspace)
{
  initialize(_db);
}

Protection::Protection(const Class *_cls, Data _idr)
{
  setClass((Class *)_cls);

  Size idr_psize;
  Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  ClassPeer::newObjRealize(getClass(), this);
  ObjectPeer::setGRTObject(this, True);
  userInitialize();
}

void Protection::initialize(Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("protection") : Protection_Class));

  Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  ClassPeer::newObjRealize(getClass(), this);
  ObjectPeer::setGRTObject(this, True);
  userInitialize();
}

Protection::Protection(const Protection& x) : Struct(x)
{
  userCopy(x);
}

Protection& Protection::operator=(const Protection& x)
{
  *(Struct *)this = Struct::operator=((const Struct &)x);
  userCopy(x);
  return *this;
}

Protection::Protection(const Struct *x, Bool share) : Struct(x, share)
{
  setClass((db ? db->getSchema()->getClass("protection") : Protection_Class));

  Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      ClassPeer::newObjRealize(getClass(), this);
    }

  ObjectPeer::setGRTObject(this, True);
  userCopy(*x);
}

Protection::Protection(const Protection *x, Bool share) : Struct(x, share)
{
  setClass((db ? db->getSchema()->getClass("protection") : Protection_Class));

  Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      ClassPeer::newObjRealize(getClass(), this);
    }

  ObjectPeer::setGRTObject(this, True);
  userCopy(*x);
}

Status Protection::setName(const char *_name)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;
  Size size;
  Size len = ::strlen(_name) + 1;

  status = getClass()->getAttributes()[2]->getSize(this, size);
  if (status)
    return status;

  if (size != len)
    status = getClass()->getAttributes()[2]->setSize(this, len);
  if (status)
    return status;

  status = getClass()->getAttributes()[2]->setValue(this, (Data)_name, len, 0);
  return status;

}

Status Protection::setName(unsigned int a0, char _name)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;
  Size from = a0;

  Size size;
  status = getClass()->getAttributes()[2]->getSize(this, size);
  if (status)
    return status;

  if (size <= from)
    status = getClass()->getAttributes()[2]->setSize(this, from+1);
  if (status)
    return status;

  status = getClass()->getAttributes()[2]->setValue(this, (Data)&_name, 1, from);
  return status;
}

const char *Protection::getName(Bool *isnull, Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  Data data;
  Status s;

  s = getClass()->getAttributes()[2]->getValue(this, (Data *)&data, Attribute::directAccess, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  if (!data) data = nulldata;
  return (const char *)data;
}

char Protection::getName(unsigned int a0, Bool *isnull, Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  char __tmp = 0;
  Status s;
  Size from = a0;

  s = getClass()->getAttributes()[2]->getValue(this, (Data *)&__tmp, 1, from, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

Status Protection::setPusers(unsigned int a0, ProtectionUser *_pusers)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;
  Size from = a0;

  Size size;
  status = getClass()->getAttributes()[3]->getSize(this, size);
  if (status)
    return status;

  if (size <= from)
    status = getClass()->getAttributes()[3]->setSize(this, from+1);
  if (status)
    return status;

  status = getClass()->getAttributes()[3]->setValue(this, (Data)&_pusers, 1, from);
  return status;
}

Status Protection::setPusersCount(unsigned int a0)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;
  Size from = a0;
  status = getClass()->getAttributes()[3]->setSize(this, from);
  return status;
}

const ProtectionUser *Protection::getPusers(unsigned int a0, Bool *isnull, Status *rs) const 
{
  gbxAutoGarbSuspender _gbxsusp_;
  Object *__o = 0, *__go;
  Status s;
  Size from = a0;

  s = getClass()->getAttributes()[3]->getValue(this, (Data *)&__o, 1, from, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (ObjectPeer::isGRTObject(__o)) {
       return (ProtectionUser *)__o;
     }
     __go = (ProtectionUser *)make_object(__o, False);
     if (__go)
      {
       __o = __go;;
       s = getClass()->getAttributes()[3]->setValue((Agregat *)this, (Data)&__o, 1, from);
       ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
    }
  return (ProtectionUser *)__o;
}

ProtectionUser *Protection::getPusers(unsigned int a0, Bool *isnull, Status *rs) 
{
  gbxAutoGarbSuspender _gbxsusp_;
  Object *__o = 0, *__go;
  Status s;
  Size from = a0;

  s = getClass()->getAttributes()[3]->getValue(this, (Data *)&__o, 1, from, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (ObjectPeer::isGRTObject(__o)) {
       return (ProtectionUser *)__o;
     }
     __go = (ProtectionUser *)make_object(__o, False);
     if (__go)
      {
       __o = __go;;
       s = getClass()->getAttributes()[3]->setValue((Agregat *)this, (Data)&__o, 1, from);
       ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
    }
  return (ProtectionUser *)__o;
}

unsigned int Protection::getPusersCount(Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  Size size;
  Status s;
  s = getClass()->getAttributes()[3]->getSize(this, size);
  if (s) {if (rs) *rs = s; return 0;}
  return (int)size;
}

Status Protection::setPoid(Oid _poid)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;

  status = getClass()->getAttributes()[4]->setValue(this, (Data)&_poid, 1, 0);
  return status;
}

Oid Protection::getPoid(Bool *isnull, Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  Oid __tmp;
  Status s;

  s = getClass()->getAttributes()[4]->getValue(this, (Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return nulloid;}

  return __tmp;
}

static const Attribute **UnreadableObject_agritems;
static Size UnreadableObject_idr_objsz, UnreadableObject_idr_psize;

static StructClass *UnreadableObject_make(StructClass *UnreadableObject_class = 0, Schema *m = 0)
{
  if (!UnreadableObject_class)
    return new StructClass("unreadable_object", (m ? m->getClass("struct") : Struct_Class));
  Attribute *attr[2];

  UnreadableObject_class->setAttributes(&attr[2], 0);


  ClassPeer::setMType(UnreadableObject_class, Class::System);

  return UnreadableObject_class;
}

Object *UnreadableObject_construct_x(const Class *cls, Data idr)
{
  return new UnreadableObject(cls, idr);
}

Object *UnreadableObject_construct(const Object *o, Bool share)
{
  return new UnreadableObject((const Struct *)o, share);
}

static void UnreadableObject_init_p()
{
  UnreadableObject_Class = UnreadableObject_make();
  constructors_x[class_ind] = UnreadableObject_construct_x;
  constructors[class_ind] = UnreadableObject_construct;
  hash->insert("unreadable_object", class_ind++);
}

static void UnreadableObject_init()
{
  UnreadableObject_make(UnreadableObject_Class);

  UnreadableObject_agritems = UnreadableObject_Class->getAttributes();
  UnreadableObject_idr_objsz = UnreadableObject_Class->getIDRObjectSize(&UnreadableObject_idr_psize, 0);

  ObjectPeer::setUnrealizable(UnreadableObject_Class, True);
}

static Status UnreadableObject_attrcomp_realize(Database *db, Class *cls)
{
  return Success;
}

UnreadableObject::UnreadableObject(Database *_db, const Dataspace *_dataspace) : Struct(_db, _dataspace)
{
  initialize(_db);
}

UnreadableObject::UnreadableObject(const Class *_cls, Data _idr)
{
  setClass((Class *)_cls);

  Size idr_psize;
  Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  ClassPeer::newObjRealize(getClass(), this);
  ObjectPeer::setGRTObject(this, True);
  userInitialize();
}

void UnreadableObject::initialize(Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("unreadable_object") : UnreadableObject_Class));

  Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  ClassPeer::newObjRealize(getClass(), this);
  ObjectPeer::setGRTObject(this, True);
  userInitialize();
}

UnreadableObject::UnreadableObject(const UnreadableObject& x) : Struct(x)
{
  userCopy(x);
}

UnreadableObject& UnreadableObject::operator=(const UnreadableObject& x)
{
  *(Struct *)this = Struct::operator=((const Struct &)x);
  userCopy(x);
  return *this;
}

UnreadableObject::UnreadableObject(const Struct *x, Bool share) : Struct(x, share)
{
  setClass((db ? db->getSchema()->getClass("unreadable_object") : UnreadableObject_Class));

  Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      ClassPeer::newObjRealize(getClass(), this);
    }

  ObjectPeer::setGRTObject(this, True);
  userCopy(*x);
}

UnreadableObject::UnreadableObject(const UnreadableObject *x, Bool share) : Struct(x, share)
{
  setClass((db ? db->getSchema()->getClass("unreadable_object") : UnreadableObject_Class));

  Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      ClassPeer::newObjRealize(getClass(), this);
    }

  ObjectPeer::setGRTObject(this, True);
  userCopy(*x);
}

static const Attribute **ClassConversion_agritems;
static Size ClassConversion_idr_objsz, ClassConversion_idr_psize;

static StructClass *ClassConversion_make(StructClass *ClassConversion_class = 0, Schema *m = 0)
{
  if (!ClassConversion_class)
    return new StructClass("class_conversion", (m ? m->getClass("struct") : Struct_Class));
  Attribute *attr[19];
  int *dims;

  dims = 0;
  attr[2] = new Attribute((m ? m->getClass("class_update_type") : ClassUpdateType_Class), "updtype", False, 0, dims);

  dims = 0;
  attr[3] = new Attribute((m ? m->getClass("attribute_convert_type") : AttributeConvertType_Class), "cnvtype", False, 0, dims);

  dims = new int[1];
  dims[0] = -1;
  attr[4] = new Attribute((m ? m->getClass("char") : Char_Class), "clsname", False, 1, dims);
  delete[] dims;

  dims = new int[1];
  dims[0] = -1;
  attr[5] = new Attribute((m ? m->getClass("char") : Char_Class), "attrname", False, 1, dims);
  delete[] dims;

  dims = 0;
  attr[6] = new Attribute((m ? m->getClass("int") : Int32_Class), "attrnum", False, 0, dims);

  dims = 0;
  attr[7] = new Attribute((m ? m->getClass("oid") : OidP_Class), "oid_o", False, 0, dims);

  dims = 0;
  attr[8] = new Attribute((m ? m->getClass("oid") : OidP_Class), "oid_n", False, 0, dims);

  dims = 0;
  attr[9] = new Attribute((m ? m->getClass("oid") : OidP_Class), "roid_o", False, 0, dims);

  dims = 0;
  attr[10] = new Attribute((m ? m->getClass("int") : Int32_Class), "sync", False, 0, dims);

  dims = 0;
  attr[11] = new Attribute((m ? m->getClass("int") : Int32_Class), "with_check", False, 0, dims);

  dims = 0;
  attr[12] = new Attribute((m ? m->getClass("int") : Int32_Class), "src_dim", False, 0, dims);

  dims = 0;
  attr[13] = new Attribute((m ? m->getClass("int") : Int32_Class), "dest_dim", False, 0, dims);

  dims = 0;
  attr[14] = new Attribute((m ? m->getClass("int") : Int32_Class), "offset_o", False, 0, dims);

  dims = 0;
  attr[15] = new Attribute((m ? m->getClass("int") : Int32_Class), "offset_n", False, 0, dims);

  dims = 0;
  attr[16] = new Attribute((m ? m->getClass("int") : Int32_Class), "size_o", False, 0, dims);

  dims = 0;
  attr[17] = new Attribute((m ? m->getClass("int") : Int32_Class), "size_n", False, 0, dims);

  dims = 0;
  attr[18] = new Attribute((m ? m->getClass("be_method_C") : BEMethod_C_Class), "cnv_mth", True, 0, dims);

  ClassConversion_class->setAttributes(&attr[2], 17);

  delete attr[2];
  delete attr[3];
  delete attr[4];
  delete attr[5];
  delete attr[6];
  delete attr[7];
  delete attr[8];
  delete attr[9];
  delete attr[10];
  delete attr[11];
  delete attr[12];
  delete attr[13];
  delete attr[14];
  delete attr[15];
  delete attr[16];
  delete attr[17];
  delete attr[18];

  ClassPeer::setMType(ClassConversion_class, Class::System);

  return ClassConversion_class;
}

Object *ClassConversion_construct_x(const Class *cls, Data idr)
{
  return new ClassConversion(cls, idr);
}

Object *ClassConversion_construct(const Object *o, Bool share)
{
  return new ClassConversion((const Struct *)o, share);
}

static void ClassConversion_init_p()
{
  ClassConversion_Class = ClassConversion_make();
  constructors_x[class_ind] = ClassConversion_construct_x;
  constructors[class_ind] = ClassConversion_construct;
  hash->insert("class_conversion", class_ind++);
}

static void ClassConversion_init()
{
  ClassConversion_make(ClassConversion_Class);

  ClassConversion_agritems = ClassConversion_Class->getAttributes();
  ClassConversion_idr_objsz = ClassConversion_Class->getIDRObjectSize(&ClassConversion_idr_psize, 0);

  ObjectPeer::setUnrealizable(ClassConversion_Class, True);
}

static Status ClassConversion_attrcomp_realize(Database *db, Class *cls)
{
  AttributeComponent *comp;
  const Dataspace *dataspace;
  ClassComponent *clcomp;
  Status status;
  int *impl_hints;
  impl_hints = new int[8];
  impl_hints[0] = 0;
  impl_hints[1] = 0;
  impl_hints[2] = 0;
  impl_hints[3] = 0;
  impl_hints[4] = 0;
  impl_hints[5] = 0;
  impl_hints[6] = 0;
  impl_hints[7] = 0;
  dataspace = 0;;
  comp = new HashIndex(db, cls, "class_conversion.clsname", False, True, dataspace, 0, 0, impl_hints, 8);
  delete [] impl_hints;
  cls->add(comp->getInd(), comp);

  impl_hints = new int[8];
  impl_hints[0] = 0;
  impl_hints[1] = 0;
  impl_hints[2] = 0;
  impl_hints[3] = 0;
  impl_hints[4] = 0;
  impl_hints[5] = 0;
  impl_hints[6] = 0;
  impl_hints[7] = 0;
  dataspace = 0;;
  comp = new BTreeIndex(db, cls, "class_conversion.oid_o", False, False, dataspace, 0, impl_hints, 8);
  delete [] impl_hints;
  cls->add(comp->getInd(), comp);

  impl_hints = new int[8];
  impl_hints[0] = 0;
  impl_hints[1] = 0;
  impl_hints[2] = 0;
  impl_hints[3] = 0;
  impl_hints[4] = 0;
  impl_hints[5] = 0;
  impl_hints[6] = 0;
  impl_hints[7] = 0;
  dataspace = 0;;
  comp = new BTreeIndex(db, cls, "class_conversion.oid_n", False, False, dataspace, 0, impl_hints, 8);
  delete [] impl_hints;
  cls->add(comp->getInd(), comp);

  return Success;
}

ClassConversion::ClassConversion(Database *_db, const Dataspace *_dataspace) : Struct(_db, _dataspace)
{
  initialize(_db);
}

ClassConversion::ClassConversion(const Class *_cls, Data _idr)
{
  setClass((Class *)_cls);

  Size idr_psize;
  Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  ClassPeer::newObjRealize(getClass(), this);
  ObjectPeer::setGRTObject(this, True);
  userInitialize();
}

void ClassConversion::initialize(Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("class_conversion") : ClassConversion_Class));

  Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  ClassPeer::newObjRealize(getClass(), this);
  ObjectPeer::setGRTObject(this, True);
  userInitialize();
}

ClassConversion::ClassConversion(const ClassConversion& x) : Struct(x)
{
  userCopy(x);
}

ClassConversion& ClassConversion::operator=(const ClassConversion& x)
{
  *(Struct *)this = Struct::operator=((const Struct &)x);
  userCopy(x);
  return *this;
}

ClassConversion::ClassConversion(const Struct *x, Bool share) : Struct(x, share)
{
  setClass((db ? db->getSchema()->getClass("class_conversion") : ClassConversion_Class));

  Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      ClassPeer::newObjRealize(getClass(), this);
    }

  ObjectPeer::setGRTObject(this, True);
  userCopy(*x);
}

ClassConversion::ClassConversion(const ClassConversion *x, Bool share) : Struct(x, share)
{
  setClass((db ? db->getSchema()->getClass("class_conversion") : ClassConversion_Class));

  Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      ClassPeer::newObjRealize(getClass(), this);
    }

  ObjectPeer::setGRTObject(this, True);
  userCopy(*x);
}

Status ClassConversion::setUpdtype(ClassUpdateType _updtype, Bool _check_value)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;
  eyedblib::int32 __tmp = _updtype;

  status = getClass()->getAttributes()[2]->setValue(this, (Data)&__tmp, 1, 0, _check_value);
  return status;
}

ClassUpdateType ClassConversion::getUpdtype(Bool *isnull, Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int32 __tmp = 0;
  Status s;

  s = getClass()->getAttributes()[2]->getValue(this, (Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return (ClassUpdateType)0;}
  return (ClassUpdateType)__tmp;
}

Status ClassConversion::setCnvtype(AttributeConvertType _cnvtype, Bool _check_value)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;
  eyedblib::int32 __tmp = _cnvtype;

  status = getClass()->getAttributes()[3]->setValue(this, (Data)&__tmp, 1, 0, _check_value);
  return status;
}

AttributeConvertType ClassConversion::getCnvtype(Bool *isnull, Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int32 __tmp = 0;
  Status s;

  s = getClass()->getAttributes()[3]->getValue(this, (Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return (AttributeConvertType)0;}
  return (AttributeConvertType)__tmp;
}

Status ClassConversion::setClsname(const char *_clsname)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;
  Size size;
  Size len = ::strlen(_clsname) + 1;

  status = getClass()->getAttributes()[4]->getSize(this, size);
  if (status)
    return status;

  if (size != len)
    status = getClass()->getAttributes()[4]->setSize(this, len);
  if (status)
    return status;

  status = getClass()->getAttributes()[4]->setValue(this, (Data)_clsname, len, 0);
  return status;

}

Status ClassConversion::setClsname(unsigned int a0, char _clsname)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;
  Size from = a0;

  Size size;
  status = getClass()->getAttributes()[4]->getSize(this, size);
  if (status)
    return status;

  if (size <= from)
    status = getClass()->getAttributes()[4]->setSize(this, from+1);
  if (status)
    return status;

  status = getClass()->getAttributes()[4]->setValue(this, (Data)&_clsname, 1, from);
  return status;
}

const char *ClassConversion::getClsname(Bool *isnull, Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  Data data;
  Status s;

  s = getClass()->getAttributes()[4]->getValue(this, (Data *)&data, Attribute::directAccess, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  if (!data) data = nulldata;
  return (const char *)data;
}

char ClassConversion::getClsname(unsigned int a0, Bool *isnull, Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  char __tmp = 0;
  Status s;
  Size from = a0;

  s = getClass()->getAttributes()[4]->getValue(this, (Data *)&__tmp, 1, from, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

Status ClassConversion::setAttrname(const char *_attrname)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;
  Size size;
  Size len = ::strlen(_attrname) + 1;

  status = getClass()->getAttributes()[5]->getSize(this, size);
  if (status)
    return status;

  if (size != len)
    status = getClass()->getAttributes()[5]->setSize(this, len);
  if (status)
    return status;

  status = getClass()->getAttributes()[5]->setValue(this, (Data)_attrname, len, 0);
  return status;

}

Status ClassConversion::setAttrname(unsigned int a0, char _attrname)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;
  Size from = a0;

  Size size;
  status = getClass()->getAttributes()[5]->getSize(this, size);
  if (status)
    return status;

  if (size <= from)
    status = getClass()->getAttributes()[5]->setSize(this, from+1);
  if (status)
    return status;

  status = getClass()->getAttributes()[5]->setValue(this, (Data)&_attrname, 1, from);
  return status;
}

const char *ClassConversion::getAttrname(Bool *isnull, Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  Data data;
  Status s;

  s = getClass()->getAttributes()[5]->getValue(this, (Data *)&data, Attribute::directAccess, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  if (!data) data = nulldata;
  return (const char *)data;
}

char ClassConversion::getAttrname(unsigned int a0, Bool *isnull, Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  char __tmp = 0;
  Status s;
  Size from = a0;

  s = getClass()->getAttributes()[5]->getValue(this, (Data *)&__tmp, 1, from, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

Status ClassConversion::setAttrnum(eyedblib::int32 _attrnum)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;

  status = getClass()->getAttributes()[6]->setValue(this, (Data)&_attrnum, 1, 0);
  return status;
}

eyedblib::int32 ClassConversion::getAttrnum(Bool *isnull, Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int32 __tmp = 0;
  Status s;

  s = getClass()->getAttributes()[6]->getValue(this, (Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

Status ClassConversion::setOidO(Oid _oid_o)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;

  status = getClass()->getAttributes()[7]->setValue(this, (Data)&_oid_o, 1, 0);
  return status;
}

Oid ClassConversion::getOidO(Bool *isnull, Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  Oid __tmp;
  Status s;

  s = getClass()->getAttributes()[7]->getValue(this, (Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return nulloid;}

  return __tmp;
}

Status ClassConversion::setOidN(Oid _oid_n)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;

  status = getClass()->getAttributes()[8]->setValue(this, (Data)&_oid_n, 1, 0);
  return status;
}

Oid ClassConversion::getOidN(Bool *isnull, Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  Oid __tmp;
  Status s;

  s = getClass()->getAttributes()[8]->getValue(this, (Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return nulloid;}

  return __tmp;
}

Status ClassConversion::setRoidO(Oid _roid_o)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;

  status = getClass()->getAttributes()[9]->setValue(this, (Data)&_roid_o, 1, 0);
  return status;
}

Oid ClassConversion::getRoidO(Bool *isnull, Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  Oid __tmp;
  Status s;

  s = getClass()->getAttributes()[9]->getValue(this, (Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return nulloid;}

  return __tmp;
}

Status ClassConversion::setSync(eyedblib::int32 _sync)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;

  status = getClass()->getAttributes()[10]->setValue(this, (Data)&_sync, 1, 0);
  return status;
}

eyedblib::int32 ClassConversion::getSync(Bool *isnull, Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int32 __tmp = 0;
  Status s;

  s = getClass()->getAttributes()[10]->getValue(this, (Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

Status ClassConversion::setWithCheck(eyedblib::int32 _with_check)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;

  status = getClass()->getAttributes()[11]->setValue(this, (Data)&_with_check, 1, 0);
  return status;
}

eyedblib::int32 ClassConversion::getWithCheck(Bool *isnull, Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int32 __tmp = 0;
  Status s;

  s = getClass()->getAttributes()[11]->getValue(this, (Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

Status ClassConversion::setSrcDim(eyedblib::int32 _src_dim)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;

  status = getClass()->getAttributes()[12]->setValue(this, (Data)&_src_dim, 1, 0);
  return status;
}

eyedblib::int32 ClassConversion::getSrcDim(Bool *isnull, Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int32 __tmp = 0;
  Status s;

  s = getClass()->getAttributes()[12]->getValue(this, (Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

Status ClassConversion::setDestDim(eyedblib::int32 _dest_dim)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;

  status = getClass()->getAttributes()[13]->setValue(this, (Data)&_dest_dim, 1, 0);
  return status;
}

eyedblib::int32 ClassConversion::getDestDim(Bool *isnull, Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int32 __tmp = 0;
  Status s;

  s = getClass()->getAttributes()[13]->getValue(this, (Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

Status ClassConversion::setOffsetO(eyedblib::int32 _offset_o)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;

  status = getClass()->getAttributes()[14]->setValue(this, (Data)&_offset_o, 1, 0);
  return status;
}

eyedblib::int32 ClassConversion::getOffsetO(Bool *isnull, Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int32 __tmp = 0;
  Status s;

  s = getClass()->getAttributes()[14]->getValue(this, (Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

Status ClassConversion::setOffsetN(eyedblib::int32 _offset_n)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;

  status = getClass()->getAttributes()[15]->setValue(this, (Data)&_offset_n, 1, 0);
  return status;
}

eyedblib::int32 ClassConversion::getOffsetN(Bool *isnull, Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int32 __tmp = 0;
  Status s;

  s = getClass()->getAttributes()[15]->getValue(this, (Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

Status ClassConversion::setSizeO(eyedblib::int32 _size_o)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;

  status = getClass()->getAttributes()[16]->setValue(this, (Data)&_size_o, 1, 0);
  return status;
}

eyedblib::int32 ClassConversion::getSizeO(Bool *isnull, Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int32 __tmp = 0;
  Status s;

  s = getClass()->getAttributes()[16]->getValue(this, (Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

Status ClassConversion::setSizeN(eyedblib::int32 _size_n)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;

  status = getClass()->getAttributes()[17]->setValue(this, (Data)&_size_n, 1, 0);
  return status;
}

eyedblib::int32 ClassConversion::getSizeN(Bool *isnull, Status *rs) const
{
  gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int32 __tmp = 0;
  Status s;

  s = getClass()->getAttributes()[17]->getValue(this, (Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

Status ClassConversion::setCnvMth(BEMethod_C *_cnv_mth)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;

  status = getClass()->getAttributes()[18]->setValue(this, (Data)&_cnv_mth, 1, 0);
  return status;
}

const BEMethod_C *ClassConversion::getCnvMth(Bool *isnull, Status *rs) const 
{
  gbxAutoGarbSuspender _gbxsusp_;
  Object *__o = 0, *__go;
  Status s;

  s = getClass()->getAttributes()[18]->getValue(this, (Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (ObjectPeer::isGRTObject(__o)) {
       return (BEMethod_C *)__o;
     }
     __go = (BEMethod_C *)make_object(__o, False);
     if (__go)
      {
       __o = __go;
       s = getClass()->getAttributes()[18]->setValue((Agregat *)this, (Data)&__o, 1, 0);
       ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
     return (BEMethod_C *)__o;
    }

  Bool wasnull = (!__o ? True : False);
  if (!__o && db)
    {
      Oid toid;
      s = getClass()->getAttributes()[18]->getOid(this, &toid, 1, 0);
      if (s) {if (rs) *rs = s; return 0;}
      if (toid.isValid())
        {
          s = db->loadObject(&toid, &__o);
          if (s) {if (rs) *rs = s; return 0;}
          if (!ObjectPeer::isGRTObject(__o))
           {
             __go = (BEMethod_C *)make_object(__o, False);
             if (__go) __o = __go;
           }
        }
    }

  if (__o && wasnull)
    {
     s = getClass()->getAttributes()[18]->setValue((Agregat *)this, (Data)&__o, 1, 0);
     if (s) {if (rs) *rs = s; return 0;}
     __o->release();
    }
  return (BEMethod_C *)__o;
}

BEMethod_C *ClassConversion::getCnvMth(Bool *isnull, Status *rs) 
{
  gbxAutoGarbSuspender _gbxsusp_;
  Object *__o = 0, *__go;
  Status s;

  s = getClass()->getAttributes()[18]->getValue(this, (Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (ObjectPeer::isGRTObject(__o)) {
       return (BEMethod_C *)__o;
     }
     __go = (BEMethod_C *)make_object(__o, False);
     if (__go)
      {
       __o = __go;
       s = getClass()->getAttributes()[18]->setValue((Agregat *)this, (Data)&__o, 1, 0);
       ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
     return (BEMethod_C *)__o;
    }

  Bool wasnull = (!__o ? True : False);
  if (!__o && db)
    {
      Oid toid;
      s = getClass()->getAttributes()[18]->getOid(this, &toid, 1, 0);
      if (s) {if (rs) *rs = s; return 0;}
      if (toid.isValid())
        {
          s = db->loadObject(&toid, &__o);
          if (s) {if (rs) *rs = s; return 0;}
          if (!ObjectPeer::isGRTObject(__o))
           {
             __go = (BEMethod_C *)make_object(__o, False);
             if (__go) __o = __go;
           }
        }
    }

  if (__o && wasnull)
    {
     s = getClass()->getAttributes()[18]->setValue((Agregat *)this, (Data)&__o, 1, 0);
     if (s) {if (rs) *rs = s; return 0;}
     __o->release();
    }
  return (BEMethod_C *)__o;
}

Status ClassConversion::setCnvMthOid(const Oid &_oid)
{
  gbxAutoGarbSuspender _gbxsusp_;
  Status status;

  status = getClass()->getAttributes()[18]->setOid(this, &_oid, 1, 0, oid_check);
  return status;
}

Oid ClassConversion::getCnvMthOid(Status *rs) 
{
  gbxAutoGarbSuspender _gbxsusp_;
  Oid __tmp;
  Status s;

  s = getClass()->getAttributes()[18]->getOid(this, &__tmp, 1, 0);
  if (s) {if (rs) *rs = s; return nulloid;}

  return __tmp;
}

static CollSetClass *set_class_AttributeComponent_ref_make(CollSetClass *cls = 0, Schema *m = 0)
{
  if (!cls)
    {
      cls = new CollSetClass((m ? m->getClass("attribute_component") : AttributeComponent_Class), True);
      ClassPeer::setMType(cls, Class::System);
    }
  return cls;
}

static void set_class_AttributeComponent_ref_init_p()
{
  set_class_AttributeComponent_ref_Class = set_class_AttributeComponent_ref_make();
}

static const char not_exit_msg[] = "class does not exist";
static const char differ_msg[] = "class differs in database and in runtime environment";

void sysclsInit(void)
{
  if (hash) return;

  hash = new GenHashTable(0, 105);

  IndexType_init_p();
  ExecutableLang_init_p();
  ArgType_Type_init_p();
  ExecutableLocalisation_init_p();
  ExecutableType_init_p();
  TriggerType_init_p();
  ProtectionMode_init_p();
  ClassUpdateType_init_p();
  AttributeConvertType_init_p();
  AttributeComponent_init_p();
  AttributeComponentSet_init_p();
  ClassComponent_init_p();
  AgregatClassComponent_init_p();
  ClassVariable_init_p();
  Index_init_p();
  HashIndex_init_p();
  BTreeIndex_init_p();
  CollAttrImpl_init_p();
  ArgType_init_p();
  Signature_init_p();
  Executable_init_p();
  AgregatClassExecutable_init_p();
  Method_init_p();
  FEMethod_init_p();
  FEMethod_C_init_p();
  BEMethod_init_p();
  BEMethod_C_init_p();
  BEMethod_OQL_init_p();
  Trigger_init_p();
  UniqueConstraint_init_p();
  NotNullConstraint_init_p();
  CardinalityDescription_init_p();
  CardinalityConstraint_init_p();
  CardinalityConstraint_Test_init_p();
  ProtectionUser_init_p();
  Protection_init_p();
  UnreadableObject_init_p();
  ClassConversion_init_p();
  set_class_AttributeComponent_ref_init_p();
  IndexType_init();
  ExecutableLang_init();
  ArgType_Type_init();
  ExecutableLocalisation_init();
  ExecutableType_init();
  TriggerType_init();
  ProtectionMode_init();
  ClassUpdateType_init();
  AttributeConvertType_init();
  AttributeComponent_init();
  AttributeComponentSet_init();
  ClassComponent_init();
  AgregatClassComponent_init();
  ClassVariable_init();
  Index_init();
  HashIndex_init();
  BTreeIndex_init();
  CollAttrImpl_init();
  ArgType_init();
  Signature_init();
  Executable_init();
  AgregatClassExecutable_init();
  Method_init();
  FEMethod_init();
  FEMethod_C_init();
  BEMethod_init();
  BEMethod_C_init();
  BEMethod_OQL_init();
  Trigger_init();
  UniqueConstraint_init();
  NotNullConstraint_init();
  CardinalityDescription_init();
  CardinalityConstraint_init();
  CardinalityConstraint_Test_init();
  ProtectionUser_init();
  Protection_init();
  UnreadableObject_init();
  ClassConversion_init();
}

void sysclsRelease(void)
{
  delete hash;

  IndexType_Class->release();
  ExecutableLang_Class->release();
  ArgType_Type_Class->release();
  ExecutableLocalisation_Class->release();
  ExecutableType_Class->release();
  TriggerType_Class->release();
  ProtectionMode_Class->release();
  ClassUpdateType_Class->release();
  AttributeConvertType_Class->release();
  AttributeComponent_Class->release();
  AttributeComponentSet_Class->release();
  ClassComponent_Class->release();
  AgregatClassComponent_Class->release();
  ClassVariable_Class->release();
  Index_Class->release();
  HashIndex_Class->release();
  BTreeIndex_Class->release();
  CollAttrImpl_Class->release();
  ArgType_Class->release();
  Signature_Class->release();
  Executable_Class->release();
  AgregatClassExecutable_Class->release();
  Method_Class->release();
  FEMethod_Class->release();
  FEMethod_C_Class->release();
  BEMethod_Class->release();
  BEMethod_C_Class->release();
  BEMethod_OQL_Class->release();
  Trigger_Class->release();
  UniqueConstraint_Class->release();
  NotNullConstraint_Class->release();
  CardinalityDescription_Class->release();
  CardinalityConstraint_Class->release();
  CardinalityConstraint_Test_Class->release();
  ProtectionUser_Class->release();
  Protection_Class->release();
  UnreadableObject_Class->release();
  ClassConversion_Class->release();
  set_class_AttributeComponent_ref_Class->release();
}

static Status
sysclsSchemaUpdate(Schema *m, Database *db)
{
  m->setName("eyedb");
  Status status;
  EnumClass *IndexType_class = IndexType_make(0, m);
  if (!m->getClass("index_type"))
    {
      status = m->addClass(IndexType_class);
      if (status)
        return status;
    }
  EnumClass *ExecutableLang_class = ExecutableLang_make(0, m);
  if (!m->getClass("executable_lang"))
    {
      status = m->addClass(ExecutableLang_class);
      if (status)
        return status;
    }
  EnumClass *ArgType_Type_class = ArgType_Type_make(0, m);
  if (!m->getClass("argtype_type"))
    {
      status = m->addClass(ArgType_Type_class);
      if (status)
        return status;
    }
  EnumClass *ExecutableLocalisation_class = ExecutableLocalisation_make(0, m);
  if (!m->getClass("executable_localisation"))
    {
      status = m->addClass(ExecutableLocalisation_class);
      if (status)
        return status;
    }
  EnumClass *ExecutableType_class = ExecutableType_make(0, m);
  if (!m->getClass("executable_type"))
    {
      status = m->addClass(ExecutableType_class);
      if (status)
        return status;
    }
  EnumClass *TriggerType_class = TriggerType_make(0, m);
  if (!m->getClass("trigger_type"))
    {
      status = m->addClass(TriggerType_class);
      if (status)
        return status;
    }
  EnumClass *ProtectionMode_class = ProtectionMode_make(0, m);
  if (!m->getClass("protection_mode"))
    {
      status = m->addClass(ProtectionMode_class);
      if (status)
        return status;
    }
  EnumClass *ClassUpdateType_class = ClassUpdateType_make(0, m);
  if (!m->getClass("class_update_type"))
    {
      status = m->addClass(ClassUpdateType_class);
      if (status)
        return status;
    }
  EnumClass *AttributeConvertType_class = AttributeConvertType_make(0, m);
  if (!m->getClass("attribute_convert_type"))
    {
      status = m->addClass(AttributeConvertType_class);
      if (status)
        return status;
    }
  StructClass *AttributeComponent_class = AttributeComponent_make(0, m);
  if (!m->getClass("attribute_component"))
    {
      status = m->addClass(AttributeComponent_class);
      if (status)
        return status;
    }
  StructClass *AttributeComponentSet_class = AttributeComponentSet_make(0, m);
  if (!m->getClass("attribute_component_set"))
    {
      status = m->addClass(AttributeComponentSet_class);
      if (status)
        return status;
    }
  StructClass *ClassComponent_class = ClassComponent_make(0, m);
  if (!m->getClass("class_component"))
    {
      status = m->addClass(ClassComponent_class);
      if (status)
        return status;
    }
  StructClass *AgregatClassComponent_class = AgregatClassComponent_make(0, m);
  if (!m->getClass("agregat_class_component"))
    {
      status = m->addClass(AgregatClassComponent_class);
      if (status)
        return status;
    }
  StructClass *ClassVariable_class = ClassVariable_make(0, m);
  if (!m->getClass("class_variable"))
    {
      status = m->addClass(ClassVariable_class);
      if (status)
        return status;
    }
  StructClass *Index_class = Index_make(0, m);
  if (!m->getClass("index"))
    {
      status = m->addClass(Index_class);
      if (status)
        return status;
    }
  StructClass *HashIndex_class = HashIndex_make(0, m);
  if (!m->getClass("hashindex"))
    {
      status = m->addClass(HashIndex_class);
      if (status)
        return status;
    }
  StructClass *BTreeIndex_class = BTreeIndex_make(0, m);
  if (!m->getClass("btreeindex"))
    {
      status = m->addClass(BTreeIndex_class);
      if (status)
        return status;
    }
  StructClass *CollAttrImpl_class = CollAttrImpl_make(0, m);
  if (!m->getClass("collection_attribute_implementation"))
    {
      status = m->addClass(CollAttrImpl_class);
      if (status)
        return status;
    }
  StructClass *ArgType_class = ArgType_make(0, m);
  if (!m->getClass("argtype"))
    {
      status = m->addClass(ArgType_class);
      if (status)
        return status;
    }
  StructClass *Signature_class = Signature_make(0, m);
  if (!m->getClass("signature"))
    {
      status = m->addClass(Signature_class);
      if (status)
        return status;
    }
  StructClass *Executable_class = Executable_make(0, m);
  if (!m->getClass("executable"))
    {
      status = m->addClass(Executable_class);
      if (status)
        return status;
    }
  StructClass *AgregatClassExecutable_class = AgregatClassExecutable_make(0, m);
  if (!m->getClass("agregat_class_executable"))
    {
      status = m->addClass(AgregatClassExecutable_class);
      if (status)
        return status;
    }
  StructClass *Method_class = Method_make(0, m);
  if (!m->getClass("method"))
    {
      status = m->addClass(Method_class);
      if (status)
        return status;
    }
  StructClass *FEMethod_class = FEMethod_make(0, m);
  if (!m->getClass("fe_method"))
    {
      status = m->addClass(FEMethod_class);
      if (status)
        return status;
    }
  StructClass *FEMethod_C_class = FEMethod_C_make(0, m);
  if (!m->getClass("fe_method_C"))
    {
      status = m->addClass(FEMethod_C_class);
      if (status)
        return status;
    }
  StructClass *BEMethod_class = BEMethod_make(0, m);
  if (!m->getClass("be_method"))
    {
      status = m->addClass(BEMethod_class);
      if (status)
        return status;
    }
  StructClass *BEMethod_C_class = BEMethod_C_make(0, m);
  if (!m->getClass("be_method_C"))
    {
      status = m->addClass(BEMethod_C_class);
      if (status)
        return status;
    }
  StructClass *BEMethod_OQL_class = BEMethod_OQL_make(0, m);
  if (!m->getClass("be_method_OQL"))
    {
      status = m->addClass(BEMethod_OQL_class);
      if (status)
        return status;
    }
  StructClass *Trigger_class = Trigger_make(0, m);
  if (!m->getClass("trigger"))
    {
      status = m->addClass(Trigger_class);
      if (status)
        return status;
    }
  StructClass *UniqueConstraint_class = UniqueConstraint_make(0, m);
  if (!m->getClass("unique_constraint"))
    {
      status = m->addClass(UniqueConstraint_class);
      if (status)
        return status;
    }
  StructClass *NotNullConstraint_class = NotNullConstraint_make(0, m);
  if (!m->getClass("notnull_constraint"))
    {
      status = m->addClass(NotNullConstraint_class);
      if (status)
        return status;
    }
  StructClass *CardinalityDescription_class = CardinalityDescription_make(0, m);
  if (!m->getClass("cardinality_description"))
    {
      status = m->addClass(CardinalityDescription_class);
      if (status)
        return status;
    }
  StructClass *CardinalityConstraint_class = CardinalityConstraint_make(0, m);
  if (!m->getClass("cardinality_constraint"))
    {
      status = m->addClass(CardinalityConstraint_class);
      if (status)
        return status;
    }
  StructClass *CardinalityConstraint_Test_class = CardinalityConstraint_Test_make(0, m);
  if (!m->getClass("cardinality_constraint_test"))
    {
      status = m->addClass(CardinalityConstraint_Test_class);
      if (status)
        return status;
    }
  StructClass *ProtectionUser_class = ProtectionUser_make(0, m);
  if (!m->getClass("protection_user"))
    {
      status = m->addClass(ProtectionUser_class);
      if (status)
        return status;
    }
  StructClass *Protection_class = Protection_make(0, m);
  if (!m->getClass("protection"))
    {
      status = m->addClass(Protection_class);
      if (status)
        return status;
    }
  StructClass *UnreadableObject_class = UnreadableObject_make(0, m);
  if (!m->getClass("unreadable_object"))
    {
      status = m->addClass(UnreadableObject_class);
      if (status)
        return status;
    }
  StructClass *ClassConversion_class = ClassConversion_make(0, m);
  if (!m->getClass("class_conversion"))
    {
      status = m->addClass(ClassConversion_class);
      if (status)
        return status;
    }
  CollSetClass *set_class_AttributeComponent_ref_class = set_class_AttributeComponent_ref_make(0, m);
  if (!m->getClass("set<attribute_component*>"))
    {
      status = m->addClass(set_class_AttributeComponent_ref_class);
      if (status)
        return status;
    }

  IndexType_make(IndexType_class, m);
  ExecutableLang_make(ExecutableLang_class, m);
  ArgType_Type_make(ArgType_Type_class, m);
  ExecutableLocalisation_make(ExecutableLocalisation_class, m);
  ExecutableType_make(ExecutableType_class, m);
  TriggerType_make(TriggerType_class, m);
  ProtectionMode_make(ProtectionMode_class, m);
  ClassUpdateType_make(ClassUpdateType_class, m);
  AttributeConvertType_make(AttributeConvertType_class, m);
  AttributeComponent_make(AttributeComponent_class, m);
  AttributeComponentSet_make(AttributeComponentSet_class, m);
  ClassComponent_make(ClassComponent_class, m);
  AgregatClassComponent_make(AgregatClassComponent_class, m);
  ClassVariable_make(ClassVariable_class, m);
  Index_make(Index_class, m);
  HashIndex_make(HashIndex_class, m);
  BTreeIndex_make(BTreeIndex_class, m);
  CollAttrImpl_make(CollAttrImpl_class, m);
  ArgType_make(ArgType_class, m);
  Signature_make(Signature_class, m);
  Executable_make(Executable_class, m);
  AgregatClassExecutable_make(AgregatClassExecutable_class, m);
  Method_make(Method_class, m);
  FEMethod_make(FEMethod_class, m);
  FEMethod_C_make(FEMethod_C_class, m);
  BEMethod_make(BEMethod_class, m);
  BEMethod_C_make(BEMethod_C_class, m);
  BEMethod_OQL_make(BEMethod_OQL_class, m);
  Trigger_make(Trigger_class, m);
  UniqueConstraint_make(UniqueConstraint_class, m);
  NotNullConstraint_make(NotNullConstraint_class, m);
  CardinalityDescription_make(CardinalityDescription_class, m);
  CardinalityConstraint_make(CardinalityConstraint_class, m);
  CardinalityConstraint_Test_make(CardinalityConstraint_Test_class, m);
  ProtectionUser_make(ProtectionUser_class, m);
  Protection_make(Protection_class, m);
  UnreadableObject_make(UnreadableObject_class, m);
  ClassConversion_make(ClassConversion_class, m);

  if (!db) return Success;

  if (!IndexType_class->compare(m->getClass("index_type")))
    return Exception::make(IDB_ERROR, "'IndexType' %s", differ_msg);
  if (!ExecutableLang_class->compare(m->getClass("executable_lang")))
    return Exception::make(IDB_ERROR, "'ExecutableLang' %s", differ_msg);
  if (!ArgType_Type_class->compare(m->getClass("argtype_type")))
    return Exception::make(IDB_ERROR, "'ArgType_Type' %s", differ_msg);
  if (!ExecutableLocalisation_class->compare(m->getClass("executable_localisation")))
    return Exception::make(IDB_ERROR, "'ExecutableLocalisation' %s", differ_msg);
  if (!ExecutableType_class->compare(m->getClass("executable_type")))
    return Exception::make(IDB_ERROR, "'ExecutableType' %s", differ_msg);
  if (!TriggerType_class->compare(m->getClass("trigger_type")))
    return Exception::make(IDB_ERROR, "'TriggerType' %s", differ_msg);
  if (!ProtectionMode_class->compare(m->getClass("protection_mode")))
    return Exception::make(IDB_ERROR, "'ProtectionMode' %s", differ_msg);
  if (!ClassUpdateType_class->compare(m->getClass("class_update_type")))
    return Exception::make(IDB_ERROR, "'ClassUpdateType' %s", differ_msg);
  if (!AttributeConvertType_class->compare(m->getClass("attribute_convert_type")))
    return Exception::make(IDB_ERROR, "'AttributeConvertType' %s", differ_msg);
  if (!AttributeComponent_class->compare(m->getClass("attribute_component")))
    return Exception::make(IDB_ERROR, "'AttributeComponent' %s", differ_msg);
  if (!AttributeComponentSet_class->compare(m->getClass("attribute_component_set")))
    return Exception::make(IDB_ERROR, "'AttributeComponentSet' %s", differ_msg);
  if (!ClassComponent_class->compare(m->getClass("class_component")))
    return Exception::make(IDB_ERROR, "'ClassComponent' %s", differ_msg);
  if (!AgregatClassComponent_class->compare(m->getClass("agregat_class_component")))
    return Exception::make(IDB_ERROR, "'AgregatClassComponent' %s", differ_msg);
  if (!ClassVariable_class->compare(m->getClass("class_variable")))
    return Exception::make(IDB_ERROR, "'ClassVariable' %s", differ_msg);
  if (!Index_class->compare(m->getClass("index")))
    return Exception::make(IDB_ERROR, "'Index' %s", differ_msg);
  if (!HashIndex_class->compare(m->getClass("hashindex")))
    return Exception::make(IDB_ERROR, "'HashIndex' %s", differ_msg);
  if (!BTreeIndex_class->compare(m->getClass("btreeindex")))
    return Exception::make(IDB_ERROR, "'BTreeIndex' %s", differ_msg);
  if (!CollAttrImpl_class->compare(m->getClass("collection_attribute_implementation")))
    return Exception::make(IDB_ERROR, "'CollAttrImpl' %s", differ_msg);
  if (!ArgType_class->compare(m->getClass("argtype")))
    return Exception::make(IDB_ERROR, "'ArgType' %s", differ_msg);
  if (!Signature_class->compare(m->getClass("signature")))
    return Exception::make(IDB_ERROR, "'Signature' %s", differ_msg);
  if (!Executable_class->compare(m->getClass("executable")))
    return Exception::make(IDB_ERROR, "'Executable' %s", differ_msg);
  if (!AgregatClassExecutable_class->compare(m->getClass("agregat_class_executable")))
    return Exception::make(IDB_ERROR, "'AgregatClassExecutable' %s", differ_msg);
  if (!Method_class->compare(m->getClass("method")))
    return Exception::make(IDB_ERROR, "'Method' %s", differ_msg);
  if (!FEMethod_class->compare(m->getClass("fe_method")))
    return Exception::make(IDB_ERROR, "'FEMethod' %s", differ_msg);
  if (!FEMethod_C_class->compare(m->getClass("fe_method_C")))
    return Exception::make(IDB_ERROR, "'FEMethod_C' %s", differ_msg);
  if (!BEMethod_class->compare(m->getClass("be_method")))
    return Exception::make(IDB_ERROR, "'BEMethod' %s", differ_msg);
  if (!BEMethod_C_class->compare(m->getClass("be_method_C")))
    return Exception::make(IDB_ERROR, "'BEMethod_C' %s", differ_msg);
  if (!BEMethod_OQL_class->compare(m->getClass("be_method_OQL")))
    return Exception::make(IDB_ERROR, "'BEMethod_OQL' %s", differ_msg);
  if (!Trigger_class->compare(m->getClass("trigger")))
    return Exception::make(IDB_ERROR, "'Trigger' %s", differ_msg);
  if (!UniqueConstraint_class->compare(m->getClass("unique_constraint")))
    return Exception::make(IDB_ERROR, "'UniqueConstraint' %s", differ_msg);
  if (!NotNullConstraint_class->compare(m->getClass("notnull_constraint")))
    return Exception::make(IDB_ERROR, "'NotNullConstraint' %s", differ_msg);
  if (!CardinalityDescription_class->compare(m->getClass("cardinality_description")))
    return Exception::make(IDB_ERROR, "'CardinalityDescription' %s", differ_msg);
  if (!CardinalityConstraint_class->compare(m->getClass("cardinality_constraint")))
    return Exception::make(IDB_ERROR, "'CardinalityConstraint' %s", differ_msg);
  if (!CardinalityConstraint_Test_class->compare(m->getClass("cardinality_constraint_test")))
    return Exception::make(IDB_ERROR, "'CardinalityConstraint_Test' %s", differ_msg);
  if (!ProtectionUser_class->compare(m->getClass("protection_user")))
    return Exception::make(IDB_ERROR, "'ProtectionUser' %s", differ_msg);
  if (!Protection_class->compare(m->getClass("protection")))
    return Exception::make(IDB_ERROR, "'Protection' %s", differ_msg);
  if (!UnreadableObject_class->compare(m->getClass("unreadable_object")))
    return Exception::make(IDB_ERROR, "'UnreadableObject' %s", differ_msg);
  if (!ClassConversion_class->compare(m->getClass("class_conversion")))
    return Exception::make(IDB_ERROR, "'ClassConversion' %s", differ_msg);

  db->transactionBegin();

  if ((status = AttributeComponent_attrcomp_realize(db, m->getClass("attribute_component")))) return status;

  if ((status = AttributeComponentSet_attrcomp_realize(db, m->getClass("attribute_component_set")))) return status;

  if ((status = ClassComponent_attrcomp_realize(db, m->getClass("class_component")))) return status;

  if ((status = AgregatClassComponent_attrcomp_realize(db, m->getClass("agregat_class_component")))) return status;

  if ((status = ClassVariable_attrcomp_realize(db, m->getClass("class_variable")))) return status;

  if ((status = Index_attrcomp_realize(db, m->getClass("index")))) return status;

  if ((status = HashIndex_attrcomp_realize(db, m->getClass("hashindex")))) return status;

  if ((status = BTreeIndex_attrcomp_realize(db, m->getClass("btreeindex")))) return status;

  if ((status = CollAttrImpl_attrcomp_realize(db, m->getClass("collection_attribute_implementation")))) return status;

  if ((status = ArgType_attrcomp_realize(db, m->getClass("argtype")))) return status;

  if ((status = Signature_attrcomp_realize(db, m->getClass("signature")))) return status;

  if ((status = Executable_attrcomp_realize(db, m->getClass("executable")))) return status;

  if ((status = AgregatClassExecutable_attrcomp_realize(db, m->getClass("agregat_class_executable")))) return status;

  if ((status = Method_attrcomp_realize(db, m->getClass("method")))) return status;

  if ((status = FEMethod_attrcomp_realize(db, m->getClass("fe_method")))) return status;

  if ((status = FEMethod_C_attrcomp_realize(db, m->getClass("fe_method_C")))) return status;

  if ((status = BEMethod_attrcomp_realize(db, m->getClass("be_method")))) return status;

  if ((status = BEMethod_C_attrcomp_realize(db, m->getClass("be_method_C")))) return status;

  if ((status = BEMethod_OQL_attrcomp_realize(db, m->getClass("be_method_OQL")))) return status;

  if ((status = Trigger_attrcomp_realize(db, m->getClass("trigger")))) return status;

  if ((status = UniqueConstraint_attrcomp_realize(db, m->getClass("unique_constraint")))) return status;

  if ((status = NotNullConstraint_attrcomp_realize(db, m->getClass("notnull_constraint")))) return status;

  if ((status = CardinalityDescription_attrcomp_realize(db, m->getClass("cardinality_description")))) return status;

  if ((status = CardinalityConstraint_attrcomp_realize(db, m->getClass("cardinality_constraint")))) return status;

  if ((status = CardinalityConstraint_Test_attrcomp_realize(db, m->getClass("cardinality_constraint_test")))) return status;

  if ((status = ProtectionUser_attrcomp_realize(db, m->getClass("protection_user")))) return status;

  if ((status = Protection_attrcomp_realize(db, m->getClass("protection")))) return status;

  if ((status = UnreadableObject_attrcomp_realize(db, m->getClass("unreadable_object")))) return status;

  if ((status = ClassConversion_attrcomp_realize(db, m->getClass("class_conversion")))) return status;
  status = m->realize();
  if (status) return status;
  db->transactionCommit();
  return Success;
}

Status sysclsSchemaUpdate(Database *db)
{
  return sysclsSchemaUpdate(db->getSchema(), db);
}

Status sysclsSchemaUpdate(Schema *m)
{
  return sysclsSchemaUpdate(m, NULL);
}

Object *sysclsMakeObject(Object *o, Bool remove)
{
  if (!o->getClass()) return (Object *)0;
  if (ObjectPeer::isGRTObject(o))
    return o;
  int ind = hash->get(o->getClass()->getName());
  if (ind < 0 && (!o->getClass()->getStrictAliasName() || (ind = hash->get(o->getClass()->getStrictAliasName())) < 0)) return 0;
  Object *co = constructors[ind](o, (remove ? True : False));
  ObjectPeer::setClass(co, o->getClass());
  if (remove) o->release();
  if (co->getDatabase())
    co->getDatabase()->cacheObject(co);
  return co;
}

Status sysclsDatabase::open(Connection *ch, Database::OpenFlag flag, const char *userauth, const char *passwdauth)
{
    return open(ch, flag, 0, userauth, passwdauth);
}

Status sysclsDatabase::open(Connection *ch, Database::OpenFlag flag, const OpenHints *hints, const char *userauth, const char *passwdauth)
{
  Status status = Database::open(ch, flag, hints, userauth, passwdauth);
  if (status) return status;
  transactionBegin();
  status = sysclsDatabase::checkSchema(getSchema());
  transactionCommit();

  if (!status) add(hash, constructors_x);

  return status;
}

void sysclsDatabase::setConsApp(Database *_db)
{
  _db->add(hash, constructors_x);
}

static void append(char *&s, const char *m1, const char *m2)
{
  if (!s) {s = (char *)malloc(strlen(m1)+strlen(m2)+2); *s = 0;}
  else s = (char *)realloc(s, strlen(s)+strlen(m1)+strlen(m2)+2);
  strcat(s, m1);
  strcat(s, m2);
  strcat(s, "\n");
}

Bool sysclsDatabase::getDynamicGetErrorPolicy() {
   throw *Exception::make(IDB_ERROR, "getDynamicGetErrorPolicy() can be called only when the dynamic attribute fonctionnality is on (-dynamic-attr option of eyedbodl)");
}

Bool sysclsDatabase::getDynamicSetErrorPolicy() {
   throw *Exception::make(IDB_ERROR, "getDynamicSetErrorPolicy() can be called only when the dynamic attribute fonctionnality is on (-dynamic-attr option of eyedbodl)");
}

void sysclsDatabase::setDynamicGetErrorPolicy(Bool policy) {
   throw *Exception::make(IDB_ERROR, "setDynamicGetErrorPolicy() can be called only when the dynamic attribute fonctionnality is on (-dynamic-attr option of eyedbodl)");
}

void sysclsDatabase::setDynamicSetErrorPolicy(Bool policy) {
   throw *Exception::make(IDB_ERROR, "setDynamicSetErrorPolicy() can be called only when the dynamic attribute fonctionnality is on (-dynamic-attr option of eyedbodl)");
}

Status sysclsDatabase::checkSchema(Schema *m)
{
  Class *cl;
  char *s = 0;

  if (!(cl = m->getClass("index_type")))
    append(s, "'index_type' ", not_exit_msg);
  else if (!IndexType_Class->compare(cl))
    append(s, "'IndexType' ", differ_msg);
  if (!(cl = m->getClass("executable_lang")))
    append(s, "'executable_lang' ", not_exit_msg);
  else if (!ExecutableLang_Class->compare(cl))
    append(s, "'ExecutableLang' ", differ_msg);
  if (!(cl = m->getClass("argtype_type")))
    append(s, "'argtype_type' ", not_exit_msg);
  else if (!ArgType_Type_Class->compare(cl))
    append(s, "'ArgType_Type' ", differ_msg);
  if (!(cl = m->getClass("executable_localisation")))
    append(s, "'executable_localisation' ", not_exit_msg);
  else if (!ExecutableLocalisation_Class->compare(cl))
    append(s, "'ExecutableLocalisation' ", differ_msg);
  if (!(cl = m->getClass("executable_type")))
    append(s, "'executable_type' ", not_exit_msg);
  else if (!ExecutableType_Class->compare(cl))
    append(s, "'ExecutableType' ", differ_msg);
  if (!(cl = m->getClass("trigger_type")))
    append(s, "'trigger_type' ", not_exit_msg);
  else if (!TriggerType_Class->compare(cl))
    append(s, "'TriggerType' ", differ_msg);
  if (!(cl = m->getClass("protection_mode")))
    append(s, "'protection_mode' ", not_exit_msg);
  else if (!ProtectionMode_Class->compare(cl))
    append(s, "'ProtectionMode' ", differ_msg);
  if (!(cl = m->getClass("class_update_type")))
    append(s, "'class_update_type' ", not_exit_msg);
  else if (!ClassUpdateType_Class->compare(cl))
    append(s, "'ClassUpdateType' ", differ_msg);
  if (!(cl = m->getClass("attribute_convert_type")))
    append(s, "'attribute_convert_type' ", not_exit_msg);
  else if (!AttributeConvertType_Class->compare(cl))
    append(s, "'AttributeConvertType' ", differ_msg);
  if (!(cl = m->getClass("attribute_component")))
    append(s, "'attribute_component' ", not_exit_msg);
  else if (!AttributeComponent_Class->compare(cl))
    append(s, "'AttributeComponent' ", differ_msg);
  if (!(cl = m->getClass("attribute_component_set")))
    append(s, "'attribute_component_set' ", not_exit_msg);
  else if (!AttributeComponentSet_Class->compare(cl))
    append(s, "'AttributeComponentSet' ", differ_msg);
  if (!(cl = m->getClass("class_component")))
    append(s, "'class_component' ", not_exit_msg);
  else if (!ClassComponent_Class->compare(cl))
    append(s, "'ClassComponent' ", differ_msg);
  if (!(cl = m->getClass("agregat_class_component")))
    append(s, "'agregat_class_component' ", not_exit_msg);
  else if (!AgregatClassComponent_Class->compare(cl))
    append(s, "'AgregatClassComponent' ", differ_msg);
  if (!(cl = m->getClass("class_variable")))
    append(s, "'class_variable' ", not_exit_msg);
  else if (!ClassVariable_Class->compare(cl))
    append(s, "'ClassVariable' ", differ_msg);
  if (!(cl = m->getClass("index")))
    append(s, "'index' ", not_exit_msg);
  else if (!Index_Class->compare(cl))
    append(s, "'Index' ", differ_msg);
  if (!(cl = m->getClass("hashindex")))
    append(s, "'hashindex' ", not_exit_msg);
  else if (!HashIndex_Class->compare(cl))
    append(s, "'HashIndex' ", differ_msg);
  if (!(cl = m->getClass("btreeindex")))
    append(s, "'btreeindex' ", not_exit_msg);
  else if (!BTreeIndex_Class->compare(cl))
    append(s, "'BTreeIndex' ", differ_msg);
  if (!(cl = m->getClass("collection_attribute_implementation")))
    append(s, "'collection_attribute_implementation' ", not_exit_msg);
  else if (!CollAttrImpl_Class->compare(cl))
    append(s, "'CollAttrImpl' ", differ_msg);
  if (!(cl = m->getClass("argtype")))
    append(s, "'argtype' ", not_exit_msg);
  else if (!ArgType_Class->compare(cl))
    append(s, "'ArgType' ", differ_msg);
  if (!(cl = m->getClass("signature")))
    append(s, "'signature' ", not_exit_msg);
  else if (!Signature_Class->compare(cl))
    append(s, "'Signature' ", differ_msg);
  if (!(cl = m->getClass("executable")))
    append(s, "'executable' ", not_exit_msg);
  else if (!Executable_Class->compare(cl))
    append(s, "'Executable' ", differ_msg);
  if (!(cl = m->getClass("agregat_class_executable")))
    append(s, "'agregat_class_executable' ", not_exit_msg);
  else if (!AgregatClassExecutable_Class->compare(cl))
    append(s, "'AgregatClassExecutable' ", differ_msg);
  if (!(cl = m->getClass("method")))
    append(s, "'method' ", not_exit_msg);
  else if (!Method_Class->compare(cl))
    append(s, "'Method' ", differ_msg);
  if (!(cl = m->getClass("fe_method")))
    append(s, "'fe_method' ", not_exit_msg);
  else if (!FEMethod_Class->compare(cl))
    append(s, "'FEMethod' ", differ_msg);
  if (!(cl = m->getClass("fe_method_C")))
    append(s, "'fe_method_C' ", not_exit_msg);
  else if (!FEMethod_C_Class->compare(cl))
    append(s, "'FEMethod_C' ", differ_msg);
  if (!(cl = m->getClass("be_method")))
    append(s, "'be_method' ", not_exit_msg);
  else if (!BEMethod_Class->compare(cl))
    append(s, "'BEMethod' ", differ_msg);
  if (!(cl = m->getClass("be_method_C")))
    append(s, "'be_method_C' ", not_exit_msg);
  else if (!BEMethod_C_Class->compare(cl))
    append(s, "'BEMethod_C' ", differ_msg);
  if (!(cl = m->getClass("be_method_OQL")))
    append(s, "'be_method_OQL' ", not_exit_msg);
  else if (!BEMethod_OQL_Class->compare(cl))
    append(s, "'BEMethod_OQL' ", differ_msg);
  if (!(cl = m->getClass("trigger")))
    append(s, "'trigger' ", not_exit_msg);
  else if (!Trigger_Class->compare(cl))
    append(s, "'Trigger' ", differ_msg);
  if (!(cl = m->getClass("unique_constraint")))
    append(s, "'unique_constraint' ", not_exit_msg);
  else if (!UniqueConstraint_Class->compare(cl))
    append(s, "'UniqueConstraint' ", differ_msg);
  if (!(cl = m->getClass("notnull_constraint")))
    append(s, "'notnull_constraint' ", not_exit_msg);
  else if (!NotNullConstraint_Class->compare(cl))
    append(s, "'NotNullConstraint' ", differ_msg);
  if (!(cl = m->getClass("cardinality_description")))
    append(s, "'cardinality_description' ", not_exit_msg);
  else if (!CardinalityDescription_Class->compare(cl))
    append(s, "'CardinalityDescription' ", differ_msg);
  if (!(cl = m->getClass("cardinality_constraint")))
    append(s, "'cardinality_constraint' ", not_exit_msg);
  else if (!CardinalityConstraint_Class->compare(cl))
    append(s, "'CardinalityConstraint' ", differ_msg);
  if (!(cl = m->getClass("cardinality_constraint_test")))
    append(s, "'cardinality_constraint_test' ", not_exit_msg);
  else if (!CardinalityConstraint_Test_Class->compare(cl))
    append(s, "'CardinalityConstraint_Test' ", differ_msg);
  if (!(cl = m->getClass("protection_user")))
    append(s, "'protection_user' ", not_exit_msg);
  else if (!ProtectionUser_Class->compare(cl))
    append(s, "'ProtectionUser' ", differ_msg);
  if (!(cl = m->getClass("protection")))
    append(s, "'protection' ", not_exit_msg);
  else if (!Protection_Class->compare(cl))
    append(s, "'Protection' ", differ_msg);
  if (!(cl = m->getClass("unreadable_object")))
    append(s, "'unreadable_object' ", not_exit_msg);
  else if (!UnreadableObject_Class->compare(cl))
    append(s, "'UnreadableObject' ", differ_msg);
  if (!(cl = m->getClass("class_conversion")))
    append(s, "'class_conversion' ", not_exit_msg);
  else if (!ClassConversion_Class->compare(cl))
    append(s, "'ClassConversion' ", differ_msg);
  if (s) {Status status = Exception::make(s); free(s); return status;}
  return Success;
}

Bool syscls_set_oid_check(Bool _oid_check)
{
  Bool old = oid_check;
  oid_check = _oid_check;
  return old;
}

Bool syscls_get_oid_check()
{
  return oid_check;
}

}
