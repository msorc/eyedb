\input{start}
\input{version}
\newcommand{\mantitle}{\textsc{Object Definition Language}}
\input{title}

\tableofcontents

\chapter*{The Object Definition Language}

The \eyedb Object Definition Language (ODL) is a specification language
to define the specifications of object types based on the ODMG ODL (but not compliant).\\
ODL \footnote{ODL is used for shortness to denote \eyedb ODL} 
is not intented to be a full programming language. It is
a definition language for object specifications. Database management
systems traditionaly provide facilities that support
data definition (using a Data Definition Language (DDL)). The DDL allows
users to define their data types and interfaces while the
Data Manipulation Language (DML) allows to create, delete, read update
instances of those data types.\\
ODL is a DDL for objects types.
If defines the characteristics of types, including their properties
and operations.
ODL defines only the signatures of operations defined in C++ and does not
address definitions of the methods that implements those operations.
Operations defined in OQL can be defined in the ODL.
\\
ODL is intented to define object types that can be implemented
in a variety of programming languages. Therefore, ODL is not tied
to the syntax of a particular programming language.\\\\
\eyedb ODL differs from ODMG ODL from several points:
\bi
\item ODMG ODL defines class attributes, relationships, method signatures and keys.
It supports nested classes, typedef constructs, constant definitions and
exception hints.
\item \eyedb ODL defines class attributes, relationships, method signatures,
attribute constraints (notnull, unique, collection cardinality), index
specifications and trigger declarations. It does not support
nested classes, typedef constructs, constant definitions and
exception hints.
\item in \eyedb ODL, any type instance can be both a literal or
an object. In ODMG ODL, this property is tied to the type: all
basic types and user defined \emph{struct} are literal while \emph{interface}s
and \emph{class}es are objects.
In \eyedb ODL, any type instance can be an object, even the basic types.
\item at last, \eyedb ODL allows to specify whether a method is executed by the server or by the client,
and whether it is a class or instance method.
\ei

\sect{The Language Specifications}

The basic concept of the \eyedb object model is the class which, as in any
traditionnal object model, modelize a set
of objects of similar properties (attributes) and behaviors (methods).
The attributes can be basic types, user types, references, arrays, collections.
The methods can be defined in C++ or in OQL (Object Query Language).
\\
\\
ODL allows one to specify classes, attributes, methods, triggers, constraints,
enumerate types, indexes and implementation hints.
\\
\\
We are going to introduced in details all the features of ODL.
\subsect{Basic types}
The basic types are as follows:\\\\
\begin{tabular}{|p{2cm}|p{5cm}|}
\hline
byte & 1-byte integer \\
\hline
char & 1-byte character \\
\hline
short & 2-byte integer \\
\hline
int & 4-byte integer \\
\hline
long & 8-byte integer \\
\hline
double & 8-byte floating point \\
\hline
oid & 8-byte internal object identifier \\
\hline
enum & 4-byte integer \\
\hline
\end{tabular}
\\
For instance:
\vspace{-0.2cm}
\begin{verbatim}
class C {
  attribute byte b;
  attribute char c;
  attribute short s;
  attribute int i;
  attribute long l;
  attribute double d;
  attribute oid o;
};
\end{verbatim}
Notes :
\be
\vspace{-0.2cm}
\item The key word \texttt{attribute} is optional:
\vspace{-0.2cm}
\begin{verbatim}
class C {
  byte b;
  char c;
  // ...
};
\end{verbatim}
\vspace{-0.2cm}
is correct.
\item The grammar does not allow one to gather several attributes on
the same line declaration:
\vspace{-0.2cm}
\begin{verbatim}
class C {
  attribute char c1, c2, c3; // is NOT correct
  // ...
};
\end{verbatim}
\ee
\subsect{Array types}
The object model supports multi-dimensionnal fixed or variable size arrays
of any type. For instance:
\vspace{-0.2cm}
\begin{verbatim}
class C {
  attribute byte b_a[4];      // fixed length mono-dimensionnal array
  attribute char str[];       // variable size mono-dimensionnal array
  attribute int i_a[3][4][8]; // multi-dimensionnal fixed size array
  attribute long l_a[][4][8]; // multi-dimensionnal variable size array
};
\end{verbatim}
%\vspace{-0.2cm}
One particular interesting array type is the array of characters, which
can be denoted as \texttt{string} as follows:
\vspace{-0.2cm}
\begin{verbatim}
class C {
  attribute string s;       // <=> char s[] (unlimited size string)
  attribute string<32> bs;  // <=> char bs[32] (bounded string)
};
\end{verbatim}
%\vspace{-0.2cm}
Note that in a multi-dimensionnal array, only the extreme left dimension can be
variable:
\vspace{-0.2cm}
\begin{verbatim}
class C {
  attribute long l_a1[][4][8]; // correct
  attribute long l_a2[4][][8]; // NOT correct
  attribute long l_a2[4][8][]; // NOT correct
};
\end{verbatim}
\subsect{Literal and object types}
Remember that each object in a set of \eyedb databases has an unique identifier called OID.
\\
A literal attribute is an attribute fully included in the class and has
no OID, while an object attribute denotes the reference
to another object with an object identifier.
A reference attribute is denoted by a \texttt{*} or a \texttt{\&} symbol.
For instance:
\vspace{-0.2cm}
\begin{verbatim}
class C1 {
  attribute int i;
};

class C {
  attribute C1  l_c1;  // literal attribute included in C
  attribute C1 *o_c1;  // object attribute referenced by C (or &oc1_1)
};
\end{verbatim}
Let \texttt{c} an instance of the class \texttt{C}.
\bi
\item \texttt{c} includes a literal of type \texttt{C1} through the attribute
\texttt{l\_c1}
\item \texttt{c} can reference an object of type \texttt{C1} through the attributes 
\texttt{o\_c1}
\item if \texttt{c} is removed from the database, the attribute \texttt{l\_c1}
is removed at the same time, but the object denoted by \texttt{o\_c1} is
not removed
\ei
\begin{tabular}{|p{16.8cm}|}
\hline
\vspace{0.1mm}
Do not confuse the \texttt{*} ODL meaning and the \texttt{*} C/C++ meaning:
in C/C++, the \texttt{*} type modifier denotes an address to an area of the
indicated type instances: it is a pointer to an address. This pointer
can be incremented and decremented to change its location in the area.
\\
In ODL, the \texttt{*} denotes a reference to one and only one object, it is why
the \texttt{\&} token is also accepted, although the meaning of this token
is a little bit different in C++.
\\
\\
So, in ODL the construct \texttt{C1 **oc1} makes no sense, in the same
manner that the construct \texttt{C1 \&\&oc1} makes no sense in C++.\\
\hline
\end{tabular}\\
\\
One can have arrays of litteral or object as follows:
\vspace{-0.2cm}
\begin{verbatim}
class C {
  attribute C1  l_c1_1[2];
  attribute C1  l_c1_2[];
  attribute C1  l_c1_3[][10][20];

  attribute C1 *o_c1_1[4];
  attribute C1 *o_c1_2[];
  attribute C1 *o_c1_3[][4][5];
};
\end{verbatim}

\subsect{Collection types}
The \eyedb object model support three types of collections, set, bag and array. A fourth type, list, will be implemented in a further version:
\bi
\item a set an unordered collection of elements of the same type
not allowing duplicate elements
\item a bag a unordered collection of elements of the same type
allowing duplicate elements
\item an array an ordered collection of elements of the same type
allowing duplicate elements
\item a list (\emph{non yet implemented}) is an ordered collections of elements of
the same type allowing duplicate elements
and where element insertion and removal is
efficiently implemented
\ei
An element may be of any type, literal or object and
a collection attribute may be a literal or an object, and one can have
arrays of collection, for instance:
\vspace{-0.2cm}
\begin{verbatim}
class C {
  attribute set<int>  i_lset;    // literal set of int
  attribute set<C1>   l_c1_lset; // literal set of C1 literals
  attribute set<C1 *> o_c1_lset; // literal set of C1 objects

  attribute set<int>  *i_oset;    // object set of int
  attribute set<C1>   *l_c1_oset; // object set of C1 literals
  attribute set<C1 *> *o_c1_oset; // object set of C1 objects

  attribute bag<C1 *> o_c1_lbag;  // literal bag of C1 objects

  attribute array<C1 *> o_c1_larr;   // literal array of C1 objects
  attribute bag<C1 *>   o_c1_lbag[]; // array of literal bag of C1 objects

  // multi-dimensionnal array of literal bag of set of array of C1 objects
  attribute bag<set<array<set<C1 *> > > > x[2][3][4]; 
};
\end{verbatim}
The differences between an array collection (i.e.
\texttt{array<}\emph{type}\texttt{>} and an attribute array (i.e. 
\emph{type} \texttt{[]}) are:
\bi
\item a collection array may exists independently from any class as a
an attribute array exists only within a class
\item the implementation is very different:
\bi
\item one can have a big collection array (thousand or millions of elements)
without loss of performance (if the collection is well parametered, see
below)). Big attribute array are unefficient
\item collection array can have ``holes'' without loss of performance, for instance an element at index 1 and another one at index 1000000 and nothing between. An attribute array with holes are unefficient as they are stored
consecutively
\item a collection array is heavier than an attribute array, and so is not
recommended for little size
\ei
\ei

\subsect{Inheritance}
The object model support single inheritance using the keyword \texttt{extends}:
\vspace{-0.2cm}
\begin{verbatim}
class C1 {
  attribute string c1;
};

class C2 extends C1 {
  attribute string c2;
};

class C3 extends C2 {
  attribute string c3;
};
\end{verbatim}
As in usual object conception, an object of class \texttt{C2} includes the two
attributes \texttt{c1} and \texttt{c2} and an object of class \texttt{C3}
includes the three attributes \texttt{c1}, \texttt{c2} and \texttt{c3}.
\\
\\
In the following construct:
%\vspace{-0.2cm}
\begin{verbatim}
class C4 {
  attribute C1 *oc1;
  attribute C2 *oc2;
  attribute C3 *oc3;

  attribute C1 lc1;
  attribute C2 lc2;
  attribute C3 lc3;
};
\end{verbatim}
The attribute \texttt{oc1} may be of type \texttt{C1}, \texttt{C2} or
\texttt{C3}.\\
The attribute \texttt{oc2} may be of type \texttt{C2} or \texttt{C3}.\\
The attribute \texttt{oc3} may be of type \texttt{C3} only.\\
The attribute \texttt{lc1} is of type \texttt{C1}.\\
The attribute \texttt{lc2} is of type \texttt{C2}.\\
The attribute \texttt{lc3} is of type \texttt{C3}.


\subsect{Constraints}
The object model supports currently two declarative constraints: notnull
and unique. The cardinality constraint on collection is partially
implemented and is not currently supported.
Non declarative constraints are defined using triggers (see below).
\\
\\
Note that:
\bi
\item unique constraint cannot be defined on several attributes and
\item unique constraint on an attribute needs an index. The index is not
automatically created, it must be defined in the ODL (see below)
or outside using the \texttt{idxcreate} tool.
\ei
For instance:
\vspace{-0.2cm}
\begin{verbatim}
class C {
  attribute string s1;
  attribute string s2;
  attribute string s3;

  constraint<notnull> on s1;

  constraint<notnull> on s2;
  constraint<unique> on s2;

  constraint<unique> on s3;
};
\end{verbatim}
The attribute \texttt{s1} must not be null.\\
The attribute \texttt{s2} must not be null and is unique in the collection
of C objects.\\
The attribute \texttt{s3} is unique in the collection
of C objects.
\subsubsect{Constraint and inheritance propagation}
By default, constraints are propagated to subclasses, let \texttt{C2}
a subclass of \texttt{C}:
\vspace{-0.2cm}
\begin{verbatim}
class C2 extends C {
  attribute string c2;
};
\end{verbatim}
When one creates an \texttt{C2} object, the attributes \texttt{s1} and
\texttt{s2} must not be null and the attributes \texttt{s2} and
\texttt{s3} must be unique.\\
\\
Important note: the unique constraint applies separately on each class
(\texttt{C} and \texttt{C2}) and not on the set of inheritance class tree.
This means that one can have a \texttt{C} object with a given value
for \texttt{s2} and a \texttt{C2} object with the same value for \texttt{s2}.
\\
This is not the expected default behavior and will
can be parametrised in a next version.
\\
\\
If you do no want to propagate automatically a constraint to the subclasses,
you need to use the construct \texttt{propagate = off} as follows:
\vspace{-0.2cm}
\begin{verbatim}
class C {
  attribute string s1;
  attribute string s2;
  attribute string s3;

  constraint<notnull, propagate = off> on s1;

  constraint<notnull> on s2;
  constraint<unique, propagate = off> on s2;

  constraint<unique> on s3;
};

class C2 extends C {
  attribute string c2;
};
\end{verbatim}
The notnull constraint on \texttt{C::s1} and the unique constraint
on \texttt{C1::s2} will not be propagated to \texttt{C2}, but the
notnull constraint on \texttt{C::s1} and the unique constraint on
\texttt{C::s3} will be propagated to \texttt{C2}.

\subsubsect{Constraint on attribute of literal composite type}
One can define constraints on attributes of literal composite type
attribute, for instance:
\vspace{-0.2cm}
\begin{verbatim}
class C1 {
  attribute string s1;
  attribute int i1;
};

class C {
  attribute C1 c1;
 
  constraint<notnull> on c1.s1;
  constraint<unique> on c1.i1;
};
\end{verbatim}

\subsect{Referential integrity}
The \eyedb object model support one-to-one, one-to-many and many-to-many
relationships. 
\\
\\
A relationship between a class \texttt{A} and a class \texttt{B} is
materialized by attributes in the two classes of the following
types according to the cardinality of the relationship:
\bi
\item one-to-one : \texttt{A} contains an attribute of type \texttt{B *} and
\texttt{A} contains an attribute  of type \texttt{B *}
\item one-to-many : \texttt{A} contains an attribute of type \emph{collection}\texttt{<B *>} (\emph{collection} is a set or a bag) and
\texttt{A} contains an attribute  of type \texttt{B *}
\item many-to-many : \texttt{A} contains an attribute of type \emph{collection}\texttt{<B *>} and
\texttt{A} contains an attribute  of type \emph{collection}\texttt{<B *}
\ei
For instance for a one-to-one relationship:
\vspace{-0.2cm}
\begin{verbatim}
class A {
  attribute string sa;
  attribute B *b;
};

class B {
  attribute string sb;
  attribute A *a;
};
\end{verbatim}
In the previous cas, \eyedb maintains only partially the referential
integrity: for instance, one cannot create an object \texttt{A}
with an attribute \texttt{b} which refers an non-existent \texttt{B}
object. But, if the referenced \texttt{B} object is removed, the attribute
\texttt{b} will still referenced the removed object.
\\
\\
\eyedb can maintain the referential integrity by indicating the
\texttt{inverse directive} in the ODL as follows:
\vspace{-0.2cm}
\begin{verbatim}
class A {
  attribute string sa;
  relationship B *b inverse B::b; // or inverse b
};

class B {
  attribute string sb;
  relationship A *a inverse A::b; // or inverse a
};
\end{verbatim}
Note \texttt{attribute} has been replaced by \texttt{relationship} in
this case: this is mandatory.
\\
In this case, if the \texttt{B} object referenced by a \texttt{A} object
through \texttt{b} is removed, \texttt{b} is set to the null value.
\\
A one-to-many relationship:
\vspace{-0.2cm}
\begin{verbatim}
class A {
  attribute string sa;
  relationship set<B *> b_set inverse a;
};

class B {
  attribute string sb;
  relationship A *a inverse b_set;;
};
\end{verbatim}
and a many-to-many relationship:
\vspace{-0.2cm}
\begin{verbatim}
class A {
  attribute string sa;
  relationship set<B *> b_set inverse a_set;
};

class B {
  attribute string sb;
  relationship set<A *> a_set inverse b_set;;
};
\end{verbatim}

\subsect{Methodes}
In ODL, one can declared the signature of C++ and OQL methods
and one can defined the body of OQL methods.
By default, a method is executed on the server side.
\\
A method argument can be any basic type, reference on a composite type or
mono-dimensionnal array of basic or composite type. An argument
can be \texttt{in}, \texttt{out} or \texttt{inout}.
Argument may be named or unnamed (only type is given), for instance:
\vspace{-0.2cm}
\begin{verbatim}
class C1 {
  attribute string c1;
};

class C2 {
  attribute string c2;
  int perform(in int size, in string str, out double, in C1 &, inout C2 &);
};
\end{verbatim}
Note that the \texttt{\&} symbol may be replaced by the \texttt{*} symbol
or no symbol as anyhow only a persistent object (not a litteral) may
be passed to a method call.
\\
\\
The \texttt{C::perform} method must be defined in C++ but may be called
from OQL or a C++ client. To define a C++ method, refer to the
document \emph{C++ Binding}.
\\
\\
Methods can be overloaded (same name but different signatures), for instance:
\vspace{-0.2cm}
\begin{verbatim}
class C2 {
  attribute string c2;
  int perform(in int size, in string str, out double, in C1 &, inout C2 &);
  int perform(in double, out string mystr);
};
\end{verbatim}
One can defined OQL methods in ODL. In this case, the name of the
arguments must be given:
\vspace{-0.2cm}
\begin{verbatim}
class C2 {
  attribute string c2;
  int append(in string s) %oql{
    this.s2 += s;
    return strlen(this.s);
  %}
};
\end{verbatim}
The OQL \texttt{this} variable denotes the calling instance.
\\
\\
A method can be an instance method (the default) or a class method (equivalent
to C++ or Java static methods). To defined a class method, there are
two constructs, using the keyword \texttt{static} or \texttt{classmethod}:
\vspace{-0.2cm}
\begin{verbatim}
class C {
  static int perform1(in string); // or
  classmethod int perform2(in string);

  instmethod int perform3(in string); // <=> int perform3(in string)
};
\end{verbatim}
If you want to execute a method on the client side, you must
use the keyword \texttt{client} as follows:
\vspace{-0.2cm}
\begin{verbatim}
class C {
  instmethod<client> int perform1(in string);
  classmethod<client> int perform2(in string);

  instmethod<server> int perform3(in string);  // <=> int perform3(...)
  classmethod<server> int perform4(in string); // <=> classmethod perform3(...)
};
\end{verbatim}

\subsect{Triggers}
Triggers are server methods which are executed when a particular
event occurs on an object: before or after creation, update, load or delete.
\\
Like methods, a trigger can be written in C++ or in OQL. On the other
hand a trigger has no argument but has a name;
\vspace{-0.2cm}
\begin{verbatim}
class C {
   attribute string s;
   trigger<create_before> c_b();
   trigger<create_after> c_a();

   trigger<update_before> u_b();
   trigger<update_after> u_a();

   trigger<load_before> l_a();
   trigger<load_after> l_b();

   trigger<remove_before> r_b();
   trigger<remove_after> r_a();

   trigger<create_before> c_b2(); // one can have several create_before triggers
};
\end{verbatim}


\subsect{Indexes}

\subsect{Advances features}
  collection implementation
  class implementation ??
  index specification
  name alias
  quoted sequences
  client methods

\sect{Concrete examples}

\end{document}
